/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#include "dispatcher.h"
#include "core.h"
#include "mcoputils.h"
#include "idlfilereg.h"
#include "common.tcc"

// Implementation
Arts::Header::Header()
{
}

Arts::Header::Header(Arts::HeaderMagic _a_magic, long _a_messageLength, Arts::MessageType _a_messageType)
{
	this->magic = _a_magic;
	this->messageLength = _a_messageLength;
	this->messageType = _a_messageType;
}

Arts::Header::Header(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::Header::Header(const Arts::Header& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::Header& Arts::Header::operator=(const Arts::Header& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::Header::readType(Arts::Buffer& stream)
{
	magic = (Arts::HeaderMagic)stream.readLong();
	messageLength = stream.readLong();
	messageType = (Arts::MessageType)stream.readLong();
}

void Arts::Header::writeType(Arts::Buffer& stream) const
{
	stream.writeLong(magic);
	stream.writeLong(messageLength);
	stream.writeLong(messageType);
}

Arts::Invocation::Invocation()
{
}

Arts::Invocation::Invocation(long _a_objectID, long _a_methodID, long _a_requestID)
{
	this->objectID = _a_objectID;
	this->methodID = _a_methodID;
	this->requestID = _a_requestID;
}

Arts::Invocation::Invocation(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::Invocation::Invocation(const Arts::Invocation& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::Invocation& Arts::Invocation::operator=(const Arts::Invocation& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::Invocation::readType(Arts::Buffer& stream)
{
	objectID = stream.readLong();
	methodID = stream.readLong();
	requestID = stream.readLong();
}

void Arts::Invocation::writeType(Arts::Buffer& stream) const
{
	stream.writeLong(objectID);
	stream.writeLong(methodID);
	stream.writeLong(requestID);
}

Arts::OnewayInvocation::OnewayInvocation()
{
}

Arts::OnewayInvocation::OnewayInvocation(long _a_objectID, long _a_methodID)
{
	this->objectID = _a_objectID;
	this->methodID = _a_methodID;
}

Arts::OnewayInvocation::OnewayInvocation(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::OnewayInvocation::OnewayInvocation(const Arts::OnewayInvocation& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::OnewayInvocation& Arts::OnewayInvocation::operator=(const Arts::OnewayInvocation& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::OnewayInvocation::readType(Arts::Buffer& stream)
{
	objectID = stream.readLong();
	methodID = stream.readLong();
}

void Arts::OnewayInvocation::writeType(Arts::Buffer& stream) const
{
	stream.writeLong(objectID);
	stream.writeLong(methodID);
}

Arts::ServerHello::ServerHello()
{
}

Arts::ServerHello::ServerHello(const std::string& _a_mcopVersion, const std::string& _a_serverID, const std::vector<std::string>& _a_authProtocols, const std::string& _a_authSeed)
{
	this->mcopVersion = _a_mcopVersion;
	this->serverID = _a_serverID;
	this->authProtocols = _a_authProtocols;
	this->authSeed = _a_authSeed;
}

Arts::ServerHello::ServerHello(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::ServerHello::ServerHello(const Arts::ServerHello& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::ServerHello& Arts::ServerHello::operator=(const Arts::ServerHello& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::ServerHello::readType(Arts::Buffer& stream)
{
	stream.readString(mcopVersion);
	stream.readString(serverID);
	stream.readStringSeq(authProtocols);
	stream.readString(authSeed);
}

void Arts::ServerHello::writeType(Arts::Buffer& stream) const
{
	stream.writeString(mcopVersion);
	stream.writeString(serverID);
	stream.writeStringSeq(authProtocols);
	stream.writeString(authSeed);
}

Arts::ClientHello::ClientHello()
{
}

Arts::ClientHello::ClientHello(const std::string& _a_serverID, const std::string& _a_authProtocol, const std::string& _a_authData)
{
	this->serverID = _a_serverID;
	this->authProtocol = _a_authProtocol;
	this->authData = _a_authData;
}

Arts::ClientHello::ClientHello(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::ClientHello::ClientHello(const Arts::ClientHello& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::ClientHello& Arts::ClientHello::operator=(const Arts::ClientHello& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::ClientHello::readType(Arts::Buffer& stream)
{
	stream.readString(serverID);
	stream.readString(authProtocol);
	stream.readString(authData);
}

void Arts::ClientHello::writeType(Arts::Buffer& stream) const
{
	stream.writeString(serverID);
	stream.writeString(authProtocol);
	stream.writeString(authData);
}

Arts::AuthAccept::AuthAccept()
{
}

Arts::AuthAccept::AuthAccept(const std::vector<std::string>& _a_hints)
{
	this->hints = _a_hints;
}

Arts::AuthAccept::AuthAccept(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::AuthAccept::AuthAccept(const Arts::AuthAccept& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::AuthAccept& Arts::AuthAccept::operator=(const Arts::AuthAccept& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::AuthAccept::readType(Arts::Buffer& stream)
{
	stream.readStringSeq(hints);
}

void Arts::AuthAccept::writeType(Arts::Buffer& stream) const
{
	stream.writeStringSeq(hints);
}

Arts::ObjectReference::ObjectReference()
{
}

Arts::ObjectReference::ObjectReference(const std::string& _a_serverID, long _a_objectID, const std::vector<std::string>& _a_urls)
{
	this->serverID = _a_serverID;
	this->objectID = _a_objectID;
	this->urls = _a_urls;
}

Arts::ObjectReference::ObjectReference(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::ObjectReference::ObjectReference(const Arts::ObjectReference& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::ObjectReference& Arts::ObjectReference::operator=(const Arts::ObjectReference& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::ObjectReference::readType(Arts::Buffer& stream)
{
	stream.readString(serverID);
	objectID = stream.readLong();
	stream.readStringSeq(urls);
}

void Arts::ObjectReference::writeType(Arts::Buffer& stream) const
{
	stream.writeString(serverID);
	stream.writeLong(objectID);
	stream.writeStringSeq(urls);
}

Arts::ParamDef::ParamDef()
{
}

Arts::ParamDef::ParamDef(const std::string& _a_type, const std::string& _a_name, const std::vector<std::string>& _a_hints)
{
	this->type = _a_type;
	this->name = _a_name;
	this->hints = _a_hints;
}

Arts::ParamDef::ParamDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::ParamDef::ParamDef(const Arts::ParamDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::ParamDef& Arts::ParamDef::operator=(const Arts::ParamDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::ParamDef::readType(Arts::Buffer& stream)
{
	stream.readString(type);
	stream.readString(name);
	stream.readStringSeq(hints);
}

void Arts::ParamDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(type);
	stream.writeString(name);
	stream.writeStringSeq(hints);
}

Arts::MethodDef::MethodDef()
{
}

Arts::MethodDef::MethodDef(const std::string& _a_name, const std::string& _a_type, Arts::MethodType _a_flags, const std::vector<Arts::ParamDef>& _a_signature, const std::vector<std::string>& _a_hints)
{
	this->name = _a_name;
	this->type = _a_type;
	this->flags = _a_flags;
	this->signature = _a_signature;
	this->hints = _a_hints;
}

Arts::MethodDef::MethodDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::MethodDef::MethodDef(const Arts::MethodDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::MethodDef& Arts::MethodDef::operator=(const Arts::MethodDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::MethodDef::readType(Arts::Buffer& stream)
{
	stream.readString(name);
	stream.readString(type);
	flags = (Arts::MethodType)stream.readLong();
	readTypeSeq(stream,signature);
	stream.readStringSeq(hints);
}

void Arts::MethodDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(name);
	stream.writeString(type);
	stream.writeLong(flags);
	Arts::writeTypeSeq(stream,signature);
	stream.writeStringSeq(hints);
}

Arts::AttributeDef::AttributeDef()
{
}

Arts::AttributeDef::AttributeDef(const std::string& _a_name, const std::string& _a_type, Arts::AttributeType _a_flags, const std::vector<std::string>& _a_hints)
{
	this->name = _a_name;
	this->type = _a_type;
	this->flags = _a_flags;
	this->hints = _a_hints;
}

Arts::AttributeDef::AttributeDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::AttributeDef::AttributeDef(const Arts::AttributeDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::AttributeDef& Arts::AttributeDef::operator=(const Arts::AttributeDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::AttributeDef::readType(Arts::Buffer& stream)
{
	stream.readString(name);
	stream.readString(type);
	flags = (Arts::AttributeType)stream.readLong();
	stream.readStringSeq(hints);
}

void Arts::AttributeDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(name);
	stream.writeString(type);
	stream.writeLong(flags);
	stream.writeStringSeq(hints);
}

Arts::InterfaceDef::InterfaceDef()
{
}

Arts::InterfaceDef::InterfaceDef(const std::string& _a_name, const std::vector<std::string>& _a_inheritedInterfaces, const std::vector<Arts::MethodDef>& _a_methods, const std::vector<Arts::AttributeDef>& _a_attributes, const std::vector<std::string>& _a_defaultPorts, const std::vector<std::string>& _a_hints)
{
	this->name = _a_name;
	this->inheritedInterfaces = _a_inheritedInterfaces;
	this->methods = _a_methods;
	this->attributes = _a_attributes;
	this->defaultPorts = _a_defaultPorts;
	this->hints = _a_hints;
}

Arts::InterfaceDef::InterfaceDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::InterfaceDef::InterfaceDef(const Arts::InterfaceDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::InterfaceDef& Arts::InterfaceDef::operator=(const Arts::InterfaceDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::InterfaceDef::readType(Arts::Buffer& stream)
{
	stream.readString(name);
	stream.readStringSeq(inheritedInterfaces);
	readTypeSeq(stream,methods);
	readTypeSeq(stream,attributes);
	stream.readStringSeq(defaultPorts);
	stream.readStringSeq(hints);
}

void Arts::InterfaceDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(name);
	stream.writeStringSeq(inheritedInterfaces);
	Arts::writeTypeSeq(stream,methods);
	Arts::writeTypeSeq(stream,attributes);
	stream.writeStringSeq(defaultPorts);
	stream.writeStringSeq(hints);
}

Arts::TypeComponent::TypeComponent()
{
}

Arts::TypeComponent::TypeComponent(const std::string& _a_type, const std::string& _a_name, const std::vector<std::string>& _a_hints)
{
	this->type = _a_type;
	this->name = _a_name;
	this->hints = _a_hints;
}

Arts::TypeComponent::TypeComponent(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::TypeComponent::TypeComponent(const Arts::TypeComponent& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::TypeComponent& Arts::TypeComponent::operator=(const Arts::TypeComponent& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::TypeComponent::readType(Arts::Buffer& stream)
{
	stream.readString(type);
	stream.readString(name);
	stream.readStringSeq(hints);
}

void Arts::TypeComponent::writeType(Arts::Buffer& stream) const
{
	stream.writeString(type);
	stream.writeString(name);
	stream.writeStringSeq(hints);
}

Arts::TypeDef::TypeDef()
{
}

Arts::TypeDef::TypeDef(const std::string& _a_name, const std::vector<Arts::TypeComponent>& _a_contents, const std::vector<std::string>& _a_hints)
{
	this->name = _a_name;
	this->contents = _a_contents;
	this->hints = _a_hints;
}

Arts::TypeDef::TypeDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::TypeDef::TypeDef(const Arts::TypeDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::TypeDef& Arts::TypeDef::operator=(const Arts::TypeDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::TypeDef::readType(Arts::Buffer& stream)
{
	stream.readString(name);
	readTypeSeq(stream,contents);
	stream.readStringSeq(hints);
}

void Arts::TypeDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(name);
	Arts::writeTypeSeq(stream,contents);
	stream.writeStringSeq(hints);
}

Arts::EnumComponent::EnumComponent()
{
}

Arts::EnumComponent::EnumComponent(const std::string& _a_name, long _a_value, const std::vector<std::string>& _a_hints)
{
	this->name = _a_name;
	this->value = _a_value;
	this->hints = _a_hints;
}

Arts::EnumComponent::EnumComponent(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::EnumComponent::EnumComponent(const Arts::EnumComponent& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::EnumComponent& Arts::EnumComponent::operator=(const Arts::EnumComponent& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::EnumComponent::readType(Arts::Buffer& stream)
{
	stream.readString(name);
	value = stream.readLong();
	stream.readStringSeq(hints);
}

void Arts::EnumComponent::writeType(Arts::Buffer& stream) const
{
	stream.writeString(name);
	stream.writeLong(value);
	stream.writeStringSeq(hints);
}

Arts::EnumDef::EnumDef()
{
}

Arts::EnumDef::EnumDef(const std::string& _a_name, const std::vector<Arts::EnumComponent>& _a_contents, const std::vector<std::string>& _a_hints)
{
	this->name = _a_name;
	this->contents = _a_contents;
	this->hints = _a_hints;
}

Arts::EnumDef::EnumDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::EnumDef::EnumDef(const Arts::EnumDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::EnumDef& Arts::EnumDef::operator=(const Arts::EnumDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::EnumDef::readType(Arts::Buffer& stream)
{
	stream.readString(name);
	readTypeSeq(stream,contents);
	stream.readStringSeq(hints);
}

void Arts::EnumDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(name);
	Arts::writeTypeSeq(stream,contents);
	stream.writeStringSeq(hints);
}

Arts::ModuleDef::ModuleDef()
{
}

Arts::ModuleDef::ModuleDef(const std::string& _a_moduleName, const std::vector<Arts::EnumDef>& _a_enums, const std::vector<Arts::TypeDef>& _a_types, const std::vector<Arts::InterfaceDef>& _a_interfaces, const std::vector<std::string>& _a_hints)
{
	this->moduleName = _a_moduleName;
	this->enums = _a_enums;
	this->types = _a_types;
	this->interfaces = _a_interfaces;
	this->hints = _a_hints;
}

Arts::ModuleDef::ModuleDef(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::ModuleDef::ModuleDef(const Arts::ModuleDef& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::ModuleDef& Arts::ModuleDef::operator=(const Arts::ModuleDef& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::ModuleDef::readType(Arts::Buffer& stream)
{
	stream.readString(moduleName);
	readTypeSeq(stream,enums);
	readTypeSeq(stream,types);
	readTypeSeq(stream,interfaces);
	stream.readStringSeq(hints);
}

void Arts::ModuleDef::writeType(Arts::Buffer& stream) const
{
	stream.writeString(moduleName);
	Arts::writeTypeSeq(stream,enums);
	Arts::writeTypeSeq(stream,types);
	Arts::writeTypeSeq(stream,interfaces);
	stream.writeStringSeq(hints);
}

Arts::Any::Any()
{
}

Arts::Any::Any(const std::string& _a_type, const std::vector<Arts::mcopbyte>& _a_value)
{
	this->type = _a_type;
	this->value = _a_value;
}

Arts::Any::Any(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::Any::Any(const Arts::Any& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::Any& Arts::Any::operator=(const Arts::Any& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::Any::readType(Arts::Buffer& stream)
{
	stream.readString(type);
	stream.readByteSeq(value);
}

void Arts::Any::writeType(Arts::Buffer& stream) const
{
	stream.writeString(type);
	stream.writeByteSeq(value);
}

Arts::TraderEntry::TraderEntry()
{
}

Arts::TraderEntry::TraderEntry(const std::string& _a_interfaceName, const std::vector<std::string>& _a_lines)
{
	this->interfaceName = _a_interfaceName;
	this->lines = _a_lines;
}

Arts::TraderEntry::TraderEntry(Arts::Buffer& stream)
{
	readType(stream);
}

Arts::TraderEntry::TraderEntry(const Arts::TraderEntry& copyType) : Arts::Type(copyType)
{
	Arts::Buffer buffer;
	copyType.writeType(buffer);
	readType(buffer);
}

Arts::TraderEntry& Arts::TraderEntry::operator=(const Arts::TraderEntry& assignType)
{
	Arts::Buffer buffer;
	assignType.writeType(buffer);
	readType(buffer);
	return *this;
}

void Arts::TraderEntry::readType(Arts::Buffer& stream)
{
	stream.readString(interfaceName);
	stream.readStringSeq(lines);
}

void Arts::TraderEntry::writeType(Arts::Buffer& stream) const
{
	stream.writeString(interfaceName);
	stream.writeStringSeq(lines);
}

Arts::InterfaceRepo_base *Arts::InterfaceRepo_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::InterfaceRepo_base *castedObject = (Arts::InterfaceRepo_base *)skel->_cast(Arts::InterfaceRepo_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::InterfaceRepo_base *Arts::InterfaceRepo_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::InterfaceRepo_base::_fromReference(r,true);
	return 0;
}

Arts::InterfaceRepo_base *Arts::InterfaceRepo_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::InterfaceRepo_base *castedObject = (Arts::InterfaceRepo_base *)object._base()->_cast(Arts::InterfaceRepo_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::InterfaceRepo_base *Arts::InterfaceRepo_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::InterfaceRepo_base *result;
	result = (Arts::InterfaceRepo_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::InterfaceRepo");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::InterfaceRepo_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::InterfaceRepo")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::InterfaceRepo_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::InterfaceRepo_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::InterfaceRepo_base::_cast(unsigned long iid)
{
	if(iid == Arts::InterfaceRepo_base::_IID) return (Arts::InterfaceRepo_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::InterfaceRepo_stub::InterfaceRepo_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::InterfaceRepo_stub::InterfaceRepo_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

long Arts::InterfaceRepo_stub::insertModule(const Arts::ModuleDef& newModule)
{
	long methodID = _lookupMethodFast("method:0000000d696e736572744d6f64756c6500000000056c6f6e6700000000020000000100000010417274733a3a4d6f64756c65446566000000000a6e65774d6f64756c65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	newModule.writeType(*request);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occured
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

void Arts::InterfaceRepo_stub::removeModule(long moduleID)
{
	long methodID = _lookupMethodFast("method:0000000d72656d6f76654d6f64756c650000000005766f6964000000000200000001000000056c6f6e6700000000096d6f64756c654944000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeLong(moduleID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

Arts::InterfaceDef Arts::InterfaceRepo_stub::queryInterface(const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000f7175657279496e746572666163650000000013417274733a3a496e7465726661636544656600000000020000000100000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return Arts::InterfaceDef(); // error occured
	Arts::InterfaceDef _returnCode(*result);
	delete result;
	return _returnCode;
}

Arts::TypeDef Arts::InterfaceRepo_stub::queryType(const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000a717565727954797065000000000e417274733a3a5479706544656600000000020000000100000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return Arts::TypeDef(); // error occured
	Arts::TypeDef _returnCode(*result);
	delete result;
	return _returnCode;
}

Arts::EnumDef Arts::InterfaceRepo_stub::queryEnum(const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000a7175657279456e756d000000000e417274733a3a456e756d44656600000000020000000100000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return Arts::EnumDef(); // error occured
	Arts::EnumDef _returnCode(*result);
	delete result;
	return _returnCode;
}

std::vector<std::string> * Arts::InterfaceRepo_stub::queryChildren(const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000e71756572794368696c6472656e00000000082a737472696e6700000000020000000100000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<std::string> *_returnCode = new std::vector<std::string>;
	if(!result) return _returnCode; // error occured
	result->readStringSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::vector<std::string> * Arts::InterfaceRepo_stub::queryInterfaces()
{
	long methodID = _lookupMethodFast("method:000000107175657279496e746572666163657300000000082a737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<std::string> *_returnCode = new std::vector<std::string>;
	if(!result) return _returnCode; // error occured
	result->readStringSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::vector<std::string> * Arts::InterfaceRepo_stub::queryTypes()
{
	long methodID = _lookupMethodFast("method:0000000b7175657279547970657300000000082a737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<std::string> *_returnCode = new std::vector<std::string>;
	if(!result) return _returnCode; // error occured
	result->readStringSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::vector<std::string> * Arts::InterfaceRepo_stub::queryEnums()
{
	long methodID = _lookupMethodFast("method:0000000b7175657279456e756d7300000000082a737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<std::string> *_returnCode = new std::vector<std::string>;
	if(!result) return _returnCode; // error occured
	result->readStringSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::string Arts::InterfaceRepo_skel::_interfaceName()
{
	return "Arts::InterfaceRepo";
}

bool Arts::InterfaceRepo_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::InterfaceRepo") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::InterfaceRepo_skel::_interfaceNameSkel()
{
	return "Arts::InterfaceRepo";
}

// insertModule
static void _dispatch_Arts_InterfaceRepo_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	Arts::ModuleDef newModule(*request);
	result->writeLong(((Arts::InterfaceRepo_skel *)object)->insertModule(newModule));
}

// removeModule
static void _dispatch_Arts_InterfaceRepo_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	long moduleID = request->readLong();
	((Arts::InterfaceRepo_skel *)object)->removeModule(moduleID);
}

// queryInterface
static void _dispatch_Arts_InterfaceRepo_02(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string name;
	request->readString(name);
	Arts::InterfaceDef _returnCode = ((Arts::InterfaceRepo_skel *)object)->queryInterface(name);
	_returnCode.writeType(*result);
}

// queryType
static void _dispatch_Arts_InterfaceRepo_03(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string name;
	request->readString(name);
	Arts::TypeDef _returnCode = ((Arts::InterfaceRepo_skel *)object)->queryType(name);
	_returnCode.writeType(*result);
}

// queryEnum
static void _dispatch_Arts_InterfaceRepo_04(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string name;
	request->readString(name);
	Arts::EnumDef _returnCode = ((Arts::InterfaceRepo_skel *)object)->queryEnum(name);
	_returnCode.writeType(*result);
}

// queryChildren
static void _dispatch_Arts_InterfaceRepo_05(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string name;
	request->readString(name);
	std::vector<std::string> *_returnCode = ((Arts::InterfaceRepo_skel *)object)->queryChildren(name);
	result->writeStringSeq(*_returnCode);
	delete _returnCode;
}

// queryInterfaces
static void _dispatch_Arts_InterfaceRepo_06(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<std::string> *_returnCode = ((Arts::InterfaceRepo_skel *)object)->queryInterfaces();
	result->writeStringSeq(*_returnCode);
	delete _returnCode;
}

// queryTypes
static void _dispatch_Arts_InterfaceRepo_07(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<std::string> *_returnCode = ((Arts::InterfaceRepo_skel *)object)->queryTypes();
	result->writeStringSeq(*_returnCode);
	delete _returnCode;
}

// queryEnums
static void _dispatch_Arts_InterfaceRepo_08(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<std::string> *_returnCode = ((Arts::InterfaceRepo_skel *)object)->queryEnums();
	result->writeStringSeq(*_returnCode);
	delete _returnCode;
}

void Arts::InterfaceRepo_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000d696e736572744d6f64756c6500000000056c6f6e670000"
        "0000020000000100000010417274733a3a4d6f64756c65446566000000000a6e65"
        "774d6f64756c650000000000000000000000000d72656d6f76654d6f64756c6500"
        "00000005766f6964000000000200000001000000056c6f6e6700000000096d6f64"
        "756c6549440000000000000000000000000f7175657279496e7465726661636500"
        "00000013417274733a3a496e746572666163654465660000000002000000010000"
        "0007737472696e6700000000056e616d650000000000000000000000000a717565"
        "727954797065000000000e417274733a3a54797065446566000000000200000001"
        "00000007737472696e6700000000056e616d650000000000000000000000000a71"
        "75657279456e756d000000000e417274733a3a456e756d44656600000000020000"
        "000100000007737472696e6700000000056e616d65000000000000000000000000"
        "0e71756572794368696c6472656e00000000082a737472696e6700000000020000"
        "000100000007737472696e6700000000056e616d65000000000000000000000000"
        "107175657279496e746572666163657300000000082a737472696e670000000002"
        "00000000000000000000000b7175657279547970657300000000082a737472696e"
        "67000000000200000000000000000000000b7175657279456e756d730000000008"
        "2a737472696e6700000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_InterfaceRepo_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_05,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_06,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_07,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_InterfaceRepo_08,this,Arts::MethodDef(m));
}

Arts::InterfaceRepo_skel::InterfaceRepo_skel()
{
}

Arts::Object_base* Arts::InterfaceRepo::_Creator() {
	return Arts::InterfaceRepo_base::_create();
}

unsigned long Arts::InterfaceRepo_base::_IID = MCOPUtils::makeIID("Arts::InterfaceRepo");

Arts::InterfaceRepoV2_base *Arts::InterfaceRepoV2_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::InterfaceRepoV2_base *castedObject = (Arts::InterfaceRepoV2_base *)skel->_cast(Arts::InterfaceRepoV2_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::InterfaceRepoV2_base *Arts::InterfaceRepoV2_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::InterfaceRepoV2_base::_fromReference(r,true);
	return 0;
}

Arts::InterfaceRepoV2_base *Arts::InterfaceRepoV2_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::InterfaceRepoV2_base *castedObject = (Arts::InterfaceRepoV2_base *)object._base()->_cast(Arts::InterfaceRepoV2_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::InterfaceRepoV2_base *Arts::InterfaceRepoV2_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::InterfaceRepoV2_base *result;
	result = (Arts::InterfaceRepoV2_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::InterfaceRepoV2");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::InterfaceRepoV2_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::InterfaceRepoV2")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::InterfaceRepoV2_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::InterfaceRepoV2_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::InterfaceRepoV2_base::_cast(unsigned long iid)
{
	if(iid == Arts::InterfaceRepoV2_base::_IID) return (Arts::InterfaceRepoV2_base *)this;
	if(iid == Arts::InterfaceRepo_base::_IID) return (Arts::InterfaceRepo_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::InterfaceRepoV2_stub::InterfaceRepoV2_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::InterfaceRepoV2_stub::InterfaceRepoV2_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

Arts::TypeIdentification Arts::InterfaceRepoV2_stub::identifyType(const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000d6964656e74696679547970650000000019417274733a3a547970654964656e74696669636174696f6e00000000020000000100000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return (Arts::TypeIdentification)0; // error occured
	Arts::TypeIdentification returnCode = (Arts::TypeIdentification)result->readLong();
	delete result;
	return returnCode;
}

std::string Arts::InterfaceRepoV2_skel::_interfaceName()
{
	return "Arts::InterfaceRepoV2";
}

bool Arts::InterfaceRepoV2_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::InterfaceRepoV2") return true;
	if (interfacename == "Arts::InterfaceRepo") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::InterfaceRepoV2_skel::_interfaceNameSkel()
{
	return "Arts::InterfaceRepoV2";
}

// identifyType
static void _dispatch_Arts_InterfaceRepoV2_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string name;
	request->readString(name);
	result->writeLong(((Arts::InterfaceRepoV2_skel *)object)->identifyType(name));
}

void Arts::InterfaceRepoV2_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000d6964656e74696679547970650000000019417274733a3a"
        "547970654964656e74696669636174696f6e000000000200000001000000077374"
        "72696e6700000000056e616d65000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_InterfaceRepoV2_00,this,Arts::MethodDef(m));
	Arts::InterfaceRepo_skel::_buildMethodTable();
}

Arts::InterfaceRepoV2_skel::InterfaceRepoV2_skel()
{
}

Arts::Object_base* Arts::InterfaceRepoV2::_Creator() {
	return Arts::InterfaceRepoV2_base::_create();
}

unsigned long Arts::InterfaceRepoV2_base::_IID = Arts::MCOPUtils::makeIID("Arts::InterfaceRepoV2");

Arts::FlowSystemSender_base *Arts::FlowSystemSender_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::FlowSystemSender_base *castedObject = (Arts::FlowSystemSender_base *)skel->_cast(Arts::FlowSystemSender_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::FlowSystemSender_base *Arts::FlowSystemSender_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::FlowSystemSender_base::_fromReference(r,true);
	return 0;
}

Arts::FlowSystemSender_base *Arts::FlowSystemSender_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::FlowSystemSender_base *castedObject = (Arts::FlowSystemSender_base *)object._base()->_cast(Arts::FlowSystemSender_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::FlowSystemSender_base *Arts::FlowSystemSender_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::FlowSystemSender_base *result;
	result = (Arts::FlowSystemSender_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::FlowSystemSender");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::FlowSystemSender_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::FlowSystemSender")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::FlowSystemSender_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::FlowSystemSender_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::FlowSystemSender_base::_cast(unsigned long iid)
{
	if(iid == Arts::FlowSystemSender_base::_IID) return (Arts::FlowSystemSender_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::FlowSystemSender_stub::FlowSystemSender_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::FlowSystemSender_stub::FlowSystemSender_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::FlowSystemSender_stub::processed()
{
	long methodID = _lookupMethodFast("method:0000000a70726f6365737365640000000005766f696400000000010000000000000000");
	Arts::Buffer *request = Arts::Dispatcher::the()->createOnewayRequest(_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

}

void Arts::FlowSystemSender_stub::disconnect()
{
	long methodID = _lookupMethodFast("method:0000000b646973636f6e6e6563740000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::FlowSystemSender_skel::_interfaceName()
{
	return "Arts::FlowSystemSender";
}

bool Arts::FlowSystemSender_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::FlowSystemSender") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::FlowSystemSender_skel::_interfaceNameSkel()
{
	return "Arts::FlowSystemSender";
}

// processed
static void _dispatch_Arts_FlowSystemSender_00(void *object, Arts::Buffer *)
{
	((Arts::FlowSystemSender_skel *)object)->processed();
}

// disconnect
static void _dispatch_Arts_FlowSystemSender_01(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::FlowSystemSender_skel *)object)->disconnect();
}

void Arts::FlowSystemSender_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000a70726f6365737365640000000005766f69640000000001"
        "00000000000000000000000b646973636f6e6e6563740000000005766f69640000"
        "0000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_FlowSystemSender_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystemSender_01,this,Arts::MethodDef(m));
}

Arts::FlowSystemSender_skel::FlowSystemSender_skel()
{
}

Arts::Object_base* Arts::FlowSystemSender::_Creator() {
	return Arts::FlowSystemSender_base::_create();
}

unsigned long Arts::FlowSystemSender_base::_IID = Arts::MCOPUtils::makeIID("Arts::FlowSystemSender");

Arts::FlowSystemReceiver_base *Arts::FlowSystemReceiver_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::FlowSystemReceiver_base *castedObject = (Arts::FlowSystemReceiver_base *)skel->_cast(Arts::FlowSystemReceiver_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::FlowSystemReceiver_base *Arts::FlowSystemReceiver_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::FlowSystemReceiver_base::_fromReference(r,true);
	return 0;
}

Arts::FlowSystemReceiver_base *Arts::FlowSystemReceiver_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::FlowSystemReceiver_base *castedObject = (Arts::FlowSystemReceiver_base *)object._base()->_cast(Arts::FlowSystemReceiver_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::FlowSystemReceiver_base *Arts::FlowSystemReceiver_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::FlowSystemReceiver_base *result;
	result = (Arts::FlowSystemReceiver_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::FlowSystemReceiver");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::FlowSystemReceiver_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::FlowSystemReceiver")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::FlowSystemReceiver_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::FlowSystemReceiver_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::FlowSystemReceiver_base::_cast(unsigned long iid)
{
	if(iid == Arts::FlowSystemReceiver_base::_IID) return (Arts::FlowSystemReceiver_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::FlowSystemReceiver_stub::FlowSystemReceiver_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::FlowSystemReceiver_stub::FlowSystemReceiver_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::FlowSystemReceiver_stub::disconnect()
{
	long methodID = _lookupMethodFast("method:0000000b646973636f6e6e6563740000000005766f696400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

long Arts::FlowSystemReceiver_stub::receiveHandlerID()
{
	long methodID = _lookupMethodFast("method:000000165f6765745f7265636569766548616e646c6572494400000000056c6f6e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0; // error occured
	long returnCode = result->readLong();
	delete result;
	return returnCode;
}

std::string Arts::FlowSystemReceiver_skel::_interfaceName()
{
	return "Arts::FlowSystemReceiver";
}

bool Arts::FlowSystemReceiver_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::FlowSystemReceiver") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::FlowSystemReceiver_skel::_interfaceNameSkel()
{
	return "Arts::FlowSystemReceiver";
}

// disconnect
static void _dispatch_Arts_FlowSystemReceiver_00(void *object, Arts::Buffer *, Arts::Buffer *)
{
	((Arts::FlowSystemReceiver_skel *)object)->disconnect();
}

// _get_receiveHandlerID
static void _dispatch_Arts_FlowSystemReceiver_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeLong(((Arts::FlowSystemReceiver_skel *)object)->receiveHandlerID());
}

void Arts::FlowSystemReceiver_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000b646973636f6e6e6563740000000005766f696400000000"
        "020000000000000000000000165f6765745f7265636569766548616e646c657249"
        "4400000000056c6f6e6700000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_FlowSystemReceiver_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystemReceiver_01,this,Arts::MethodDef(m));
}

Arts::FlowSystemReceiver_skel::FlowSystemReceiver_skel()
{
}

Arts::Object_base* Arts::FlowSystemReceiver::_Creator() {
	return Arts::FlowSystemReceiver_base::_create();
}

unsigned long Arts::FlowSystemReceiver_base::_IID = Arts::MCOPUtils::makeIID("Arts::FlowSystemReceiver");

Arts::FlowSystem_base *Arts::FlowSystem_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::FlowSystem_base *castedObject = (Arts::FlowSystem_base *)skel->_cast(Arts::FlowSystem_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::FlowSystem_base *Arts::FlowSystem_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::FlowSystem_base::_fromReference(r,true);
	return 0;
}

Arts::FlowSystem_base *Arts::FlowSystem_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::FlowSystem_base *castedObject = (Arts::FlowSystem_base *)object._base()->_cast(Arts::FlowSystem_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::FlowSystem_base *Arts::FlowSystem_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::FlowSystem_base *result;
	result = (Arts::FlowSystem_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::FlowSystem");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::FlowSystem_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::FlowSystem")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::FlowSystem_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::FlowSystem_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::FlowSystem_base::_cast(unsigned long iid)
{
	if(iid == Arts::FlowSystem_base::_IID) return (Arts::FlowSystem_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::FlowSystem_stub::FlowSystem_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::FlowSystem_stub::FlowSystem_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::FlowSystem_stub::startObject(Arts::Object node)
{
	long methodID = _lookupMethodFast("method:0000000c73746172744f626a6563740000000005766f6964000000000200000001000000076f626a65637400000000056e6f6465000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,node._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::FlowSystem_stub::stopObject(Arts::Object node)
{
	long methodID = _lookupMethodFast("method:0000000b73746f704f626a6563740000000005766f6964000000000200000001000000076f626a65637400000000056e6f6465000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,node._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::FlowSystem_stub::connectObject(Arts::Object sourceObject, const std::string& sourcePort, Arts::Object destObject, const std::string& destPort)
{
	long methodID = _lookupMethodFast("method:0000000e636f6e6e6563744f626a6563740000000005766f6964000000000200000004000000076f626a656374000000000d736f757263654f626a656374000000000000000007737472696e67000000000b736f75726365506f72740000000000000000076f626a656374000000000b646573744f626a656374000000000000000007737472696e67000000000964657374506f7274000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,sourceObject._base());
	request->writeString(sourcePort);
	Arts::writeObject(*request,destObject._base());
	request->writeString(destPort);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

void Arts::FlowSystem_stub::disconnectObject(Arts::Object sourceObject, const std::string& sourcePort, Arts::Object destObject, const std::string& destPort)
{
	long methodID = _lookupMethodFast("method:00000011646973636f6e6e6563744f626a6563740000000005766f6964000000000200000004000000076f626a656374000000000d736f757263654f626a656374000000000000000007737472696e67000000000b736f75726365506f72740000000000000000076f626a656374000000000b646573744f626a656374000000000000000007737472696e67000000000964657374506f7274000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,sourceObject._base());
	request->writeString(sourcePort);
	Arts::writeObject(*request,destObject._base());
	request->writeString(destPort);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

Arts::AttributeType Arts::FlowSystem_stub::queryFlags(Arts::Object node, const std::string& port)
{
	long methodID = _lookupMethodFast("method:0000000b7175657279466c6167730000000014417274733a3a41747472696275746554797065000000000200000002000000076f626a65637400000000056e6f6465000000000000000007737472696e670000000005706f7274000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,node._base());
	request->writeString(port);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return (Arts::AttributeType)0; // error occured
	Arts::AttributeType returnCode = (Arts::AttributeType)result->readLong();
	delete result;
	return returnCode;
}

void Arts::FlowSystem_stub::setFloatValue(Arts::Object node, const std::string& port, float value)
{
	long methodID = _lookupMethodFast("method:0000000e736574466c6f617456616c75650000000005766f6964000000000200000003000000076f626a65637400000000056e6f6465000000000000000007737472696e670000000005706f7274000000000000000006666c6f6174000000000676616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,node._base());
	request->writeString(port);
	request->writeFloat(value);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

Arts::FlowSystemReceiver Arts::FlowSystem_stub::createReceiver(Arts::Object destObject, const std::string& destPort, Arts::FlowSystemSender sender)
{
	long methodID = _lookupMethodFast("method:0000000f63726561746552656365697665720000000019417274733a3a466c6f7753797374656d5265636569766572000000000200000003000000076f626a656374000000000b646573744f626a656374000000000000000007737472696e67000000000964657374506f7274000000000000000017417274733a3a466c6f7753797374656d53656e646572000000000773656e646572000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,destObject._base());
	request->writeString(destPort);
	Arts::writeObject(*request,sender._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if (!result) return Arts::FlowSystemReceiver::null();
	Arts::FlowSystemReceiver_base* returnCode;
	Arts::readObject(*result,returnCode);
	delete result;
	return Arts::FlowSystemReceiver::_from_base(returnCode);
}

std::string Arts::FlowSystem_skel::_interfaceName()
{
	return "Arts::FlowSystem";
}

bool Arts::FlowSystem_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::FlowSystem") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::FlowSystem_skel::_interfaceNameSkel()
{
	return "Arts::FlowSystem";
}

// startObject
static void _dispatch_Arts_FlowSystem_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::Object_base* _temp_node;
	Arts::readObject(*request,_temp_node);
	Arts::Object node = Arts::Object::_from_base(_temp_node);
	((Arts::FlowSystem_skel *)object)->startObject(node);
}

// stopObject
static void _dispatch_Arts_FlowSystem_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::Object_base* _temp_node;
	Arts::readObject(*request,_temp_node);
	Arts::Object node = Arts::Object::_from_base(_temp_node);
	((Arts::FlowSystem_skel *)object)->stopObject(node);
}

// connectObject
static void _dispatch_Arts_FlowSystem_02(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::Object_base* _temp_sourceObject;
	Arts::readObject(*request,_temp_sourceObject);
	Arts::Object sourceObject = Arts::Object::_from_base(_temp_sourceObject);
	std::string sourcePort;
	request->readString(sourcePort);
	Arts::Object_base* _temp_destObject;
	Arts::readObject(*request,_temp_destObject);
	Arts::Object destObject = Arts::Object::_from_base(_temp_destObject);
	std::string destPort;
	request->readString(destPort);
	((Arts::FlowSystem_skel *)object)->connectObject(sourceObject,sourcePort,destObject,destPort);
}

// disconnectObject
static void _dispatch_Arts_FlowSystem_03(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::Object_base* _temp_sourceObject;
	Arts::readObject(*request,_temp_sourceObject);
	Arts::Object sourceObject = Arts::Object::_from_base(_temp_sourceObject);
	std::string sourcePort;
	request->readString(sourcePort);
	Arts::Object_base* _temp_destObject;
	Arts::readObject(*request,_temp_destObject);
	Arts::Object destObject = Arts::Object::_from_base(_temp_destObject);
	std::string destPort;
	request->readString(destPort);
	((Arts::FlowSystem_skel *)object)->disconnectObject(sourceObject,sourcePort,destObject,destPort);
}

// queryFlags
static void _dispatch_Arts_FlowSystem_04(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	Arts::Object_base* _temp_node;
	Arts::readObject(*request,_temp_node);
	Arts::Object node = Arts::Object::_from_base(_temp_node);
	std::string port;
	request->readString(port);
	result->writeLong(((Arts::FlowSystem_skel *)object)->queryFlags(node,port));
}

// setFloatValue
static void _dispatch_Arts_FlowSystem_05(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	Arts::Object_base* _temp_node;
	Arts::readObject(*request,_temp_node);
	Arts::Object node = Arts::Object::_from_base(_temp_node);
	std::string port;
	request->readString(port);
	float value = request->readFloat();
	((Arts::FlowSystem_skel *)object)->setFloatValue(node,port,value);
}

// createReceiver
static void _dispatch_Arts_FlowSystem_06(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	Arts::Object_base* _temp_destObject;
	Arts::readObject(*request,_temp_destObject);
	Arts::Object destObject = Arts::Object::_from_base(_temp_destObject);
	std::string destPort;
	request->readString(destPort);
	Arts::FlowSystemSender_base* _temp_sender;
	Arts::readObject(*request,_temp_sender);
	Arts::FlowSystemSender sender = Arts::FlowSystemSender::_from_base(_temp_sender);
	Arts::FlowSystemReceiver returnCode = ((Arts::FlowSystem_skel *)object)->createReceiver(destObject,destPort,sender);
	Arts::writeObject(*result,returnCode._base());
}

void Arts::FlowSystem_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000c73746172744f626a6563740000000005766f6964000000"
        "000200000001000000076f626a65637400000000056e6f64650000000000000000"
        "000000000b73746f704f626a6563740000000005766f6964000000000200000001"
        "000000076f626a65637400000000056e6f64650000000000000000000000000e63"
        "6f6e6e6563744f626a6563740000000005766f6964000000000200000004000000"
        "076f626a656374000000000d736f757263654f626a656374000000000000000007"
        "737472696e67000000000b736f75726365506f72740000000000000000076f626a"
        "656374000000000b646573744f626a656374000000000000000007737472696e67"
        "000000000964657374506f727400000000000000000000000011646973636f6e6e"
        "6563744f626a6563740000000005766f6964000000000200000004000000076f62"
        "6a656374000000000d736f757263654f626a656374000000000000000007737472"
        "696e67000000000b736f75726365506f72740000000000000000076f626a656374"
        "000000000b646573744f626a656374000000000000000007737472696e67000000"
        "000964657374506f72740000000000000000000000000b7175657279466c616773"
        "0000000014417274733a3a41747472696275746554797065000000000200000002"
        "000000076f626a65637400000000056e6f6465000000000000000007737472696e"
        "670000000005706f72740000000000000000000000000e736574466c6f61745661"
        "6c75650000000005766f6964000000000200000003000000076f626a6563740000"
        "0000056e6f6465000000000000000007737472696e670000000005706f72740000"
        "00000000000006666c6f6174000000000676616c75650000000000000000000000"
        "000f63726561746552656365697665720000000019417274733a3a466c6f775379"
        "7374656d5265636569766572000000000200000003000000076f626a6563740000"
        "00000b646573744f626a656374000000000000000007737472696e670000000009"
        "64657374506f7274000000000000000017417274733a3a466c6f7753797374656d"
        "53656e646572000000000773656e646572000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_FlowSystem_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystem_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystem_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystem_03,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystem_04,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystem_05,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_FlowSystem_06,this,Arts::MethodDef(m));
}

Arts::FlowSystem_skel::FlowSystem_skel()
{
}

Arts::Object_base* Arts::FlowSystem::_Creator() {
	return Arts::FlowSystem_base::_create();
}

unsigned long Arts::FlowSystem_base::_IID = Arts::MCOPUtils::makeIID("Arts::FlowSystem");

Arts::GlobalComm_base *Arts::GlobalComm_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::GlobalComm_base *castedObject = (Arts::GlobalComm_base *)skel->_cast(Arts::GlobalComm_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::GlobalComm_base *Arts::GlobalComm_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::GlobalComm_base::_fromReference(r,true);
	return 0;
}

Arts::GlobalComm_base *Arts::GlobalComm_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::GlobalComm_base *castedObject = (Arts::GlobalComm_base *)object._base()->_cast(Arts::GlobalComm_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::GlobalComm_base *Arts::GlobalComm_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::GlobalComm_base *result;
	result = (Arts::GlobalComm_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::GlobalComm");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::GlobalComm_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::GlobalComm")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::GlobalComm_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::GlobalComm_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::GlobalComm_base::_cast(unsigned long iid)
{
	if(iid == Arts::GlobalComm_base::_IID) return (Arts::GlobalComm_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::GlobalComm_stub::GlobalComm_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::GlobalComm_stub::GlobalComm_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

bool Arts::GlobalComm_stub::put(const std::string& variable, const std::string& value)
{
	long methodID = _lookupMethodFast("method:000000047075740000000008626f6f6c65616e00000000020000000200000007737472696e6700000000097661726961626c65000000000000000007737472696e67000000000676616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(variable);
	request->writeString(value);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return false; // error occured
	bool returnCode = result->readBool();
	delete result;
	return returnCode;
}

std::string Arts::GlobalComm_stub::get(const std::string& variable)
{
	long methodID = _lookupMethodFast("method:000000046765740000000007737472696e6700000000020000000100000007737472696e6700000000097661726961626c65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(variable);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occured
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

void Arts::GlobalComm_stub::erase(const std::string& variable)
{
	long methodID = _lookupMethodFast("method:0000000665726173650000000005766f696400000000020000000100000007737472696e6700000000097661726961626c65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(variable);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string Arts::GlobalComm_skel::_interfaceName()
{
	return "Arts::GlobalComm";
}

bool Arts::GlobalComm_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::GlobalComm") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::GlobalComm_skel::_interfaceNameSkel()
{
	return "Arts::GlobalComm";
}

// put
static void _dispatch_Arts_GlobalComm_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string variable;
	request->readString(variable);
	std::string value;
	request->readString(value);
	result->writeBool(((Arts::GlobalComm_skel *)object)->put(variable,value));
}

// get
static void _dispatch_Arts_GlobalComm_01(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string variable;
	request->readString(variable);
	result->writeString(((Arts::GlobalComm_skel *)object)->get(variable));
}

// erase
static void _dispatch_Arts_GlobalComm_02(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string variable;
	request->readString(variable);
	((Arts::GlobalComm_skel *)object)->erase(variable);
}

void Arts::GlobalComm_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:000000047075740000000008626f6f6c65616e0000000002000000"
        "0200000007737472696e6700000000097661726961626c65000000000000000007"
        "737472696e67000000000676616c75650000000000000000000000000467657400"
        "00000007737472696e6700000000020000000100000007737472696e6700000000"
        "097661726961626c65000000000000000000000000066572617365000000000576"
        "6f696400000000020000000100000007737472696e670000000009766172696162"
        "6c65000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_GlobalComm_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_GlobalComm_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_GlobalComm_02,this,Arts::MethodDef(m));
}

Arts::GlobalComm_skel::GlobalComm_skel()
{
}

Arts::Object_base* Arts::GlobalComm::_Creator() {
	return Arts::GlobalComm_base::_create();
}

unsigned long Arts::GlobalComm_base::_IID = Arts::MCOPUtils::makeIID("Arts::GlobalComm");

Arts::TmpGlobalComm_base *Arts::TmpGlobalComm_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::TmpGlobalComm_base *castedObject = (Arts::TmpGlobalComm_base *)skel->_cast(Arts::TmpGlobalComm_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::TmpGlobalComm_base *Arts::TmpGlobalComm_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::TmpGlobalComm_base::_fromReference(r,true);
	return 0;
}

Arts::TmpGlobalComm_base *Arts::TmpGlobalComm_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::TmpGlobalComm_base *castedObject = (Arts::TmpGlobalComm_base *)object._base()->_cast(Arts::TmpGlobalComm_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::TmpGlobalComm_base *Arts::TmpGlobalComm_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::TmpGlobalComm_base *result;
	result = (Arts::TmpGlobalComm_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::TmpGlobalComm");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::TmpGlobalComm_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::TmpGlobalComm")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::TmpGlobalComm_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::TmpGlobalComm_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::TmpGlobalComm_base::_cast(unsigned long iid)
{
	if(iid == Arts::TmpGlobalComm_base::_IID) return (Arts::TmpGlobalComm_base *)this;
	if(iid == Arts::GlobalComm_base::_IID) return (Arts::GlobalComm_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::TmpGlobalComm_stub::TmpGlobalComm_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::TmpGlobalComm_stub::TmpGlobalComm_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string Arts::TmpGlobalComm_skel::_interfaceName()
{
	return "Arts::TmpGlobalComm";
}

bool Arts::TmpGlobalComm_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::TmpGlobalComm") return true;
	if (interfacename == "Arts::GlobalComm") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::TmpGlobalComm_skel::_interfaceNameSkel()
{
	return "Arts::TmpGlobalComm";
}

void Arts::TmpGlobalComm_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::GlobalComm_skel::_buildMethodTable();
}

Arts::TmpGlobalComm_skel::TmpGlobalComm_skel()
{
}

Arts::Object_base* Arts::TmpGlobalComm::_Creator() {
	return Arts::TmpGlobalComm_base::_create();
}

unsigned long Arts::TmpGlobalComm_base::_IID = Arts::MCOPUtils::makeIID("Arts::TmpGlobalComm");

Arts::TraderOffer_base *Arts::TraderOffer_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::TraderOffer_base *castedObject = (Arts::TraderOffer_base *)skel->_cast(Arts::TraderOffer_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::TraderOffer_base *Arts::TraderOffer_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::TraderOffer_base::_fromReference(r,true);
	return 0;
}

Arts::TraderOffer_base *Arts::TraderOffer_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::TraderOffer_base *castedObject = (Arts::TraderOffer_base *)object._base()->_cast(Arts::TraderOffer_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::TraderOffer_base *Arts::TraderOffer_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::TraderOffer_base *result;
	result = (Arts::TraderOffer_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::TraderOffer");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::TraderOffer_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::TraderOffer")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::TraderOffer_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::TraderOffer_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::TraderOffer_base::_cast(unsigned long iid)
{
	if(iid == Arts::TraderOffer_base::_IID) return (Arts::TraderOffer_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::TraderOffer_stub::TraderOffer_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::TraderOffer_stub::TraderOffer_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::vector<std::string> * Arts::TraderOffer_stub::getProperty(const std::string& name)
{
	long methodID = _lookupMethodFast("method:0000000c67657450726f706572747900000000082a737472696e6700000000020000000100000007737472696e6700000000056e616d65000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(name);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<std::string> *_returnCode = new std::vector<std::string>;
	if(!result) return _returnCode; // error occured
	result->readStringSeq(*_returnCode);
	delete result;
	return _returnCode;
}

std::string Arts::TraderOffer_stub::interfaceName()
{
	long methodID = _lookupMethodFast("method:000000135f6765745f696e746572666163654e616d650000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occured
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

std::string Arts::TraderOffer_skel::_interfaceName()
{
	return "Arts::TraderOffer";
}

bool Arts::TraderOffer_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::TraderOffer") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::TraderOffer_skel::_interfaceNameSkel()
{
	return "Arts::TraderOffer";
}

// getProperty
static void _dispatch_Arts_TraderOffer_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	std::string name;
	request->readString(name);
	std::vector<std::string> *_returnCode = ((Arts::TraderOffer_skel *)object)->getProperty(name);
	result->writeStringSeq(*_returnCode);
	delete _returnCode;
}

// _get_interfaceName
static void _dispatch_Arts_TraderOffer_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::TraderOffer_skel *)object)->interfaceName());
}

void Arts::TraderOffer_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000c67657450726f706572747900000000082a737472696e67"
        "00000000020000000100000007737472696e6700000000056e616d650000000000"
        "00000000000000135f6765745f696e746572666163654e616d6500000000077374"
        "72696e6700000000020000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_TraderOffer_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_TraderOffer_01,this,Arts::MethodDef(m));
}

Arts::TraderOffer_skel::TraderOffer_skel()
{
}

Arts::Object_base* Arts::TraderOffer::_Creator() {
	return Arts::TraderOffer_base::_create();
}

unsigned long Arts::TraderOffer_base::_IID = Arts::MCOPUtils::makeIID("Arts::TraderOffer");

Arts::TraderQuery_base *Arts::TraderQuery_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::TraderQuery_base *castedObject = (Arts::TraderQuery_base *)skel->_cast(Arts::TraderQuery_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::TraderQuery_base *Arts::TraderQuery_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::TraderQuery_base::_fromReference(r,true);
	return 0;
}

Arts::TraderQuery_base *Arts::TraderQuery_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::TraderQuery_base *castedObject = (Arts::TraderQuery_base *)object._base()->_cast(Arts::TraderQuery_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::TraderQuery_base *Arts::TraderQuery_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::TraderQuery_base *result;
	result = (Arts::TraderQuery_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::TraderQuery");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::TraderQuery_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::TraderQuery")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::TraderQuery_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::TraderQuery_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::TraderQuery_base::_cast(unsigned long iid)
{
	if(iid == Arts::TraderQuery_base::_IID) return (Arts::TraderQuery_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::TraderQuery_stub::TraderQuery_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::TraderQuery_stub::TraderQuery_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

void Arts::TraderQuery_stub::supports(const std::string& property, const std::string& value)
{
	long methodID = _lookupMethodFast("method:00000009737570706f7274730000000005766f696400000000020000000200000007737472696e67000000000970726f7065727479000000000000000007737472696e67000000000676616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeString(property);
	request->writeString(value);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::vector<Arts::TraderOffer> * Arts::TraderQuery_stub::query()
{
	long methodID = _lookupMethodFast("method:00000006717565727900000000132a417274733a3a5472616465724f6666657200000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<Arts::TraderOffer> *_returnCode = new std::vector<Arts::TraderOffer>;
	if(!result) return _returnCode; // error occured
	Arts::readObjectSeq(*result,*_returnCode);
	delete result;
	return _returnCode;
}

std::string Arts::TraderQuery_skel::_interfaceName()
{
	return "Arts::TraderQuery";
}

bool Arts::TraderQuery_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::TraderQuery") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::TraderQuery_skel::_interfaceNameSkel()
{
	return "Arts::TraderQuery";
}

// supports
static void _dispatch_Arts_TraderQuery_00(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	std::string property;
	request->readString(property);
	std::string value;
	request->readString(value);
	((Arts::TraderQuery_skel *)object)->supports(property,value);
}

// query
static void _dispatch_Arts_TraderQuery_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<Arts::TraderOffer> *_returnCode = ((Arts::TraderQuery_skel *)object)->query();
	Arts::writeObjectSeq(*result,*_returnCode);
	delete _returnCode;
}

void Arts::TraderQuery_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:00000009737570706f7274730000000005766f6964000000000200"
        "00000200000007737472696e67000000000970726f706572747900000000000000"
        "0007737472696e67000000000676616c7565000000000000000000000000067175"
        "65727900000000132a417274733a3a5472616465724f6666657200000000020000"
        "000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_TraderQuery_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_TraderQuery_01,this,Arts::MethodDef(m));
}

Arts::TraderQuery_skel::TraderQuery_skel()
{
}

Arts::Object_base* Arts::TraderQuery::_Creator() {
	return Arts::TraderQuery_base::_create();
}

unsigned long Arts::TraderQuery_base::_IID = Arts::MCOPUtils::makeIID("Arts::TraderQuery");

Arts::Loader_base *Arts::Loader_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	Arts::Loader_base *castedObject = (Arts::Loader_base *)skel->_cast(Arts::Loader_base::_IID);
	assert(castedObject);
	return castedObject;
}

Arts::Loader_base *Arts::Loader_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return Arts::Loader_base::_fromReference(r,true);
	return 0;
}

Arts::Loader_base *Arts::Loader_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	Arts::Loader_base *castedObject = (Arts::Loader_base *)object._base()->_cast(Arts::Loader_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

Arts::Loader_base *Arts::Loader_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	Arts::Loader_base *result;
	result = (Arts::Loader_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"Arts::Loader");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new Arts::Loader_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("Arts::Loader")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> Arts::Loader_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> Arts::Loader_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *Arts::Loader_base::_cast(unsigned long iid)
{
	if(iid == Arts::Loader_base::_IID) return (Arts::Loader_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

Arts::Loader_stub::Loader_stub()
{
	// constructor for subclasses (don't use directly)
}

Arts::Loader_stub::Loader_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

Arts::Object Arts::Loader_stub::loadObject(Arts::TraderOffer offer)
{
	long methodID = _lookupMethodFast("method:0000000b6c6f61644f626a65637400000000076f626a65637400000000020000000100000012417274733a3a5472616465724f6666657200000000066f66666572000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	Arts::writeObject(*request,offer._base());
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if (!result) return Arts::Object::null();
	Arts::Object_base* returnCode;
	Arts::readObject(*result,returnCode);
	delete result;
	return Arts::Object::_from_base(returnCode);
}

std::string Arts::Loader_stub::dataVersion()
{
	long methodID = _lookupMethodFast("method:000000115f6765745f6461746156657273696f6e0000000007737472696e6700000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return""; // error occured
	std::string returnCode;
	result->readString(returnCode);
	delete result;
	return returnCode;
}

std::vector<Arts::TraderEntry> * Arts::Loader_stub::traderEntries()
{
	long methodID = _lookupMethodFast("method:000000135f6765745f747261646572456e747269657300000000132a417274733a3a547261646572456e74727900000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<Arts::TraderEntry> *_returnCode = new std::vector<Arts::TraderEntry>;
	if(!result) return _returnCode; // error occured
	readTypeSeq(*result,*_returnCode);
	delete result;
	return _returnCode;
}

std::vector<Arts::ModuleDef> * Arts::Loader_stub::modules()
{
	long methodID = _lookupMethodFast("method:0000000d5f6765745f6d6f64756c657300000000112a417274733a3a4d6f64756c6544656600000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	std::vector<Arts::ModuleDef> *_returnCode = new std::vector<Arts::ModuleDef>;
	if(!result) return _returnCode; // error occured
	readTypeSeq(*result,*_returnCode);
	delete result;
	return _returnCode;
}

std::string Arts::Loader_skel::_interfaceName()
{
	return "Arts::Loader";
}

bool Arts::Loader_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "Arts::Loader") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string Arts::Loader_skel::_interfaceNameSkel()
{
	return "Arts::Loader";
}

// loadObject
static void _dispatch_Arts_Loader_00(void *object, Arts::Buffer *request, Arts::Buffer *result)
{
	Arts::TraderOffer_base* _temp_offer;
	Arts::readObject(*request,_temp_offer);
	Arts::TraderOffer offer = Arts::TraderOffer::_from_base(_temp_offer);
	Arts::Object returnCode = ((Arts::Loader_skel *)object)->loadObject(offer);
	Arts::writeObject(*result,returnCode._base());
}

// _get_dataVersion
static void _dispatch_Arts_Loader_01(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeString(((Arts::Loader_skel *)object)->dataVersion());
}

// _get_traderEntries
static void _dispatch_Arts_Loader_02(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<Arts::TraderEntry> *_returnCode = ((Arts::Loader_skel *)object)->traderEntries();
	Arts::writeTypeSeq(*result,*_returnCode);
	delete _returnCode;
}

// _get_modules
static void _dispatch_Arts_Loader_03(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	std::vector<Arts::ModuleDef> *_returnCode = ((Arts::Loader_skel *)object)->modules();
	Arts::writeTypeSeq(*result,*_returnCode);
	delete _returnCode;
}

void Arts::Loader_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000b6c6f61644f626a65637400000000076f626a6563740000"
        "0000020000000100000012417274733a3a5472616465724f666665720000000006"
        "6f66666572000000000000000000000000115f6765745f6461746156657273696f"
        "6e0000000007737472696e6700000000020000000000000000000000135f676574"
        "5f747261646572456e747269657300000000132a417274733a3a54726164657245"
        "6e747279000000000200000000000000000000000d5f6765745f6d6f64756c6573"
        "00000000112a417274733a3a4d6f64756c65446566000000000200000000000000"
        "00",
		"MethodTable"
	);
	_addMethod(_dispatch_Arts_Loader_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Loader_01,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Loader_02,this,Arts::MethodDef(m));
	_addMethod(_dispatch_Arts_Loader_03,this,Arts::MethodDef(m));
}

Arts::Loader_skel::Loader_skel()
{
}

Arts::Object_base* Arts::Loader::_Creator() {
	return Arts::Loader_base::_create();
}

unsigned long Arts::Loader_base::_IID = Arts::MCOPUtils::makeIID("Arts::Loader");

static Arts::IDLFileReg IDLFileReg_core("core",
    "IDLFile:00000001000000000500000012417274733a3a4865616465724d6167696300"
    "000000010000000b4d434f505f4d41474943004d434f50000000000000000000000012"
    "417274733a3a4d657373616765547970650000000007000000136d636f704d65737361"
    "6765496e76616c6964000000000000000000000000106d636f7053657276657248656c"
    "6c6f000000000100000000000000106d636f70436c69656e7448656c6c6f0000000002"
    "000000000000000f6d636f70417574684163636570740000000003000000000000000f"
    "6d636f70496e766f636174696f6e0000000004000000000000000b6d636f7052657475"
    "726e000000000500000000000000156d636f704f6e65776179496e766f636174696f6e"
    "0000000006000000000000000000000011417274733a3a4d6574686f64547970650000"
    "0000020000000d6d6574686f644f6e657761790000000001000000000000000d6d6574"
    "686f6454776f7761790000000002000000000000000000000014417274733a3a417474"
    "7269627574655479706500000000070000000973747265616d496e0000000001000000"
    "000000000a73747265616d4f75740000000002000000000000000c73747265616d4d75"
    "6c74690000000004000000000000001061747472696275746553747265616d00000000"
    "0800000000000000136174747269627574654174747269627574650000000010000000"
    "000000000c73747265616d4173796e630000000020000000000000000e73747265616d"
    "44656661756c740000000040000000000000000000000019417274733a3a5479706549"
    "64656e74696669636174696f6e000000000a0000000a7469556e6b6e6f776e00000000"
    "0000000000000000077469566f69640000000001000000000000000774694c6f6e6700"
    "0000000200000000000000077469427974650000000003000000000000000974695374"
    "72696e670000000004000000000000000a7469426f6f6c65616e000000000500000000"
    "000000087469466c6f6174000000000600000000000000077469456e756d0000000080"
    "00000000000000077469547970650000000081000000000000000c7469496e74657266"
    "61636500000000820000000000000000000000120000000d417274733a3a4865616465"
    "72000000000300000012417274733a3a4865616465724d6167696300000000066d6167"
    "69630000000000000000056c6f6e67000000000e6d6573736167654c656e6774680000"
    "00000000000012417274733a3a4d65737361676554797065000000000c6d6573736167"
    "655479706500000000000000000000000011417274733a3a496e766f636174696f6e00"
    "00000003000000056c6f6e6700000000096f626a65637449440000000000000000056c"
    "6f6e6700000000096d6574686f6449440000000000000000056c6f6e67000000000a72"
    "657175657374494400000000000000000000000017417274733a3a4f6e65776179496e"
    "766f636174696f6e0000000002000000056c6f6e6700000000096f626a656374494400"
    "00000000000000056c6f6e6700000000096d6574686f64494400000000000000000000"
    "000012417274733a3a53657276657248656c6c6f000000000400000007737472696e67"
    "000000000c6d636f7056657273696f6e000000000000000007737472696e6700000000"
    "0973657276657249440000000000000000082a737472696e67000000000e6175746850"
    "726f746f636f6c73000000000000000007737472696e67000000000961757468536565"
    "6400000000000000000000000012417274733a3a436c69656e7448656c6c6f00000000"
    "0300000007737472696e67000000000973657276657249440000000000000000077374"
    "72696e67000000000d6175746850726f746f636f6c000000000000000007737472696e"
    "670000000009617574684461746100000000000000000000000011417274733a3a4175"
    "74684163636570740000000001000000082a737472696e67000000000668696e747300"
    "000000000000000000000016417274733a3a4f626a6563745265666572656e63650000"
    "00000300000007737472696e6700000000097365727665724944000000000000000005"
    "6c6f6e6700000000096f626a65637449440000000000000000082a737472696e670000"
    "00000575726c730000000000000000000000000f417274733a3a506172616d44656600"
    "0000000300000007737472696e67000000000574797065000000000000000007737472"
    "696e6700000000056e616d650000000000000000082a737472696e6700000000066869"
    "6e747300000000000000000000000010417274733a3a4d6574686f6444656600000000"
    "0500000007737472696e6700000000056e616d65000000000000000007737472696e67"
    "000000000574797065000000000000000011417274733a3a4d6574686f645479706500"
    "00000006666c6167730000000000000000102a417274733a3a506172616d4465660000"
    "00000a7369676e61747572650000000000000000082a737472696e6700000000066869"
    "6e747300000000000000000000000013417274733a3a41747472696275746544656600"
    "0000000400000007737472696e6700000000056e616d65000000000000000007737472"
    "696e67000000000574797065000000000000000014417274733a3a4174747269627574"
    "65547970650000000006666c6167730000000000000000082a737472696e6700000000"
    "0668696e747300000000000000000000000013417274733a3a496e7465726661636544"
    "6566000000000600000007737472696e6700000000056e616d65000000000000000008"
    "2a737472696e670000000014696e68657269746564496e746572666163657300000000"
    "00000000112a417274733a3a4d6574686f6444656600000000086d6574686f64730000"
    "000000000000142a417274733a3a417474726962757465446566000000000b61747472"
    "6962757465730000000000000000082a737472696e67000000000d64656661756c7450"
    "6f7274730000000000000000082a737472696e67000000000668696e74730000000000"
    "0000000000000014417274733a3a54797065436f6d706f6e656e740000000003000000"
    "07737472696e67000000000574797065000000000000000007737472696e6700000000"
    "056e616d650000000000000000082a737472696e67000000000668696e747300000000"
    "00000000000000000e417274733a3a5479706544656600000000030000000773747269"
    "6e6700000000056e616d650000000000000000152a417274733a3a54797065436f6d70"
    "6f6e656e740000000009636f6e74656e74730000000000000000082a737472696e6700"
    "0000000668696e747300000000000000000000000014417274733a3a456e756d436f6d"
    "706f6e656e74000000000300000007737472696e6700000000056e616d650000000000"
    "000000056c6f6e67000000000676616c75650000000000000000082a737472696e6700"
    "0000000668696e74730000000000000000000000000e417274733a3a456e756d446566"
    "000000000300000007737472696e6700000000056e616d650000000000000000152a41"
    "7274733a3a456e756d436f6d706f6e656e740000000009636f6e74656e747300000000"
    "00000000082a737472696e67000000000668696e747300000000000000000000000010"
    "417274733a3a4d6f64756c65446566000000000500000007737472696e67000000000b"
    "6d6f64756c654e616d6500000000000000000f2a417274733a3a456e756d4465660000"
    "000006656e756d7300000000000000000f2a417274733a3a5479706544656600000000"
    "0674797065730000000000000000142a417274733a3a496e7465726661636544656600"
    "0000000b696e74657266616365730000000000000000082a737472696e670000000006"
    "68696e74730000000000000000000000000a417274733a3a416e790000000002000000"
    "07737472696e670000000005747970650000000000000000062a627974650000000006"
    "76616c756500000000000000000000000012417274733a3a547261646572456e747279"
    "000000000200000007737472696e67000000000e696e746572666163654e616d650000"
    "000000000000082a737472696e6700000000066c696e65730000000000000000000000"
    "000b00000014417274733a3a496e746572666163655265706f00000000000000000900"
    "00000d696e736572744d6f64756c6500000000056c6f6e670000000002000000010000"
    "0010417274733a3a4d6f64756c65446566000000000a6e65774d6f64756c6500000000"
    "00000000000000000d72656d6f76654d6f64756c650000000005766f69640000000002"
    "00000001000000056c6f6e6700000000096d6f64756c65494400000000000000000000"
    "00000f7175657279496e746572666163650000000013417274733a3a496e7465726661"
    "636544656600000000020000000100000007737472696e6700000000056e616d650000"
    "000000000000000000000a717565727954797065000000000e417274733a3a54797065"
    "44656600000000020000000100000007737472696e6700000000056e616d6500000000"
    "00000000000000000a7175657279456e756d000000000e417274733a3a456e756d4465"
    "6600000000020000000100000007737472696e6700000000056e616d65000000000000"
    "0000000000000e71756572794368696c6472656e00000000082a737472696e67000000"
    "00020000000100000007737472696e6700000000056e616d6500000000000000000000"
    "0000107175657279496e746572666163657300000000082a737472696e670000000002"
    "00000000000000000000000b7175657279547970657300000000082a737472696e6700"
    "0000000200000000000000000000000b7175657279456e756d7300000000082a737472"
    "696e670000000002000000000000000000000000000000000000000000000016417274"
    "733a3a496e746572666163655265706f5632000000000100000014417274733a3a496e"
    "746572666163655265706f00000000010000000d6964656e7469667954797065000000"
    "0019417274733a3a547970654964656e74696669636174696f6e000000000200000001"
    "00000007737472696e6700000000056e616d6500000000000000000000000000000000"
    "000000000000000017417274733a3a466c6f7753797374656d53656e64657200000000"
    "00000000020000000a70726f6365737365640000000005766f69640000000001000000"
    "00000000000000000b646973636f6e6e6563740000000005766f696400000000020000"
    "00000000000000000000000000000000000000000019417274733a3a466c6f77537973"
    "74656d52656365697665720000000000000000010000000b646973636f6e6e65637400"
    "00000005766f6964000000000200000000000000000000000100000011726563656976"
    "6548616e646c6572494400000000056c6f6e6700000000120000000000000000000000"
    "0000000011417274733a3a466c6f7753797374656d0000000000000000070000000c73"
    "746172744f626a6563740000000005766f6964000000000200000001000000076f626a"
    "65637400000000056e6f64650000000000000000000000000b73746f704f626a656374"
    "0000000005766f6964000000000200000001000000076f626a65637400000000056e6f"
    "64650000000000000000000000000e636f6e6e6563744f626a6563740000000005766f"
    "6964000000000200000004000000076f626a656374000000000d736f757263654f626a"
    "656374000000000000000007737472696e67000000000b736f75726365506f72740000"
    "000000000000076f626a656374000000000b646573744f626a65637400000000000000"
    "0007737472696e67000000000964657374506f72740000000000000000000000001164"
    "6973636f6e6e6563744f626a6563740000000005766f69640000000002000000040000"
    "00076f626a656374000000000d736f757263654f626a65637400000000000000000773"
    "7472696e67000000000b736f75726365506f72740000000000000000076f626a656374"
    "000000000b646573744f626a656374000000000000000007737472696e670000000009"
    "64657374506f72740000000000000000000000000b7175657279466c61677300000000"
    "14417274733a3a41747472696275746554797065000000000200000002000000076f62"
    "6a65637400000000056e6f6465000000000000000007737472696e670000000005706f"
    "72740000000000000000000000000e736574466c6f617456616c75650000000005766f"
    "6964000000000200000003000000076f626a65637400000000056e6f64650000000000"
    "00000007737472696e670000000005706f7274000000000000000006666c6f61740000"
    "00000676616c75650000000000000000000000000f6372656174655265636569766572"
    "0000000019417274733a3a466c6f7753797374656d5265636569766572000000000200"
    "000003000000076f626a656374000000000b646573744f626a65637400000000000000"
    "0007737472696e67000000000964657374506f7274000000000000000017417274733a"
    "3a466c6f7753797374656d53656e646572000000000773656e64657200000000000000"
    "000000000000000000000000000000000011417274733a3a476c6f62616c436f6d6d00"
    "0000000000000003000000047075740000000008626f6f6c65616e0000000002000000"
    "0200000007737472696e6700000000097661726961626c650000000000000000077374"
    "72696e67000000000676616c7565000000000000000000000000046765740000000007"
    "737472696e6700000000020000000100000007737472696e6700000000097661726961"
    "626c650000000000000000000000000665726173650000000005766f69640000000002"
    "0000000100000007737472696e6700000000097661726961626c650000000000000000"
    "0000000000000000000000000000000014417274733a3a546d70476c6f62616c436f6d"
    "6d000000000100000011417274733a3a476c6f62616c436f6d6d000000000000000000"
    "000000000000000000000012417274733a3a5472616465724f66666572000000000000"
    "0000010000000c67657450726f706572747900000000082a737472696e670000000002"
    "0000000100000007737472696e6700000000056e616d65000000000000000000000000"
    "010000000e696e746572666163654e616d650000000007737472696e67000000001200"
    "000000000000000000000000000012417274733a3a5472616465725175657279000000"
    "00000000000200000009737570706f7274730000000005766f69640000000002000000"
    "0200000007737472696e67000000000970726f70657274790000000000000000077374"
    "72696e67000000000676616c7565000000000000000000000000067175657279000000"
    "00132a417274733a3a5472616465724f66666572000000000200000000000000000000"
    "000000000000000000000000000d417274733a3a4f626a65637400000000000000000e"
    "0000000e5f6c6f6f6b75704d6574686f6400000000056c6f6e67000000000200000001"
    "00000010417274733a3a4d6574686f64446566000000000a6d6574686f644465660000"
    "000000000000000000000f5f696e746572666163654e616d650000000007737472696e"
    "6700000000020000000000000000000000105f7175657279496e746572666163650000"
    "000013417274733a3a496e746572666163654465660000000002000000010000000773"
    "7472696e6700000000056e616d650000000000000000000000000b5f71756572795479"
    "7065000000000e417274733a3a54797065446566000000000200000001000000077374"
    "72696e6700000000056e616d650000000000000000000000000b5f7175657279456e75"
    "6d000000000e417274733a3a456e756d44656600000000020000000100000007737472"
    "696e6700000000056e616d650000000000000000000000000a5f746f537472696e6700"
    "00000007737472696e6700000000020000000000000000000000125f6973436f6d7061"
    "7469626c65576974680000000008626f6f6c65616e0000000002000000010000000773"
    "7472696e67000000000e696e746572666163656e616d65000000000000000000000000"
    "0c5f636f707952656d6f74650000000005766f69640000000002000000000000000000"
    "00000b5f75736552656d6f74650000000005766f696400000000020000000000000000"
    "0000000f5f72656c6561736552656d6f74650000000005766f69640000000002000000"
    "00000000000000000a5f6164644368696c640000000007737472696e67000000000200"
    "000002000000076f626a65637400000000066368696c64000000000000000007737472"
    "696e6700000000056e616d650000000000000000000000000d5f72656d6f7665436869"
    "6c640000000008626f6f6c65616e00000000020000000100000007737472696e670000"
    "0000056e616d650000000000000000000000000a5f6765744368696c6400000000076f"
    "626a65637400000000020000000100000007737472696e6700000000056e616d650000"
    "000000000000000000000f5f71756572794368696c6472656e00000000082a73747269"
    "6e6700000000020000000000000000000000010000000c5f666c6f7753797374656d00"
    "00000011417274733a3a466c6f7753797374656d000000001200000000000000000000"
    "00000000000d417274733a3a4c6f616465720000000000000000010000000b6c6f6164"
    "4f626a65637400000000076f626a65637400000000020000000100000012417274733a"
    "3a5472616465724f6666657200000000066f6666657200000000000000000000000003"
    "0000000c6461746156657273696f6e0000000007737472696e67000000001200000000"
    "0000000e747261646572456e747269657300000000132a417274733a3a547261646572"
    "456e747279000000001200000000000000086d6f64756c657300000000112a41727473"
    "3a3a4d6f64756c65446566000000001200000000000000000000000000000000"
);
