<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qt Toolkit - QGLFormat Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>QGLFormat Class Reference<br><small>[ <a href="opengl.html">OpenGL module</a> ]</small></h1><br clear="all">
<p>
The QGLFormat class specifies the display format of an OpenGL rendering context.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qgl-h.html">qgl.h</a>&gt;</code>
<p>
Inherits <a href="qgl.html">QGL</a>.
<p><a href="qglformat-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class="fn"><a href="#c9f477"><b>QGLFormat</b></a> () </div>
<li><div class="fn"><a href="#93d950"><b>QGLFormat</b></a> ( int options, int plane = 0 ) </div>
<li><div class="fn">bool <a href="#d90b73"><b>doubleBuffer</b></a> () const</div>
<li><div class="fn">void <a href="#38644f"><b>setDoubleBuffer</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#84543f"><b>depth</b></a> () const</div>
<li><div class="fn">void <a href="#c9b04b"><b>setDepth</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#c41052"><b>rgba</b></a> () const</div>
<li><div class="fn">void <a href="#89df7a"><b>setRgba</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#a225ce"><b>alpha</b></a> () const</div>
<li><div class="fn">void <a href="#28c4a1"><b>setAlpha</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#923800"><b>accum</b></a> () const</div>
<li><div class="fn">void <a href="#9add13"><b>setAccum</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#7729dc"><b>stencil</b></a> () const</div>
<li><div class="fn">void <a href="#3f8dd1"><b>setStencil</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#a1fa0a"><b>stereo</b></a> () const</div>
<li><div class="fn">void <a href="#82dd03"><b>setStereo</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#a012c8"><b>directRendering</b></a> () const</div>
<li><div class="fn">void <a href="#81a31b"><b>setDirectRendering</b></a> ( bool enable ) </div>
<li><div class="fn">bool <a href="#4d483d"><b>hasOverlay</b></a> () const</div>
<li><div class="fn">void <a href="#3186af"><b>setOverlay</b></a> ( bool enable ) </div>
<li><div class="fn">int <a href="#c7a681"><b>plane</b></a> () const</div>
<li><div class="fn">void <a href="#e3fa90"><b>setPlane</b></a> ( int plane ) </div>
<li><div class="fn">void <a href="#ebfce6"><b>setOption</b></a> ( FormatOption opt ) </div>
<li><div class="fn">bool <a href="#9f0704"><b>testOption</b></a> ( FormatOption opt ) const</div>
</ul>
<h2>Static Public Members</h2>
<ul>
<li><div class="fn">QGLFormat <a href="#8f6f62"><b>defaultFormat</b></a> () </div>
<li><div class="fn">void <a href="#be1e65"><b>setDefaultFormat</b></a> ( const QGLFormat &amp; f ) </div>
<li><div class="fn">QGLFormat <a href="#4dd7cf"><b>defaultOverlayFormat</b></a> () </div>
<li><div class="fn">void <a href="#581a4b"><b>setDefaultOverlayFormat</b></a> ( const QGLFormat &amp; f ) </div>
<li><div class="fn">bool <a href="#59330f"><b>hasOpenGL</b></a> () </div>
<li><div class="fn">bool <a href="#efc77b"><b>hasOpenGLOverlays</b></a> () </div>
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QGLFormat class specifies the display format of an OpenGL rendering context.
<p>
A display format has several characteristics:
<ul>
<li> <a href="#38644f">Double or single buffering.</a>
<li> <a href="#c9b04b">Depth buffer.</a>
<li> <a href="#89df7a">RGBA or color index mode.</a>
<li> <a href="#28c4a1">Alpha channel.</a>
<li> <a href="#9add13">Accumulation buffer.</a>
<li> <a href="#3f8dd1">Stencil buffer.</a>
<li> <a href="#82dd03">Stereo buffers.</a>
<li> <a href="#81a31b">Direct rendering.</a>
<li> <a href="#3186af">Presence of an overlay.</a>
<li> <a href="#e3fa90">The plane of an overlay format.</a>
</ul>
<p>You create and tell a QGLFormat object what rendering options
you want from an OpenGL rendering context.
<p>OpenGL drivers or accelerated hardware may or may not support
advanced features like alpha channel or stereographic viewing. If
you request some features the driver/hardware does not provide when
you create a <a href="qglwidget.html">QGLWidget</a>, you will get the a rendering context with
the nearest subset of features.
<p>There are different ways of defining the display characteristics
of a rendering context. One is to create a QGLFormat and make
it default for the entire application:
<pre>    <a href="qglformat.html">QGLFormat</a> f;
    f.<a href="#28c4a1">setAlpha</a>( TRUE );
    f.<a href="#82dd03">setStereo</a>( TRUE );
    <a href="#be1e65">QGLFormat::setDefaultFormat</a>( f );
</pre>
<p>Or you can specify the desired format when creating an object of
your QGLWidget subclass:
<pre>    <a href="qglformat.html">QGLFormat</a> f;
    f.<a href="#38644f">setDoubleBuffer</a>( FALSE );                 // I want single buffer
    f.<a href="#81a31b">setDirectRendering</a>( FALSE );              // I want software rendering
    MyGLWidget* myWidget = new MyGLWidget( f, ... );
</pre>
<p>After the widget has been created, you can test which of the
requested features the system was able to provide:
<pre>    <a href="qglformat.html">QGLFormat</a> f;
    f.<a href="#3186af">setOverlay</a>( TRUE );
    f.<a href="#82dd03">setStereo</a>( TRUE );
    MyGLWidget* myWidget = new MyGLWidget( f, ... );
    if ( !w-&gt;format().stereo() ) {
        // ok, goggles off
        if ( !w-&gt;format().hasOverlay() ) {
            <a href="qapplication.html#0e1d68">qFatal</a>( "Cool hardware wanted" );
        }
    }
</pre>
<p>See also  <a href="qglcontext.html">QGLContext</a> and <a href="qglwidget.html">QGLWidget</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="c9f477"></a>QGLFormat::QGLFormat ()</h3>
<p>Constructs a QGLFormat object with the factory default settings:
<ul>
<li> <a href="#38644f">Double buffer:</a> Enabled.
<li> <a href="#c9b04b">Depth buffer:</a> Enabled.
<li> <a href="#89df7a">RGBA:</a> Enabled (i.e. color index disabled).
<li> <a href="#28c4a1">Alpha channel:</a> Disabled.
<li> <a href="#9add13">Accumulator buffer:</a> Disabled.
<li> <a href="#3f8dd1">Stencil buffer:</a> Disabled.
<li> <a href="#82dd03">Stereo:</a> Disabled.
<li> <a href="#81a31b">Direct rendering:</a> Enabled.
<li> <a href="#3186af">Overlay:</a> Disabled.
<li> <a href="#e3fa90">Plane:</a> 0 (i.e. normal plane).
</ul>
<h3 class="fn"><a name="93d950"></a>QGLFormat::QGLFormat ( int options, int plane = 0 )</h3>
<p>Creates a QGLFormat object that is a copy of the current <a href="#8f6f62">application default format</a>.
<p>If <em>options</em> is not 0, this copy will be modified by these format options.
The <em>options</em> parameter must be FormatOption values OR'ed together.
<p>This constructor makes it easy to specify a certain desired format
in classes derived from <a href="qglwidget.html">QGLWidget</a>, for example:
<pre>    // The rendering in MyGLWidget depends on using
    // stencil buffer and alpha channel
    MyGLWidget::MyGLWidget( <a href="qwidget.html">QWidget</a>* parent, const char* name )
        : <a href="qglwidget.html">QGLWidget</a>( <a href="qglformat.html">QGLFormat</a>( StencilBuffer | AlphaChannel ), parent, name )
    {
      if ( !format().stencil() )
        <a href="qapplication.html#290ef4">qWarning</a>( "Could not get stencil buffer; results will be suboptimal" );
      if ( !format().alphaChannel() )
        <a href="qapplication.html#290ef4">qWarning</a>( "Could not get alpha channel; results will be suboptimal" );
      ...
   }
</pre>
<p>Note that there exists FormatOption values for both turning on and
off all format settings, e.g. DepthBuffer and NoDepthBuffer,
DirectRendering and IndirectRendering, etc.
<p>See also  <a href="#8f6f62">defaultFormat</a>() and <a href="#ebfce6">setOption</a>().
<h3 class="fn">bool <a name="923800"></a>QGLFormat::accum () const</h3>
<p>Returns TRUE if the accumulation buffer is enabled, otherwise FALSE.
The accumulation buffer is disabled by default.
<p>See also  <a href="#9add13">setAccum</a>().
<h3 class="fn">bool <a name="a225ce"></a>QGLFormat::alpha () const</h3>
<p>Returns TRUE if the alpha channel of the framebuffer is enabled,
otherwise FALSE.  The alpha channel is disabled by default.
<p>See also  <a href="#28c4a1">setAlpha</a>().
<h3 class="fn">QGLFormat <a name="8f6f62"></a>QGLFormat::defaultFormat () <code>[static]</code></h3>
<p>Returns the default QGLFormat for the application.
All QGLWidgets that are created use this format unless
anything else is specified.
<p>If no special default format has been set using <a href="#be1e65">setDefaultFormat</a>(),
the default format is the same as that created with QGLFormat().
<p>See also  <a href="#be1e65">setDefaultFormat</a>().
<h3 class="fn">QGLFormat <a name="4dd7cf"></a>QGLFormat::defaultOverlayFormat () <code>[static]</code></h3>
<p>Returns the default QGLFormat for overlay contexts.
<p>The factory default overlay format is:
<ul>
<li> <a href="#38644f">Double buffer:</a> Disabled.
<li> <a href="#c9b04b">Depth buffer:</a> Disabled.
<li> <a href="#89df7a">RGBA:</a> Disabled (i.e. color index enabled).
<li> <a href="#28c4a1">Alpha channel:</a> Disabled.
<li> <a href="#9add13">Accumulator buffer:</a> Disabled.
<li> <a href="#3f8dd1">Stencil buffer:</a> Disabled.
<li> <a href="#82dd03">Stereo:</a> Disabled.
<li> <a href="#81a31b">Direct rendering:</a> Enabled.
<li> <a href="#3186af">Overlay:</a> Disabled.
<li> <a href="#e3fa90">Plane:</a> 1 (i.e. first overlay plane).
</ul>
<p>See also  <a href="#be1e65">setDefaultFormat</a>().
<h3 class="fn">bool <a name="84543f"></a>QGLFormat::depth () const</h3>
<p>Returns TRUE if the depth buffer is enabled, otherwise FALSE.
The depth buffer is enabled by default.
<p>See also  <a href="#c9b04b">setDepth</a>().
<h3 class="fn">bool <a name="a012c8"></a>QGLFormat::directRendering () const</h3>
<p>Returns TRUE if direct rendering is enabled, otherwise FALSE.
<p>Direct rendering is enabled by default.
<p>See also  <a href="#81a31b">setDirectRendering</a>().
<h3 class="fn">bool <a name="d90b73"></a>QGLFormat::doubleBuffer () const</h3>
<p>Returns TRUE if double buffering is enabled, otherwise FALSE.
Double buffering is enabled by default.
<p>See also  <a href="#38644f">setDoubleBuffer</a>().
<h3 class="fn">bool <a name="59330f"></a>QGLFormat::hasOpenGL () <code>[static]</code></h3>
<p>Returns TRUE if the window system has any OpenGL support,
otherwise FALSE.
<p>Note: This function may not be called until the <a href="qapplication.html">QApplication</a> object has
been created.
<h3 class="fn">bool <a name="efc77b"></a>QGLFormat::hasOpenGLOverlays () <code>[static]</code></h3>
<p>Returns TRUE if the window system supports OpenGL overlays,
otherwise FALSE.
<p>Note: This function may not be called until the <a href="qapplication.html">QApplication</a> object has
been created.
<h3 class="fn">bool <a name="4d483d"></a>QGLFormat::hasOverlay () const</h3>
<p>Returns TRUE if overlay plane is enabled, otherwise FALSE.
<p>Overlay is disabled by default.
<p>See also  <a href="#3186af">setOverlay</a>().
<h3 class="fn">int <a name="c7a681"></a>QGLFormat::plane () const</h3>
<p>Returns the plane of this format. Default for normal formats is 0,
which means the normal plane; default for overlay formats is 1,
which is the first overlay plane.
<p>See also  <a href="#e3fa90">setPlane</a>().
<h3 class="fn">bool <a name="c41052"></a>QGLFormat::rgba () const</h3>
<p>Returns TRUE if RGBA color mode is set, or FALSE if color index
mode is set. The default color mode is RGBA.
<p>See also  <a href="#89df7a">setRgba</a>().
<h3 class="fn">void <a name="9add13"></a>QGLFormat::setAccum ( bool enable )</h3>
<p>Enables the accumulation buffer if <em>enable</em> is TRUE, or disables
it if <em>enable</em> is FALSE.
<p>The accumulation buffer is disabled by default.
<p>The accumulation buffer is used for create blur effects and
multiple exposures.
<p>See also  <a href="#923800">accum</a>().
<h3 class="fn">void <a name="28c4a1"></a>QGLFormat::setAlpha ( bool enable )</h3>
<p>Enables the alpha channel of the framebuffer if <em>enable</em> is TRUE,
or disables it if <em>enable</em> is FALSE.
<p>The alpha buffer is disabled by default.
<p>The alpha channel is typically used for implementing transparency or
translucency.  The A in RGBA specifies the transparency of a pixel.
<p>See also  <a href="#a225ce">alpha</a>().
<h3 class="fn">void <a name="be1e65"></a>QGLFormat::setDefaultFormat ( const QGLFormat &amp; f ) <code>[static]</code></h3>
<p>Sets a new default QGLFormat for the application.
For example, to set single buffering as default instead
of double buffering, your main() can contain:
<pre>    <a href="qapplication.html">QApplication</a> a(argc, argv);
    <a href="qglformat.html">QGLFormat</a> f;
    f.<a href="#38644f">setDoubleBuffer</a>( FALSE );
    <a href="#be1e65">QGLFormat::setDefaultFormat</a>( f );
</pre>
<p>See also  <a href="#8f6f62">defaultFormat</a>().
<h3 class="fn">void <a name="581a4b"></a>QGLFormat::setDefaultOverlayFormat ( const QGLFormat &amp; f ) <code>[static]</code></h3>
<p>Sets a new default QGLFormat for overlay contexts. This format is
used whenever a <a href="qglwidget.html">QGLWidget</a> is created with a format with <a href="#4d483d">hasOverlay</a>()
enabled.
<p>For example, to get a double buffered overlay contexts (if
available), the code can do:
<p><pre>    <a href="qglformat.html">QGLFormat</a> f = QGLFormat::defaultOverlayFormat();
    f.<a href="#38644f">setDoubleBuffer</a>( TRUE );
    <a href="#581a4b">QGLFormat::setDefaultOverlayFormat</a>( f );
</pre>
<p>As usual, you can test after the widget creation whether the
underlying OpenGL system was able to provide the requested
specification:
<p><pre>    // (...continued from above)
    MyGLWidget* myWidget = new MyGLWidget( <a href="qglformat.html">QGLFormat</a>( QGL::HasOverlay ), ... );
    if ( myWidget-&gt;format().hasOverlay() ) {
      // Yes, we got an overlay, let's check _its_ format:
      <a href="qglcontext.html">QGLContext</a>* olContext = myWidget-&gt;overlayContext();
      if ( olContext-&gt;<a href="qglcontext.html#df01e6">format</a>().doubleBuffer() )
         ; // yes, we got a double buffered overlay
      else
         ; // no, only single buffered overlays were available
    }
</pre>
<p>See also  <a href="#4dd7cf">defaultOverlayFormat</a>().
<h3 class="fn">void <a name="c9b04b"></a>QGLFormat::setDepth ( bool enable )</h3>
<p>Enables the depth buffer if <em>enable</em> is TRUE, or disables
it if <em>enable</em> is FALSE.
<p>The depth buffer is enabled by default.
<p>The purpose of a depth buffer (or z-buffering) is to remove hidden
surfaces. Pixels are assigned z values based on the distance to the
viewer. A pixel with a high z value is closer to the viewer than a
pixel with a low z value. This information is used to decide whether
to draw a pixel or not.
<p>See also  <a href="#84543f">depth</a>().
<h3 class="fn">void <a name="81a31b"></a>QGLFormat::setDirectRendering ( bool enable )</h3>
<p>Enables direct rendering if <em>enable</em> is TRUE, or disables
it if <em>enable</em> is FALSE.
<p>Direct rendering is enabled by default.
<p>Enabling this option will make OpenGL bypass the underlying window
system and render directly from hardware to the screen, if this is
supported by the system.
<p>See also  <a href="#a012c8">directRendering</a>().
<h3 class="fn">void <a name="38644f"></a>QGLFormat::setDoubleBuffer ( bool enable )</h3>
<p>Sets double buffering if <em>enable</em> is TRUE or single buffering if
<em>enable</em> is FALSE.
<p>Double buffering is enabled by default.
<p>Double buffering is a technique where graphics is rendered to an off-screen
buffer and not directly to the screen. When the drawing has been
completed, the program calls a swapBuffers function to exchange the screen
contents with the buffer. The result is flicker-free drawing and often
better performance.
<p>See also  <a href="#d90b73">doubleBuffer</a>(), <a href="qglcontext.html#35dbed">QGLContext::swapBuffers</a>() and <a href="qglwidget.html#a0d069">QGLWidget::swapBuffers</a>().
<h3 class="fn">void <a name="ebfce6"></a>QGLFormat::setOption ( FormatOption opt )</h3>
<p>Sets the option <em>opt.</em>
<p>See also  <a href="#9f0704">testOption</a>().
<h3 class="fn">void <a name="3186af"></a>QGLFormat::setOverlay ( bool enable )</h3>
<p>Enables an overlay plane if <em>enable</em> is TRUE; otherwise disables it.
<p>Enabling the overlay plane will cause <a href="qglwidget.html">QGLWidget</a> to create an
additional context in an overlay plane. See the QGLWidget
documentation for further information.
<p>See also  <a href="#4d483d">hasOverlay</a>().
<h3 class="fn">void <a name="e3fa90"></a>QGLFormat::setPlane ( int plane )</h3>
<p>Sets the requested plane. 0 is the normal plane, 1 is the first
overlay plane, 2 is the second overlay plane, etc., and -1, -2,
etc. are underlay planes.
<p>Note that, in contrast to the other format specifications, the plane
specifications will be matched exactly. Thus, if you specify a plane
that the underlying OpenGL system cannot provide, an <a href="qglwidget.html#af9038">invalid</a> <a href="qglwidget.html">QGLWidget</a> will be created.
<p>See also  <a href="#c7a681">plane</a>().
<h3 class="fn">void <a name="89df7a"></a>QGLFormat::setRgba ( bool enable )</h3>
<p>Sets RGBA mode if <em>enable</em> is TRUE, or color index mode if <em>enable</em>
is FALSE.
<p>The default color mode is RGBA.
<p>RGBA is the preferred mode for most OpenGL applications.
In RGBA color mode you specify colors as a red + green + blue + alpha
quadruplet.
<p>In color index mode you specify an index into a color lookup table.
<p>See also  <a href="#c41052">rgba</a>().
<h3 class="fn">void <a name="3f8dd1"></a>QGLFormat::setStencil ( bool enable )</h3>
<p>Enables the stencil buffer if <em>enable</em> is TRUE, or disables
it if <em>enable</em> is FALSE.
<p>The stencil buffer is disabled by default.
<p>The stencil buffer masks away drawing from certain parts of
the screen.
<p>See also  <a href="#7729dc">stencil</a>().
<h3 class="fn">void <a name="82dd03"></a>QGLFormat::setStereo ( bool enable )</h3>
<p>Enables stereo buffering if <em>enable</em> is TRUE, or disables
it if <em>enable</em> is FALSE.
<p>Stereo buffering is disabled by default.
<p>Stereo buffering provides extra color buffers to generate left-eye
and right-eye images.
<p>See also  <a href="#a1fa0a">stereo</a>().
<h3 class="fn">bool <a name="7729dc"></a>QGLFormat::stencil () const</h3>
<p>Returns TRUE if the stencil buffer is enabled, otherwise FALSE.
The stencil buffer is disabled by default.
<p>See also  <a href="#3f8dd1">setStencil</a>().
<h3 class="fn">bool <a name="a1fa0a"></a>QGLFormat::stereo () const</h3>
<p>Returns TRUE if stereo buffering is enabled, otherwise FALSE.
Stereo buffering is disabled by default.
<p>See also  <a href="#82dd03">setStereo</a>().
<h3 class="fn">bool <a name="9f0704"></a>QGLFormat::testOption ( FormatOption opt ) const</h3>
<p>Returns TRUE if format option <em>opt</em> is set, otherwise FALSE.
<p>See also  <a href="#ebfce6">setOption</a>().
<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses
<a href="http://www.trolltech.com">www.trolltech.com</a>):<br>
<form method=post action="http://www.trolltech.com/search.cgi">
<input type=hidden name="version" value="2.3.2"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-2001
<a href="http://www.trolltech.com">Trolltech</a>, all rights reserved.<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2001 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.2</div>
</table></div></address></body></html>
