<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qt Toolkit - QIconView Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>QIconView Class Reference<br><small>[ <a href="iconview.html">iconview module</a> ]</small></h1><br clear="all">
<p>
The QIconView class provides an area with movable labelled icons.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qiconview-h.html">qiconview.h</a>&gt;</code>
<p>
Inherits <a href="qscrollview.html">QScrollView</a>.
<p><a href="qiconview-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class="fn">enum <a href="#SelectionMode"><b>SelectionMode</b></a> { Single = 0, Multi, Extended, NoSelection }</div>
<li><div class="fn">enum <a href="#Arrangement"><b>Arrangement</b></a> { LeftToRight = 0, TopToBottom }</div>
<li><div class="fn">enum <a href="#ResizeMode"><b>ResizeMode</b></a> { Fixed = 0, Adjust }</div>
<li><div class="fn">enum <a href="#ItemTextPos"><b>ItemTextPos</b></a> { Bottom = 0, Right }</div>
<li><div class="fn"><a href="#a3849b"><b>QIconView</b></a> ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 ) </div>
<li><div class="fn">virtual <a href="#5872e0"><b>~QIconView</b></a> () </div>
<li><div class="fn">virtual void <a href="#2d0207"><b>insertItem</b></a> ( QIconViewItem * item, QIconViewItem * after = 0L ) </div>
<li><div class="fn">virtual void <a href="#7164b3"><b>takeItem</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">int <a href="#e97fe2"><b>index</b></a> ( const QIconViewItem * item ) const</div>
<li><div class="fn">QIconViewItem* <a href="#f4df66"><b>firstItem</b></a> () const</div>
<li><div class="fn">QIconViewItem* <a href="#13c5a9"><b>lastItem</b></a> () const</div>
<li><div class="fn">QIconViewItem* <a href="#b2a5c7"><b>currentItem</b></a> () const</div>
<li><div class="fn">virtual void <a href="#b30724"><b>setCurrentItem</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">virtual void <a href="#81719c"><b>setSelected</b></a> ( QIconViewItem * item, bool s, bool cb = FALSE ) </div>
<li><div class="fn">uint <a href="#6bb21a"><b>count</b></a> () const</div>
<li><div class="fn">virtual void <a href="#98457a"><b>setSelectionMode</b></a> ( SelectionMode m ) </div>
<li><div class="fn">SelectionMode <a href="#0040a8"><b>selectionMode</b></a> () const</div>
<li><div class="fn">QIconViewItem* <a href="#526763"><b>findItem</b></a> ( const QPoint &amp; pos ) const</div>
<li><div class="fn">QIconViewItem* <a href="#ec58f0"><b>findItem</b></a> ( const QString &amp; text ) const</div>
<li><div class="fn">virtual void <a href="#31b5ce"><b>selectAll</b></a> ( bool select ) </div>
<li><div class="fn">virtual void <a href="#767612"><b>clearSelection</b></a> () </div>
<li><div class="fn">virtual void <a href="#e283c9"><b>invertSelection</b></a> () </div>
<li><div class="fn">virtual void <a href="#65c0ac"><b>repaintItem</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">void <a href="#76c81f"><b>ensureItemVisible</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">QIconViewItem* <a href="#4e4ffe"><b>findFirstVisibleItem</b></a> ( const QRect &amp; r ) const</div>
<li><div class="fn">QIconViewItem* <a href="#7d074a"><b>findLastVisibleItem</b></a> ( const QRect &amp; r ) const</div>
<li><div class="fn">virtual void <a href="#f84d65"><b>clear</b></a> () </div>
<li><div class="fn">virtual void <a href="#6c95d9"><b>setGridX</b></a> ( int rx ) </div>
<li><div class="fn">virtual void <a href="#feb12c"><b>setGridY</b></a> ( int ry ) </div>
<li><div class="fn">int <a href="#2c5c00"><b>gridX</b></a> () const</div>
<li><div class="fn">int <a href="#304c4d"><b>gridY</b></a> () const</div>
<li><div class="fn">virtual void <a href="#f39ce3"><b>setSpacing</b></a> ( int sp ) </div>
<li><div class="fn">int <a href="#2f08d8"><b>spacing</b></a> () const</div>
<li><div class="fn">virtual void <a href="#a495e8"><b>setItemTextPos</b></a> ( ItemTextPos pos ) </div>
<li><div class="fn">ItemTextPos <a href="#429e49"><b>itemTextPos</b></a> () const</div>
<li><div class="fn">virtual void <a href="#949782"><b>setItemTextBackground</b></a> ( const QBrush &amp; b ) </div>
<li><div class="fn">QBrush <a href="#251f1c"><b>itemTextBackground</b></a> () const</div>
<li><div class="fn">virtual void <a href="#bf383b"><b>setArrangement</b></a> ( Arrangement am ) </div>
<li><div class="fn">Arrangement <a href="#332d1c"><b>arrangement</b></a> () const</div>
<li><div class="fn">virtual void <a href="#4a1229"><b>setResizeMode</b></a> ( ResizeMode am ) </div>
<li><div class="fn">ResizeMode <a href="#6347ef"><b>resizeMode</b></a> () const</div>
<li><div class="fn">virtual void <a href="#942024"><b>setMaxItemWidth</b></a> ( int w ) </div>
<li><div class="fn">int <a href="#17c372"><b>maxItemWidth</b></a> () const</div>
<li><div class="fn">virtual void <a href="#ba0e49"><b>setMaxItemTextLength</b></a> ( int w ) </div>
<li><div class="fn">int <a href="#da54ae"><b>maxItemTextLength</b></a> () const</div>
<li><div class="fn">virtual void <a href="#7b3f0b"><b>setAutoArrange</b></a> ( bool b ) </div>
<li><div class="fn">bool <a href="#70daef"><b>autoArrange</b></a> () const</div>
<li><div class="fn">virtual void <a href="#612f32"><b>setShowToolTips</b></a> ( bool b ) </div>
<li><div class="fn">bool <a href="#355480"><b>showToolTips</b></a> () const</div>
<li><div class="fn">void <a href="#540892"><b>setSorting</b></a> ( bool sort, bool ascending = TRUE ) </div>
<li><div class="fn">bool <a href="#b779dd"><b>sorting</b></a> () const</div>
<li><div class="fn">bool <a href="#4ff476"><b>sortDirection</b></a> () const</div>
<li><div class="fn">virtual void <a href="#037c84"><b>setItemsMovable</b></a> ( bool b ) </div>
<li><div class="fn">bool <a href="#7aba5f"><b>itemsMovable</b></a> () const</div>
<li><div class="fn">virtual void <a href="#dbeaa6"><b>setWordWrapIconText</b></a> ( bool b ) </div>
<li><div class="fn">bool <a href="#644375"><b>wordWrapIconText</b></a> () const</div>
<li><div class="fn">virtual void <a href="#7be9a1"><b>sort</b></a> ( bool ascending = TRUE ) </div>
</ul>
<h2>Public Slots</h2>
<ul>
<li><div class="fn">virtual void <a href="#9fb7be"><b>arrangeItemsInGrid</b></a> ( const QSize &amp; grid, bool update = TRUE ) </div>
<li><div class="fn">virtual void <a href="#a66b75"><b>arrangeItemsInGrid</b></a> ( bool update = TRUE ) </div>
<li><div class="fn">virtual void <b>updateContents</b> () (internal)</div>
</ul>
<h2>Signals</h2>
<ul>
<li><div class="fn">void <a href="#fac306"><b>selectionChanged</b></a> () </div>
<li><div class="fn">void <a href="#4dcf65"><b>selectionChanged</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">void <a href="#9aaf90"><b>currentChanged</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">void <a href="#d37c32"><b>clicked</b></a> ( QIconViewItem * ) </div>
<li><div class="fn">void <a href="#2d5902"><b>clicked</b></a> ( QIconViewItem *, const QPoint &amp; ) </div>
<li><div class="fn">void <a href="#9aba48"><b>pressed</b></a> ( QIconViewItem * ) </div>
<li><div class="fn">void <a href="#bf2323"><b>pressed</b></a> ( QIconViewItem *, const QPoint &amp; ) </div>
<li><div class="fn">void <a href="#3fac1f"><b>doubleClicked</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">void <a href="#0567c1"><b>returnPressed</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">void <a href="#ad2630"><b>rightButtonClicked</b></a> ( QIconViewItem * item, const QPoint &amp; pos ) </div>
<li><div class="fn">void <a href="#3fb30b"><b>rightButtonPressed</b></a> ( QIconViewItem * item, const QPoint &amp; pos ) </div>
<li><div class="fn">void <a href="#15dc22"><b>mouseButtonPressed</b></a> ( int button, QIconViewItem * item, const QPoint &amp; pos ) </div>
<li><div class="fn">void <a href="#7a6311"><b>mouseButtonClicked</b></a> ( int button, QIconViewItem * item, const QPoint &amp; pos ) </div>
<li><div class="fn">void <a href="#b97176"><b>dropped</b></a> ( QDropEvent * e, const QValueList&lt;QIconDragItem&gt; &amp; lst ) </div>
<li><div class="fn">void <a href="#7d6d77"><b>moved</b></a> () </div>
<li><div class="fn">void <a href="#21b913"><b>onItem</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">void <a href="#608fee"><b>onViewport</b></a> () </div>
<li><div class="fn">void <a href="#0b5c7c"><b>itemRenamed</b></a> ( QIconViewItem * item, const QString &amp; ) </div>
<li><div class="fn">void <a href="#c5f6fe"><b>itemRenamed</b></a> ( QIconViewItem * item ) </div>
</ul>
<h2>Protected Members</h2>
<ul>
<li><div class="fn">virtual void <a href="#5708e1"><b>drawRubber</b></a> ( QPainter * p ) </div>
<li><div class="fn">virtual QDragObject* <a href="#8a680b"><b>dragObject</b></a> () </div>
<li><div class="fn">virtual void <a href="#9918ce"><b>startDrag</b></a> () </div>
<li><div class="fn">virtual void <a href="#d14416"><b>insertInGrid</b></a> ( QIconViewItem * item ) </div>
<li><div class="fn">virtual void <a href="#e825cc"><b>drawBackground</b></a> ( QPainter * p, const QRect &amp; r ) </div>
<li><div class="fn">void <a href="#2206c3"><b>emitSelectionChanged</b></a> ( QIconViewItem * i = 0 ) </div>
<li><div class="fn">void <b>emitRenamed</b> ( QIconViewItem * item ) (internal)</div>
<li><div class="fn">QIconViewItem* <a href="#c0ef82"><b>makeRowLayout</b></a> ( QIconViewItem * begin, int &amp; y ) </div>
</ul>
<h2>Protected Slots</h2>
<ul>
<li><div class="fn">virtual void <a href="#0fc7d8"><b>doAutoScroll</b></a> () </div>
<li><div class="fn">virtual void <a href="#c9ca05"><b>adjustItems</b></a> () </div>
<li><div class="fn">virtual void <a href="#0a8823"><b>slotUpdate</b></a> () </div>
</ul>
<h2>Properties</h2>
<table border=1 cellpadding=3 cellspacing=0>
<tr><th>Type<th>Name<th>READ<th>WRITE<th>Options
<tr><td>bool<td>sorting<td>sorting<td>&nbsp;<td>&nbsp;
<tr><td>bool<td>sortDirection<td>sortDirection<td>&nbsp;<td>&nbsp;
<tr><td>SelectionMode<td>selectionMode<td>selectionMode<td>setSelectionMode<td>&nbsp;
<tr><td>int<td>gridX<td>gridX<td>setGridX<td>&nbsp;
<tr><td>int<td>gridY<td>gridY<td>setGridY<td>&nbsp;
<tr><td>int<td>spacing<td>spacing<td>setSpacing<td>&nbsp;
<tr><td>ItemTextPos<td>itemTextPos<td>itemTextPos<td>setItemTextPos<td>&nbsp;
<tr><td>QBrush<td>itemTextBackground<td>itemTextBackground<td>setItemTextBackground<td>&nbsp;
<tr><td>Arrangement<td>arrangement<td>arrangement<td>setArrangement<td>&nbsp;
<tr><td>ResizeMode<td>resizeMode<td>resizeMode<td>setResizeMode<td>&nbsp;
<tr><td>int<td>maxItemWidth<td>maxItemWidth<td>setMaxItemWidth<td>&nbsp;
<tr><td>int<td>maxItemTextLength<td>maxItemTextLength<td>setMaxItemTextLength<td>&nbsp;
<tr><td>bool<td>autoArrange<td>autoArrange<td>setAutoArrange<td>&nbsp;
<tr><td>bool<td>itemsMovable<td>itemsMovable<td>setItemsMovable<td>&nbsp;
<tr><td>bool<td>wordWrapIconText<td>wordWrapIconText<td>setWordWrapIconText<td>&nbsp;
<tr><td>bool<td>showToolTips<td>showToolTips<td>setShowToolTips<td>&nbsp;
<tr><td>uint<td>count<td>count<td>&nbsp;<td>&nbsp;
</table>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QIconView class provides an area with movable labelled icons.
<p>
It can display and control a grid or other 2-d layout of items, and
provides the ability to add or remove new items at any time, lets
the user select one or may items, rearrange the items, provides drag
and drop of items, and so on.
<p>Each item (a <a href="qiconviewitem.html">QIconViewItem</a>) contains a text and a pixmap (the icon itself).
<p>The simplest usage of QIconView is to create the object, create some
QIconViewItems with the view as parent, set the view's geometry, and
show it.
<p>When an item is inserted, QIconView allocates a spot for it. The
default <a href="#Arrangement">Arrangement</a> is <code>LeftToRight</code> - QIconView fills up the
leftmost column first, then goes rightwards. You can change that
using <a href="#bf383b">setArrangement</a>(), or insert items in a specified position by
calling the appropriate constructors or QIconViewItem::insertItem(),
or sort while the view is on-screen using <a href="#540892">setSorting</a>() and/or
<a href="#7be9a1">sort</a>().
<p>Each (<a href="qiconviewitem.html#3ff63a">selectable</a>) item
can be selected, and the view provides various <a href="#SelectionMode">SelectionMode</a>
settings. The default is <code>Single</code> - when one item is selected, the
previously selected item is unselected.
<p>The QIconView provides a widget which can contain lots of iconview
items which can be selected, dragged and so on.
<p>Items can be inserted in a grid and can flow from top to bottom
(TopToBottom) or from left to right (LeftToRight). The text can be
either displayed at the bottom of the icons or the the right of the
icons. Items can also be inserted in a sorted order. There are also
methods to re-arrange and re-sort the items after they have been
inserted.
<p>There is a variety of selection modes, described in the
<a href="#SelectionMode">QIconView::SelectionMode</a> documentation. The default is
single-selection, and you can change it using <a href="#98457a">setSelectionMode</a>().
<p>Since QIconView offers multiple selection it has to display keyboard
focus and selection state separately. Therefore there are functions
both to set the selection state of an item, <a href="#81719c">setSelected</a>(), and to
select which item displays keyboard focus, <a href="#b30724">setCurrentItem</a>().
<p>When multiple items may be selected, the iconview provides a
rubberband too.
<p>Items can also be in-place renamed.
<p>The normal way to insert some items is to create QIconViewItems and
pass the iconview as parent. By using <a href="#2d0207">insertItem</a>(), items can be
inserted manually too. The QIconView offers basic methods similar to
the <a href="qlistview.html">QListView</a> and <a href="qlistbox.html">QListBox</a>, like <a href="#7164b3">QIconView::takeItem</a>(),
<a href="#767612">QIconView::clearSelection</a>(), <a href="#81719c">QIconView::setSelected</a>(),
<a href="#b30724">QIconView::setCurrentItem</a>(), <a href="#b2a5c7">QIconView::currentItem</a>() and much more.
<p>As the internal structure to store the iconview items is linear (a
double linked list), no iterator class is needed to iterate over all
items. This can be easily done with a code like
<p><pre>  <a href="qiconview.html">QIconView</a> *iv = the iconview
  for ( <a href="qiconviewitem.html">QIconViewItem</a> *i = iv-&gt;<a href="#f4df66">firstItem</a>(); i; i = i-&gt;<a href="qiconviewitem.html#005b99">nextItem</a>() ) {
      i-&gt;doSmething();
  }
</pre>
<p>To notify the application about changes in the iconview there are
several signals which are emitted by the QIconView.
<p>The QIconView is designed for Drag'<a href="n.html">n</a>'Drop, as the icons are also
moved inside the iconview itself using DnD. So the QIconView
provides some methods for extended DnD too. To use DnD correctly in
the iconview, please read following instructions:
<p>There are two different ways to do that, depending what you want.
The first case is the simple one, in which case just the dragobject
you created is dragged around. If you want, that drag shapes (the
rectangles of the dragged items with exact positions) are drawn, you
have to choose the more complicated way. Here first the simple case
is described:
<p>In the simple case you only need for starting a drag to reimplement
<a href="#8a680b">QIconView::dragObject</a>(). There you create a <a href="qdragobject.html">QDragObject</a> with the
data you want to drag and return it. And for entering drags you
don't need to do anything special then. Just connect to <a href="#b97176">dropped</a>()
signal to get notified about drops onto the viewport and reimplement
<a href="qiconviewitem.html#7ca2b9">QIconViewItem::acceptDrop</a>() and <a href="qiconviewitem.html#741a24">QIconViewItem::dropped</a>() to be able
to react on drops onto an iconview item.
<p>If you want to have drag shapes drawn, you have to do quite a bit
more and complex things:
<p>The first part is starting drags: If you want to use extended DnD in
the QIconView, you should use <a href="qicondrag.html">QIconDrag</a> (or a derived class from
that) as dragobject and in <a href="#8a680b">dragObject</a>() create such an object and
return it. Before returning it, fill it there with QIconDragItems.
Normally such a drag should offer data of each selected item. So in
dragObject() you should iterate over all items, create for each
selected item a <a href="qicondragitem.html">QIconDragItem</a> and append this with
<a href="qicondrag.html#e2f3cc">QIconDrag::append</a>() to the QIconDrag object. With
<a href="qicondragitem.html#89eea4">QIconDragItem::setData</a>() you can set the data of each item which
should be dragged. If you want to offer the data in additional
mime-types, it's the best to use a class derived from QIconDrag
which implements additional encoding and decoding functions.
<p>Now, when a drag enters the iconview, there is not much todo. Just
connect to the dropped() signal and reimplement
QIconViewItem::dropped() and QIconViewItem::acceptDrop(). The only
special thing in this case is the second argument in the dropped()
signal and in QIconViewItem::dropped(). Fur further details about
that look at the documentation of these signal/method.
<p>For an example implementation of the complex Drag'n'Drop stuff look at the
qfileiconview example (qt/examples/qfileiconview)
<p>Finally, see also <a href="qiconviewitem.html#b9937a">QIconViewItem::setDragEnabled</a>(),
<a href="qiconviewitem.html#015768">QIconViewItem::setDropEnabled</a>(), QIconViewItem::acceptDrop() and
QIconViewItem::dropped()
<p><img src=qiconview-m.png> <img src=qiconview-w.png>
<p>Examples:
 <a href="iconview-main-cpp.html#QIconView">iconview/main.cpp</a>

<hr><h2>Member Type Documentation</h2>
<h3 class="fn"><a name="Arrangement">QIconView::Arrangement</a></h3>
This enum type decides in which direction the items, which do not
fit onto the screen anymore flow.
<p><ul>
<li> <code>LeftToRight</code> - Items, which don't fit onto the view, go further down (you get a vertical scrollbar)
<li> <code>TopToBottom</code> - Items, which don't fit onto the view, go further right (you get a horizontal scrollbar)
</ul>
<h3 class="fn"><a name="ItemTextPos">QIconView::ItemTextPos</a></h3>
This enum type specifies the position of the item text in relation to the icon.
<p><ul>
<li> <code>Bottom</code> - The text is drawn at the bottom of the icon)
<li> <code>Right</code> - The text is drawn at the right of the icon)
</ul>
<h3 class="fn"><a name="ResizeMode">QIconView::ResizeMode</a></h3>
This enum type decides how QIconView should treat the positions of
its icons when the widget is resized.  The currently defined modes
are: <ul>
<li> <code>Fixed</code> - the icons' positions are not changed.
<li> <code>Adjust</code> - the icons' positions are adjusted to be within the
new geometry, if possible.
<p></ul>
<h3 class="fn"><a name="SelectionMode">QIconView::SelectionMode</a></h3>
This enumerated type is used by QIconView to indicate how it reacts
to selection by the user. It has four values: <ul>
<li> <code>Single</code> - When the user selects an item, any already-selected
item becomes unselected, and the user cannot unselect the selected
item. This means that the user can never clear the selection, even
though the selection may be cleared by the application programmer
using <a href="#767612">QIconView::clearSelection</a>().
<li> <code>Multi</code> - When the user selects an item in the most ordinary
way, the selection status of that item is toggled and the other
items are left alone.
<li> <code>Extended</code> - When the user selects an item in the most
ordinary way, the selection is cleared and the new item selected.
However, if the user presses the CTRL key when clicking on an item,
the clicked item gets toggled and all other items are left untouched. And
if the user presses the SHIFT key while clicking on an item, all items
between the current item and the clicked item get selected or unselected
depending on the state of the clicked item.
Also multiple items can be selected by dragging the mouse while the
left mouse button stayes pressed.
<li> <code>NoSelection</code> - Items cannot be selected.
<p></ul>
<p>In other words, <code>Single</code> is a real single-selection iconview, <code>Multi</code> a real multi-selection iconview, and <code>Extended</code> iconview
where users can select multiple items but usually want to select
either just one or a range of contiguous items, and <code>NoSelection</code>
is for a iconview where the user can look but not touch.
<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="a3849b"></a>QIconView::QIconView ( <a href="qwidget.html">QWidget</a> * parent = 0, const char * name = 0, WFlags f = 0 )</h3>
<p>Constructs an empty icon view.
<h3 class="fn"><a name="5872e0"></a>QIconView::~QIconView () <code>[virtual]</code></h3>
<p>Destructs the iconview and deletes all items.
<h3 class="fn">void <a name="c9ca05"></a>QIconView::adjustItems () <code>[virtual protected slot]</code></h3>
<p>Adjusts the positions of the items to the geometry of the iconview.
<h3 class="fn">void <a name="a66b75"></a>QIconView::arrangeItemsInGrid ( bool update = TRUE ) <code>[virtual slot]</code></h3>
<p>Arranges all items in the grid. For the grid the specified
values, given by <a href="#6c95d9">QIconView::setGridX</a>() and <a href="#feb12c">QIconView::setGridY</a>()
are used.
Even if <a href="#b779dd">QIconView::sorting</a>() is enabled, the items are not resorted
in this method. If you want to sort and re-arrange all items, use
iconview-><a href="#7be9a1">sort</a>( iconview-><a href="#4ff476">sortDirection</a>() );
<p>If <em>update</em> is TRUE, the viewport is repainted.
<p>See also  <a href="#6c95d9">QIconView::setGridX</a>(), <a href="#feb12c">QIconView::setGridY</a>() and <a href="#7be9a1">QIconView::sort</a>().
<h3 class="fn">void <a name="9fb7be"></a>QIconView::arrangeItemsInGrid ( const <a href="qsize.html">QSize</a> &amp; grid, bool update = TRUE ) <code>[virtual slot]</code></h3>
<p>Arranges all items in the <em>grid;</em> If the grid is invalid (see
<a href="qsize.html#7336d9">QSize::isValid</a>(), an invalid size is created when using the default
constructor of <a href="qsize.html">QSize</a>()) the best fitting grid is calculated first
and used then.
<p>if <em>update</em> is TRUE, the viewport is repainted.
<h3 class="fn">QIconView::Arrangement <a name="332d1c"></a>QIconView::arrangement() const</h3>
<p>Returns the arrangement mode of the iconview.
<p>See also  <a href="#bf383b">QIconView::setArrangement</a>().
<h3 class="fn">bool <a name="70daef"></a>QIconView::autoArrange () const</h3>
<p>Returns TRUE if all items are re-arranged in the grid if a new one is
inserted, else FALSE.
<p>See also  <a href="#7b3f0b">QIconView::setAutoArrange</a>().
<h3 class="fn">void <a name="f84d65"></a>QIconView::clear () <code>[virtual]</code></h3>
<p>Cleares the iconview.
<h3 class="fn">void <a name="767612"></a>QIconView::clearSelection () <code>[virtual]</code></h3>
<p>Unselects all items.
<h3 class="fn">void <a name="d37c32"></a>QIconView::clicked ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>This signal is emitted when the user clicked (pressed + released) with any mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0).
<h3 class="fn">void <a name="2d5902"></a>QIconView::clicked ( <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qpoint.html">QPoint</a> &amp; pos ) <code>[signal]</code></h3>
<p>This signal is emitted when the user clicked (pressed + released) with any mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0). <em>pos</em> the position of the mouse cursor.
<h3 class="fn">void <a name="876ebb"></a>QIconView::contentsDragEnterEvent ( <a href="qdragenterevent.html">QDragEnterEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="2f492d"></a>QIconView::contentsDragLeaveEvent ( <a href="qdragleaveevent.html">QDragLeaveEvent</a> * ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="57aa92"></a>QIconView::contentsDragMoveEvent ( <a href="qdragmoveevent.html">QDragMoveEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="df152f"></a>QIconView::contentsDropEvent ( <a href="qdropevent.html">QDropEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="c87f21"></a>QIconView::contentsMouseDoubleClickEvent ( <a href="qmouseevent.html">QMouseEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="13f756"></a>QIconView::contentsMouseMoveEvent ( <a href="qmouseevent.html">QMouseEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="ed9722"></a>QIconView::contentsMousePressEvent ( <a href="qmouseevent.html">QMouseEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="ec1fe8"></a>QIconView::contentsMouseReleaseEvent ( <a href="qmouseevent.html">QMouseEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">uint <a name="6bb21a"></a>QIconView::count () const</h3>
<p>Returns the number of items in the iconview.
<h3 class="fn">void <a name="9aaf90"></a>QIconView::currentChanged ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>This signal is emitted, when the different items got current.
<em>item</em> is the new current item or 0, if no item is current now.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a> * <a name="b2a5c7"></a>QIconView::currentItem () const</h3>
<p>Returns a pointer to the current item fo the iconview, or 0, if no
item is current.
<h3 class="fn">void <a name="0fc7d8"></a>QIconView::doAutoScroll () <code>[virtual protected slot]</code></h3>
<p>Does autoscrolling when selecting multiple icons with the rubber band.
<h3 class="fn">void <a name="3fac1f"></a>QIconView::doubleClicked ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>This signal is emitted, if the user double-clicked on the item <em>item.</em>
<h3 class="fn"><a href="qdragobject.html">QDragObject</a> * <a name="8a680b"></a>QIconView::dragObject () <code>[virtual protected]</code></h3>
<p>Returns the <a href="qdragobject.html">QDragObject</a> which should be used for DnD. This method
is called by the iconview when starting a drag to get the dragobject
which should be used for the drag.
Subclasses may reimplement this.
<p>See also  <a href="qicondrag.html">QIconDrag</a>.
<h3 class="fn">void <a name="e825cc"></a>QIconView::drawBackground ( <a href="qpainter.html">QPainter</a> * p, const <a href="qrect.html">QRect</a> &amp; r ) <code>[virtual protected]</code></h3>
<p>This method is called to draw the rectangle <em>r</em> of the background using
the painter <em>p.</em> xOffset and yOffset are known using the methods
<a href="qscrollview.html#be020d">contentsX</a>() and <a href="qscrollview.html#459550">contentsY</a>().
<p>The default implementation only fills <em>r</em> with <a href="qwidget.html#d92bf4">colorGroup</a>().base(). Subclasses
may reimplement this to draw fency backgrounds.
<h3 class="fn">void <a name="2af8c2"></a>QIconView::drawContents ( <a href="qpainter.html">QPainter</a> * p, int cx, int cy, int cw, int ch ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="5708e1"></a>QIconView::drawRubber ( <a href="qpainter.html">QPainter</a> * p ) <code>[virtual protected]</code></h3>
<p>Draws the rubber band using the painter <em>p.</em>
<h3 class="fn">void <a name="b97176"></a>QIconView::dropped ( <a href="qdropevent.html">QDropEvent</a> * e, const <a href="qvaluelist.html">QValueList</a>&lt;<a href="qicondragitem.html">QIconDragItem</a>&gt; &amp; lst ) <code>[signal]</code></h3>
<p>This signal is emitted, when a drop event occurred onto the viewport
(not onto an icon), which the iconview itself can't handle.
<p><em>e</em> gives you all information about the drop. If the drag object of
the drop was a <a href="qicondrag.html">QIconDrag</a>, <em>lst</em> contains the list of the dropped
items. You can get the data using <a href="qicondragitem.html#c00cb9">QIconDragItem::data</a>() of each item
then.
<p>So, if <em>lst</em> is not empty, use this data for further operations,
else the drag was not a QIconDrag, so you have to decode <em>e</em>
yourself and work with that.
<h3 class="fn">void <a name="2206c3"></a>QIconView::emitSelectionChanged ( <a href="qiconviewitem.html">QIconViewItem</a> * i = 0 ) <code>[protected]</code></h3>
<p>Emits signals, that indicate selection changes.
<h3 class="fn">void <a name="76c81f"></a>QIconView::ensureItemVisible ( <a href="qiconviewitem.html">QIconViewItem</a> * item )</h3>
<p>Makes sure, that <em>item</em> is visible, and scrolls the view if required.
<h3 class="fn">void <a name="ce1444"></a>QIconView::enterEvent ( <a href="qevent.html">QEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">bool <a name="a54a67"></a>QIconView::eventFilter ( <a href="qobject.html">QObject</a> * o, <a href="qevent.html">QEvent</a> * e ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Reimplemented from <a href="qobject.html#bd20fe">QObject.</a>
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a>* <a name="4e4ffe"></a>QIconView::findFirstVisibleItem ( const <a href="qrect.html">QRect</a> &amp; r ) const</h3>
<p>Finds the first item which is visible in the rectangle <em>r</em> in contents coordinates. If no items are
visible at all, 0 is returned.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a> * <a name="526763"></a>QIconView::findItem ( const <a href="qpoint.html">QPoint</a> &amp; pos ) const</h3>
<p>Returns a pointer to the item which contains <em>pos,</em> which is given
on contents coordinates.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a> * <a name="ec58f0"></a>QIconView::findItem ( const <a href="qstring.html">QString</a> &amp; text ) const</h3>
<p>Returns a pointer to the first item which could be found that contains
<em>text,</em> or 0 if no such item could be found.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a>* <a name="7d074a"></a>QIconView::findLastVisibleItem ( const <a href="qrect.html">QRect</a> &amp; r ) const</h3>
<p>Finds the last item which is visible in the rectangle <em>r</em> in contents coordinates. If no items are
visible at all, 0 is returned.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a> * <a name="f4df66"></a>QIconView::firstItem () const</h3>
<p>Returns a pointer to the first item fo the iconview, or 0, if there
are no items in the iconview.
<h3 class="fn">void <a name="5f006f"></a>QIconView::focusInEvent ( <a href="qfocusevent.html">QFocusEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="36abfd"></a>QIconView::focusOutEvent ( <a href="qfocusevent.html">QFocusEvent</a> * ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">int <a name="2c5c00"></a>QIconView::gridX () const</h3>
<p>Returns the horizontal grid.
<p>See also  <a href="#6c95d9">QIconView::setGridX</a>().
<h3 class="fn">int <a name="304c4d"></a>QIconView::gridY () const</h3>
<p>Returns the vertica grid.
<p>See also  <a href="#feb12c">QIconView::setGridY</a>().
<h3 class="fn">int <a name="e97fe2"></a>QIconView::index ( const <a href="qiconviewitem.html">QIconViewItem</a> * item ) const</h3>
<p>Returns the index of <em>item</em> or -1 if <em>item</em> doesn't exist
in this icon view.
<h3 class="fn">void <a name="d14416"></a>QIconView::insertInGrid ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[virtual protected]</code></h3>
<p>Inserts an item in the grid of the iconview. You should never need
to call this manually.
<h3 class="fn">void <a name="2d0207"></a>QIconView::insertItem ( <a href="qiconviewitem.html">QIconViewItem</a> * item, <a href="qiconviewitem.html">QIconViewItem</a> * after = 0L ) <code>[virtual]</code></h3>
<p>Inserts the iconview item <em>item</em> after <em>after.</em> If <em>after</em> is 0,
<em>item</em> is appended.
<p>You should never need to call this method yourself, you should rather do
<p><pre>    (void) new <a href="qiconviewitem.html">QIconViewItem</a>( iconview, "This is the text of the item", pixmap );
</pre>
<p>This does everything required for inserting an item.
<h3 class="fn">void <a name="e283c9"></a>QIconView::invertSelection () <code>[virtual]</code></h3>
<p>Inverts the selection. Works only in Multi and Extended selection mode.
<h3 class="fn">void <a name="c5f6fe"></a>QIconView::itemRenamed ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>If the <em>item</em> has been renamed (e.g. by in-place renaming),
this signal is emitted.
<h3 class="fn">void <a name="0b5c7c"></a>QIconView::itemRenamed ( <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qstring.html">QString</a> &amp; name ) <code>[signal]</code></h3>
<p>If the <em>item</em> has been renamed (e.g. by in-place renaming),
this signal is emitted. <em>name</em> is the new text (name) of the item.
<h3 class="fn"><a href="qbrush.html">QBrush</a> <a name="251f1c"></a>QIconView::itemTextBackground () const</h3>
<p>Returns the brush which is used to draw the background of an item text
<p>See also  <a href="#949782">setItemTextBackground</a>().
<h3 class="fn">QIconView::ItemTextPos <a name="429e49"></a>QIconView::itemTextPos() const</h3>
<p>Returns the position, at which the text of the items are drawn.
<p>See also  <a href="#a495e8">QIconView::setItemTextPos</a>().
<h3 class="fn">bool <a name="7aba5f"></a>QIconView::itemsMovable () const</h3>
<p>Returns TRUE, if the user is allowed to move items around
in the iconview, else FALSE;
<p>See also  <a href="#037c84">QIconView::setItemsMovable</a>().
<h3 class="fn">void <a name="c1b24e"></a>QIconView::keyPressEvent ( <a href="qkeyevent.html">QKeyEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a> * <a name="13c5a9"></a>QIconView::lastItem () const</h3>
<p>Returns a pointer to the last item fo the iconview, or 0, if there
are no items in the iconview.
<h3 class="fn"><a href="qiconviewitem.html">QIconViewItem</a> * <a name="c0ef82"></a>QIconView::makeRowLayout ( <a href="qiconviewitem.html">QIconViewItem</a> * begin, int &amp; y ) <code>[protected]</code></h3>
<p>Lays out a row of icons (in <a href="#Arrangement">Arrangement</a> == TopToBottom this is a column). Starts
laying out with the item <em>begin. y</em> is the starting coordinate.
Returns the last item of the row and sets the new starting coordinate to <em>y.</em>
<p>This function may be made private in a future version of Qt. We
recommend not calling it.
<h3 class="fn">int <a name="da54ae"></a>QIconView::maxItemTextLength () const</h3>
<p>Returns the maximum length (in characters), which the
text of an icon may have.
<p>See also  <a href="#ba0e49">QIconView::setMaxItemTextLength</a>().
<h3 class="fn">int <a name="17c372"></a>QIconView::maxItemWidth () const</h3>
<p>Returns the maximum width (in pixels), which an item may have.
<p>See also  <a href="#942024">QIconView::setMaxItemWidth</a>().
<h3 class="fn"><a href="qsize.html">QSize</a> <a name="4789a5"></a>QIconView::minimumSizeHint () const <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Reimplemented from <a href="qwidget.html#553e08">QWidget.</a>
<h3 class="fn">void <a name="7a6311"></a>QIconView::mouseButtonClicked ( int button, <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qpoint.html">QPoint</a> &amp; pos ) <code>[signal]</code></h3>
<p>This signal is emitted when the user clicked (pressed + released) with any mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0). <em>button</em> is the number of the mouse button which
the user clicked, and <em>pos</em> the position of the mouse cursor.
<h3 class="fn">void <a name="15dc22"></a>QIconView::mouseButtonPressed ( int button, <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qpoint.html">QPoint</a> &amp; pos ) <code>[signal]</code></h3>
<p>This signal is emitted when the user pressed with any mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0). <em>button</em> is the number of the mouse button which
the user pressed, and <em>pos</em> the position of the mouse cursor.
<h3 class="fn">void <a name="7d6d77"></a>QIconView::moved () <code>[signal]</code></h3>
<p>This signal is emitted after successfully dropping an (or some) item(s) of the iconview
somewhere and if they should be removed now.
<h3 class="fn">void <a name="21b913"></a>QIconView::onItem ( <a href="qiconviewitem.html">QIconViewItem</a> * i ) <code>[signal]</code></h3>
<p>This signal is emitted, when the user moves the mouse cursor onto an item.
It´s only emitted once per item.
<h3 class="fn">void <a name="608fee"></a>QIconView::onViewport () <code>[signal]</code></h3>
<p>This signal is emitted, when the user moves the mouse cursor, which was
on an item away from the item onto the viewport.
<h3 class="fn">void <a name="9aba48"></a>QIconView::pressed ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>This signal is emitted when the user pressed with any mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0).
<h3 class="fn">void <a name="bf2323"></a>QIconView::pressed ( <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qpoint.html">QPoint</a> &amp; pos ) <code>[signal]</code></h3>
<p>This signal is emitted when the user pressed with any mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0). <em>pos</em> the position of the mouse cursor.
<h3 class="fn">void <a name="65c0ac"></a>QIconView::repaintItem ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[virtual]</code></h3>
<p>Repaints the <em>item.</em>
<h3 class="fn">void <a name="a8aa9e"></a>QIconView::resizeEvent ( <a href="qresizeevent.html">QResizeEvent</a> * e ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">QIconView::ResizeMode <a name="6347ef"></a>QIconView::resizeMode() const</h3>
<p>Returns the resize mode of the iconview.
<p>See also  <a href="#4a1229">QIconView::setResizeMode</a>().
<h3 class="fn">void <a name="0567c1"></a>QIconView::returnPressed ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>This signal is emitted, if the user pressed the return or enter button.
<em>item</em> is the item which was current while return or enter was pressed.
<h3 class="fn">void <a name="ad2630"></a>QIconView::rightButtonClicked ( <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qpoint.html">QPoint</a> &amp; pos ) <code>[signal]</code></h3>
<p>This signal is emitted when the user clicked (pressed + released) with the right
mouse button on either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0). <em>pos</em> the position of the mouse cursor.
<h3 class="fn">void <a name="3fb30b"></a>QIconView::rightButtonPressed ( <a href="qiconviewitem.html">QIconViewItem</a> * item, const <a href="qpoint.html">QPoint</a> &amp; pos ) <code>[signal]</code></h3>
<p>This signal is emitted when the user pressed with the right mouse button on
either and item (then <em>item</em> is the item under the mouse cursor) or
somewhere else (then <em>item</em> is 0). <em>pos</em> the position of the mouse cursor.
<h3 class="fn">void <a name="31b5ce"></a>QIconView::selectAll ( bool select ) <code>[virtual]</code></h3>
<p>If <em>select</em> is TRUE, all items get selected, else all get unselected.
This works only in the selection modes Multi and Extended. In
Single and NoSelection mode the selection of the current item is
just set to <em>select.</em>
<h3 class="fn">void <a name="fac306"></a>QIconView::selectionChanged () <code>[signal]</code></h3>
<p>This signal is emitted when the selection has been changed. It's emitted
in each selection mode.
<h3 class="fn">void <a name="4dcf65"></a>QIconView::selectionChanged ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[signal]</code></h3>
<p>This signal is emitted when the selection has been changed. <em>item</em>
is the new selected item. This signal is only emitted in single
selection mode.
<h3 class="fn">QIconView::SelectionMode <a name="0040a8"></a>QIconView::selectionMode() const</h3>
<p>Returns the selection mode of the iconview.  The initial mode is
<code>Single.</code>
<p>See also  <a href="#98457a">setSelectionMode</a>().
<h3 class="fn">void <a name="bf383b"></a>QIconView::setArrangement ( <a href="qiconview.html#Arrangement">Arrangement</a> am )</h3>
<p>Sets the arrangement mode of the iconview to <em>am,</em> which must be
one of <code>LeftToRight</code> and TopToBottom.
<p>See also  <a href="#Arrangement">Arrangement</a>.
<h3 class="fn">void <a name="7b3f0b"></a>QIconView::setAutoArrange ( bool b ) <code>[virtual]</code></h3>
<p>If <em>b</em> is TRUE, all items are re-arranged in the grid if a new one is
inserted. Else, the best fitting place for the new item is searched and
the other ones are not touched.
<p>This setting only applies if the iconview is visible. If you insert
items and the iconview is not visible, the icons are reordered when it
gets visible.
<h3 class="fn">void <a name="1bf55e"></a>QIconView::setContentsPos ( int x, int y ) <code>[virtual slot]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="b30724"></a>QIconView::setCurrentItem ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[virtual]</code></h3>
<p>Makes <em>item</em> the new current item of the iconview.
<h3 class="fn">void <a name="286880"></a>QIconView::setFont ( const <a href="qfont.html">QFont</a> &amp; f ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="6c95d9"></a>QIconView::setGridX ( int rx ) <code>[virtual]</code></h3>
<p>Sets the horizontal grid to <em>rx.</em>  If <em>rx</em> is -1, there is no
horizontal grid used for arranging items.
<h3 class="fn">void <a name="feb12c"></a>QIconView::setGridY ( int ry ) <code>[virtual]</code></h3>
<p>Sets the vertical grid to <em>ry.</em>  If <em>ry</em> is -1, there is no
vertical grid used for arranging items.
<h3 class="fn">void <a name="949782"></a>QIconView::setItemTextBackground ( const <a href="qbrush.html">QBrush</a> &amp; brush ) <code>[virtual]</code></h3>
<p>Sets the <em>brush,</em> which should be used when drawing the background
of an item text. By default, this brush is set to NoBrush, which means
no extra brush is used for drawing the item text background (just the normal
iconview background).
<h3 class="fn">void <a name="a495e8"></a>QIconView::setItemTextPos ( <a href="qiconview.html#ItemTextPos">ItemTextPos</a> pos )</h3>
<p>Sets the position, where the text of the items is drawn. This can be Bottom
or Right.
<h3 class="fn">void <a name="037c84"></a>QIconView::setItemsMovable ( bool b ) <code>[virtual]</code></h3>
<p>If <em>b</em> is TRUE, the user is allowed to move items around in
the iconview.
if <em>b</em> is FALSE, the user is not allowed to do that.
<h3 class="fn">void <a name="ba0e49"></a>QIconView::setMaxItemTextLength ( int w ) <code>[virtual]</code></h3>
<p>Sets the maximum length (in characters), which an item text may have.
<h3 class="fn">void <a name="942024"></a>QIconView::setMaxItemWidth ( int w ) <code>[virtual]</code></h3>
<p>Sets the maximum width, which an item may have. If a <a href="#2c5c00">gridX</a>() is set,
this value is ignored, and the gridX() value is used.
<h3 class="fn">void <a name="4bc288"></a>QIconView::setPalette ( const <a href="qpalette.html">QPalette</a> &amp; p ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">void <a name="4a1229"></a>QIconView::setResizeMode ( <a href="qiconview.html#ResizeMode">ResizeMode</a> rm )</h3>
<p>Sets the resize mode of the iconview to <em>rm,</em> which must be one of
<code>Fixed</code> and Adjust.
<p>See also  <a href="#ResizeMode">ResizeMode</a>.
<h3 class="fn">void <a name="81719c"></a>QIconView::setSelected ( <a href="qiconviewitem.html">QIconViewItem</a> * item, bool s, bool cb = FALSE ) <code>[virtual]</code></h3>
<p>Selects or unselects <em>item</em> depending on <em>s,</em> and may also
unselect other items, depending on <a href="#0040a8">QIconView::selectionMode</a>() and <em>cb.</em>
<p>If <em>s</em> is FALSE, <em>item</em> is unselected.
<p>If <em>s</em> is TRUE and QIconView::selectionMode() is <code>Single,</code> <em>item</em>
is selected, and the item which was selected is unselected.
<p>If <em>s</em> is TRUE and QIconView::selectionMode() is <code>Extended,</code> <em>item</em> is selected. If <em>cb</em> is TRUE, the other items of the iconview
are not touched. If <em>cb</em> is FALSE (the default) all other items are
unselected.
<p>If <em>s</em> is TRUE and QIconView::selectionMode() is <code>Multi</code> <em>item</em>
is selected.
<p>Note that <em>cb</em> is used only if QIconView::selectionMode() is <code>Extended.</code> <em>cb</em> defaults to FALSE.
<p>All items whose selection status change repaint themselves.
<h3 class="fn">void <a name="98457a"></a>QIconView::setSelectionMode ( <a href="qiconview.html#SelectionMode">SelectionMode</a> m )</h3>
<p>Sets the selection mode of the iconview to <em>m,</em> which may be one of
<code>Single</code> (the default), <code>Extended, Multi</code> or <code>NoSelection.</code>
<p>See also  <a href="#0040a8">selectionMode</a>().
<p>Examples:
 <a href="iconview-main-cpp.html#setSelectionMode">iconview/main.cpp</a>
<h3 class="fn">void <a name="612f32"></a>QIconView::setShowToolTips ( bool b ) <code>[virtual]</code></h3>
<p>If <a href="#644375">wordWrapIconText</a>() is FALSE, it happens that an item text
is truncated because it's too large for one line. If you specify TRUE for
<em>b</em> here and the user moves the mouse onto the item a tooltip with
the whole item text is shown.
If you pass <em>FALSE</em> here this feature is switched off.
<p>See also  <a href="#dbeaa6">setWordWrapIconText</a>().
<h3 class="fn">void <a name="540892"></a>QIconView::setSorting ( bool sort, bool ascending = TRUE )</h3>
<p>If <em>sort</em> is TRUE, new items are inserted sorted. The sort
direction is specified using <em>ascending.</em>
<p>Inserting items sorted only works when re-arranging items is
set to TRUE as well (using <a href="#7b3f0b">QIconView::setAutoArrange</a>()).
<p>See also  <a href="#7b3f0b">QIconView::setAutoArrange</a>() and <a href="#70daef">QIconView::autoArrange</a>().
<h3 class="fn">void <a name="f39ce3"></a>QIconView::setSpacing ( int sp ) <code>[virtual]</code></h3>
<p>Sets the space between iconview items to <em>sp.</em>
<h3 class="fn">void <a name="dbeaa6"></a>QIconView::setWordWrapIconText ( bool b ) <code>[virtual]</code></h3>
<p>If the width of an item text is larger than the maximal item width,
there are two possibilities how the QIconView can deal with this.
Either it does a word wrap of the item text, so that it uses
multiple lines. Or it truncates the item text so that it shrinks
to the maximal item width and appends three dots "..." to the
displayed text to indicate that not the full text is displayed.
<p>If you set <em>b</em> to TRUE, a word wrap is done, else the
text is displayed truncated.
<p>NOTE: Both possibilities just change the way how the text is
displayed, they do NOT modify the item text itslef.
<p>See also  <a href="#612f32">setShowToolTips</a>().
<h3 class="fn">void <a name="9b31e9"></a>QIconView::showEvent ( <a href="qshowevent.html">QShowEvent</a> * ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<h3 class="fn">bool <a name="355480"></a>QIconView::showToolTips () const</h3>
<p>Returns TRUE if a tooltip is shown for truncated item texts and
FALSE otherwise.
<p>See also  <a href="#612f32">setShowToolTips</a>() and <a href="#dbeaa6">setWordWrapIconText</a>().
<h3 class="fn"><a href="qsize.html">QSize</a> <a name="157488"></a>QIconView::sizeHint () const <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Examples:
 <a href="iconview-main-cpp.html#sizeHint">iconview/main.cpp</a>
<p>Reimplemented from <a href="qwidget.html#4511d1">QWidget.</a>
<h3 class="fn"><a href="qsizepolicy.html">QSizePolicy</a> <a name="9a6404"></a>QIconView::sizePolicy () const <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Reimplemented from <a href="qwidget.html#23726d">QWidget.</a>
<h3 class="fn">void <a name="0a8823"></a>QIconView::slotUpdate () <code>[virtual protected slot]</code></h3>
<p>Because of efficiency, the iconview is not redrawn immediately after
inserting a new item, but with a very small delay using a <a href="qtimer.html">QTimer</a>. The
result of this is, that if lots of items are inserted in a short time
(e.g. in a loop), the iconview is not redrawn after each inserted item,
but after inserting all of them, which makes the operation much faster
and flicker-free.
<h3 class="fn">void <a name="7be9a1"></a>QIconView::sort ( bool ascending = TRUE ) <code>[virtual]</code></h3>
<p>Sorts the items of the listview and re-arranges them afterwards. If
<em>ascending</em> is TRUE, the items are sorted in increasing order, else
in decreasing order. For sorting <a href="qiconviewitem.html#d3dc25">QIconViewItem::compare</a>() is used.
The default sort direction is set to the sort direction you set
here.
<p>See also  <a href="qiconviewitem.html#f40531">QIconViewItem::key</a>(), <a href="qiconviewitem.html#4782f9">QIconViewItem::setKey</a>(), <a href="qiconviewitem.html#d3dc25">QIconViewItem::compare</a>(), <a href="#540892">QIconView::setSorting</a>() and <a href="#4ff476">QIconView::sortDirection</a>().
<h3 class="fn">bool <a name="4ff476"></a>QIconView::sortDirection () const</h3>
<p>Returns TRUE if the sort direction for inserting new items is ascending,
FALSE means descending. This sort direction has only a meaning if re-sorting
and re-arranging of new inserted items is enabled.
<p>See also  <a href="#540892">QIconView::setSorting</a>() and <a href="#7b3f0b">QIconView::setAutoArrange</a>().
<h3 class="fn">bool <a name="b779dd"></a>QIconView::sorting () const</h3>
<p>Returns TRUE if new items are inserted sorted, else FALSE.
<p>See also  <a href="#540892">QIconView::setSorting</a>().
<h3 class="fn">int <a name="2f08d8"></a>QIconView::spacing () const</h3>
<p>Returns the spacing between iconview items.
<h3 class="fn">void <a name="9918ce"></a>QIconView::startDrag () <code>[virtual protected]</code></h3>
<p>Starts a drag.
<h3 class="fn">void <a name="26f923"></a>QIconView::styleChange ( <a href="qstyle.html">QStyle</a> &amp; old ) <code>[virtual protected]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Reimplemented from <a href="qwidget.html#5e2e23">QWidget.</a>
<h3 class="fn">void <a name="7164b3"></a>QIconView::takeItem ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[virtual]</code></h3>
<p>Takes the iconview item <em>item</em> out of the iconview and causes an update
of the screen display.  The item is not deleted.  You should normally not
need to call this function, as QIconViewItem::~<a href="qiconviewitem.html">QIconViewItem</a>() calls it.
The normal way to delete an item is <code>delete.</code>
<h3 class="fn">bool <a name="644375"></a>QIconView::wordWrapIconText () const</h3>
<p>Returns TRUE, if an item text which needs too much
space (to the width) is displayed word wrapped, or FALSE
if it gets displayed truncated.
<p>See also  <a href="#dbeaa6">setWordWrapIconText</a>() and <a href="#612f32">setShowToolTips</a>().
<h3 class="fn">void <a name="48df15"></a>QIconView::emitRenamed ( <a href="qiconviewitem.html">QIconViewItem</a> * item ) <code>[protected]</code></h3>
<p>For internal use only.
<h3 class="fn">void <a name="b1714a"></a>QIconView::updateContents () <code>[virtual slot]</code></h3>
<p>For internal use only.
<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses
<a href="http://www.trolltech.com">www.trolltech.com</a>):<br>
<form method=post action="http://www.trolltech.com/search.cgi">
<input type=hidden name="version" value="2.3.2"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-2001
<a href="http://www.trolltech.com">Trolltech</a>, all rights reserved.<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2001 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.2</div>
</table></div></address></body></html>
