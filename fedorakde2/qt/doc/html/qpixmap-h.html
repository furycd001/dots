<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
Qt Toolkit - qpixmap.h include file
</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>qpixmap.h</h1><br clear="all">
This is the verbatim text of the qpixmap.h include file.  It is
provided only for illustration; the copyright
remains with Trolltech.
<hr>
<pre>
/****************************************************************************
** &#36;Id&#58; qt/src/kernel/qpixmap.h   2.3.2   edited 2001-06-22 $
**
** Definition of QPixmap class
**
** Created : 940501
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the kernel module of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

#ifndef QPIXMAP_H
#define QPIXMAP_H

#ifndef QT_H
#include "qpaintdevice.h"
#include "qcolor.h"
#include "qstring.h"
#include "qnamespace.h"
#endif // QT_H

class QGfx;

#if defined(_WS_WIN_)
// Internal pixmap memory optimization class for Windows 9x
class QMultiCellPixmap;
#endif


class Q_EXPORT <a href="qpixmap.html">QPixmap</a> : public <a href="qpaintdevice.html">QPaintDevice</a>, public <a href="qt.html">Qt</a>
{
public:
    enum ColorMode { Auto, Color, Mono };
    enum Optimization { DefaultOptim, NoOptim, MemoryOptim=NoOptim,
                        NormalOptim, BestOptim };

    QPixmap();
    QPixmap( int w, int h,  int depth = -1, Optimization = DefaultOptim );
    QPixmap( const QSize &amp;, int depth = -1, Optimization = DefaultOptim );
    QPixmap( const QString&amp; fileName, const char *format=0,
             ColorMode mode=Auto );
    QPixmap( const QString&amp; fileName, const char *format,
             int conversion_flags );
    QPixmap( const char *xpm[] );
    QPixmap( const QByteArray &amp;data );
    QPixmap( const QPixmap &amp; );
   ~QPixmap();

    QPixmap    &amp;operator=( const QPixmap &amp; );
    QPixmap    &amp;operator=( const QImage  &amp; );

    bool        isNull()        const;

    int         width()         const { return data-&gt;w; }
    int         height()        const { return data-&gt;h; }
    QSize       size()          const { return QSize(data-&gt;w,data-&gt;h); }
    QRect       rect()          const { return QRect(0,0,data-&gt;w,data-&gt;h); }
    int         depth()         const { return data-&gt;d; }
    static int  defaultDepth();

    void        fill( const QColor &amp;fillColor = Qt::white );
    void        fill( const QWidget *, int xofs, int yofs );
    void        fill( const QWidget *, const QPoint &amp;ofs );
    void        resize( int width, int height );
    void        resize( const QSize &amp; );

    const QBitmap *mask() const;
    void        setMask( const QBitmap &amp; );
    bool        selfMask() const;
    QBitmap     createHeuristicMask( bool clipTight = TRUE ) const;

    static  QPixmap grabWindow( WId, int x=0, int y=0, int w=-1, int h=-1 );
    static  QPixmap grabWidget( QWidget * widget,
                                int x=0, int y=0, int w=-1, int h=-1 );

#ifndef QT_NO_PIXMAP_TRANSFORMATION
    QPixmap         xForm( const QWMatrix &amp; ) const;
#endif
#ifndef QT_NO_WMATRIX
    static QWMatrix trueMatrix( const QWMatrix &amp;, int w, int h );
#endif

    QImage      convertToImage() const;
    bool        convertFromImage( const QImage &amp;, ColorMode mode=Auto );
    bool        convertFromImage( const QImage &amp;, int conversion_flags );

    static const char* imageFormat( const QString &amp;fileName );
    bool        load( const QString&amp; fileName, const char *format=0,
                      ColorMode mode=Auto );
    bool        load( const QString&amp; fileName, const char *format,
                      int conversion_flags );
    bool        loadFromData( const uchar *buf, uint len,
                              const char* format=0,
                              ColorMode mode=Auto );
    bool        loadFromData( const uchar *buf, uint len,
                              const char* format,
                              int conversion_flags );
    bool        loadFromData( const QByteArray &amp;data,
                              const char* format=0,
                              int conversion_flags=0 );
    bool        save( const QString&amp; fileName, const char* format ) const; // ### remove 3.0
    bool        save( const QString&amp; fileName, const char* format,
                      int quality ) const; // ### change to quality=-1 in 3.0

#if defined(_WS_WIN_)
    HBITMAP     hbm()           const;
#endif

    int         serialNumber()  const;

    Optimization        optimization() const;
    void                setOptimization( Optimization );
    static Optimization defaultOptimization();
    static void         setDefaultOptimization( Optimization );

    virtual void detach();

    bool        isQBitmap() const;

#if defined(_WS_WIN_)
    // These functions are internal and used by Windows 9x only
    bool        isMultiCellPixmap() const;
    HDC         multiCellHandle() const;
    HBITMAP     multiCellBitmap() const;
    int         multiCellOffset() const;
    int         allocCell();
    void        freeCell( bool = FALSE );
#endif

#if defined(_WS_QWS_)
    virtual QGfx * graphicsContext(bool clip_children=TRUE) const;
    virtual unsigned char * scanLine(int) const;
    virtual int bytesPerLine() const;
    QRgb * clut() const;
    int numCols() const;
#endif

#if defined(Q_FULL_TEMPLATE_INSTANTIATION)
    bool operator==( const QPixmap&amp; ) const { return FALSE; }
#endif

protected:
    QPixmap( int w, int h, const uchar *data, bool isXbitmap );
    int metric( int ) const;

#if defined(_WS_WIN_)
    struct QMCPI {                              // mem optim for win9x
        QMultiCellPixmap *mcp;
        int     offset;
    };
#endif

    struct QPixmapData : public QShared {       // internal pixmap data
        QCOORD  w, h;
        short   d;
        uint    uninit   : 1;
        uint    bitmap   : 1;
        uint    selfmask : 1;
#if defined(_WS_WIN_)
        uint    mcp      : 1;
#endif
        int     ser_no;
        QBitmap *mask;
#if defined(_WS_WIN_)
        void   *bits;
        QPixmap *maskpm;
        union {
            HBITMAP hbm;    // if mcp == FALSE
            QMCPI  *mcpi;   // if mcp == TRUE
        } hbm_or_mcpi;
#elif defined(_WS_X11_)
        void   *ximage;
        void   *maskgc;
#elif defined(_WS_QWS_)
        int id; // ### should use QPaintDevice::hd, since it is there
        QRgb * clut;
        int numcols;
        int rw;
        int rh;
        bool hasAlpha;
#endif
        Optimization optim;
    } *data;

private:
    QPixmap( int w, int h, int depth, bool, Optimization );
    void        init( int, int, int, bool, Optimization );
    void        deref();
    QPixmap     copy( bool ignoreMask = FALSE ) const;
    static Optimization defOptim;
    friend Q_EXPORT void bitBlt( QPaintDevice *, int, int,
                                 const QPaintDevice *,
                                 int, int, int, int, RasterOp, bool );
    friend Q_EXPORT void bitBlt( QPaintDevice *, int, int,
                                 const QImage* src,
                                 int, int, int, int, int conversion_flags );
    friend class QBitmap;
    friend class QPaintDevice;
    friend class QPainter;
};


inline bool QPixmap::isNull() const
{
    return data-&gt;w == 0;
}

inline void QPixmap::fill( const QWidget *w, const QPoint &amp;ofs )
{
    fill( w, ofs.x(), ofs.y() );
}

inline void QPixmap::resize( const QSize &amp;s )
{
    resize( s.width(), s.height() );
}

inline const QBitmap *QPixmap::mask() const
{
    return data-&gt;mask;
}

inline bool QPixmap::selfMask() const
{
    return data-&gt;selfmask;
}

#if defined(_WS_WIN_)
inline HBITMAP QPixmap::hbm() const
{
    return data-&gt;mcp ? 0 : data-&gt;hbm_or_mcpi.hbm;
}
#endif

inline int QPixmap::serialNumber() const
{
    return data-&gt;ser_no;
}

inline QPixmap::Optimization QPixmap::optimization() const
{
    return data-&gt;optim;
}

inline bool QPixmap::isQBitmap() const
{
    return data-&gt;bitmap;
}

#if defined(_WS_WIN_)
inline bool QPixmap::isMultiCellPixmap() const
{
    return data-&gt;mcp;
}
#endif


/*****************************************************************************
  QPixmap stream functions
 *****************************************************************************/

#ifndef QT_NO_DATASTREAM
Q_EXPORT QDataStream &amp;operator&lt;&lt;( QDataStream &amp;, const QPixmap &amp; );
Q_EXPORT QDataStream &amp;operator&gt;&gt;( QDataStream &amp;, QPixmap &amp; );
#endif

#endif // QPIXMAP_H

</pre>
<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2001 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.2</div>
</table></div></address></body></html>
