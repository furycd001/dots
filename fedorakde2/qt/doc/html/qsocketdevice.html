<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qt Toolkit - QSocketDevice Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>QSocketDevice Class Reference<br><small>[ <a href="network.html">network module</a> ]</small></h1><br clear="all">
<p>
The QSocketDevice class provides a platform-independent low-level socket API.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qsocketdevice-h.html">qsocketdevice.h</a>&gt;</code>
<p>
Inherits <a href="qiodevice.html">QIODevice</a>.
<p><a href="qsocketdevice-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class="fn">enum <a href="#Type"><b>Type</b></a> { Stream, Datagram }</div>
<li><div class="fn"><a href="#f7e4fb"><b>QSocketDevice</b></a> ( Type type = Stream ) </div>
<li><div class="fn"><a href="#39af37"><b>QSocketDevice</b></a> ( int socket, Type type ) </div>
<li><div class="fn">virtual <a href="#9f301b"><b>~QSocketDevice</b></a> () </div>
<li><div class="fn">bool <a href="#cc2024"><b>isValid</b></a> () const</div>
<li><div class="fn">Type <a href="#e08294"><b>type</b></a> () const</div>
<li><div class="fn">int <a href="#67ea7b"><b>socket</b></a> () const</div>
<li><div class="fn">virtual void <a href="#23c0f7"><b>setSocket</b></a> ( int socket, Type type ) </div>
<li><div class="fn">bool <a href="#e073ae"><b>blocking</b></a> () const</div>
<li><div class="fn">virtual void <a href="#9660f4"><b>setBlocking</b></a> ( bool ) </div>
<li><div class="fn">bool <a href="#4a6e01"><b>addressReusable</b></a> () const</div>
<li><div class="fn">virtual void <a href="#30e1dc"><b>setAddressReusable</b></a> ( bool ) </div>
<li><div class="fn">int <a href="#c8d8a5"><b>receiveBufferSize</b></a> () const</div>
<li><div class="fn">virtual void <a href="#c63fb9"><b>setReceiveBufferSize</b></a> ( uint ) </div>
<li><div class="fn">int <a href="#1cc0c3"><b>sendBufferSize</b></a> () const</div>
<li><div class="fn">virtual void <a href="#5b9541"><b>setSendBufferSize</b></a> ( uint ) </div>
<li><div class="fn">virtual bool <a href="#b17573"><b>connect</b></a> ( const QHostAddress &amp;, Q_UINT16 ) </div>
<li><div class="fn">virtual bool <a href="#15d70b"><b>bind</b></a> ( const QHostAddress &amp;, Q_UINT16 ) </div>
<li><div class="fn">virtual bool <a href="#a37b85"><b>listen</b></a> ( int backlog ) </div>
<li><div class="fn">virtual int <a href="#8cb9cd"><b>accept</b></a> () </div>
<li><div class="fn">int <a href="#318632"><b>bytesAvailable</b></a> () const</div>
<li><div class="fn">int <a href="#2baa28"><b>waitForMore</b></a> ( int msecs ) const</div>
<li><div class="fn">virtual int <a href="#f51391"><b>readBlock</b></a> ( char * data, uint maxlen ) </div>
<li><div class="fn">virtual int <a href="#61dc32"><b>writeBlock</b></a> ( const char * data, uint len ) </div>
<li><div class="fn">virtual int <a href="#a6eec8"><b>writeBlock</b></a> ( const char * data, uint len, const QHostAddress &amp; host, Q_UINT16 port ) </div>
<li><div class="fn">Q_UINT16 <a href="#07f655"><b>port</b></a> () const</div>
<li><div class="fn">Q_UINT16 <a href="#3e121a"><b>peerPort</b></a> () const</div>
<li><div class="fn">QHostAddress <a href="#ef3dd3"><b>address</b></a> () const</div>
<li><div class="fn">QHostAddress <a href="#a11b1c"><b>peerAddress</b></a> () const</div>
<li><div class="fn">enum <a href="#Error"><b>Error</b></a> { NoError, AlreadyBound, Inaccessible, NoResources, Bug, Impossible, NoFiles, ConnectionRefused, NetworkFailure, UnknownError }</div>
<li><div class="fn">Error <a href="#b717ef"><b>error</b></a> () const</div>
</ul>
<h2>Protected Members</h2>
<ul>
<li><div class="fn">void <a href="#a1e477"><b>setError</b></a> ( Error err ) </div>
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QSocketDevice class provides a platform-independent low-level socket API.
<p>
This class is not really meant for use outside Qt.  It can be used
to achieve some things that <a href="qsocket.html">QSocket</a> does not provide, but it's
not particularly easy to understand or use.
<p>The basic purpose of the class is to provide a <a href="qiodevice.html">QIODevice</a> that works
on sockets, wrapped in a platform-independent API.
<p>See also  <a href="qsocket.html">QSocket</a>, <a href="qsocketnotifier.html">QSocketNotifier</a> and <a href="qhostaddress.html">QHostAddress</a>.

<hr><h2>Member Type Documentation</h2>
<h3 class="fn"><a name="Error">QSocketDevice::Error</a></h3>
This enum type describes the error states of QSocketDevice.  At present these
errors are defined:
<p><ul>
<li> <code>NoError</code> - all is fine.
<li> <code>AlreadyBound</code> - <a href="#15d70b">bind</a>() said so.
<li> <code>Inaccessible</code> - the operating system or firewall prohibits something.
<li> <code>NoResources</code> - the operating system ran out of something.
<li> <code>Bug</code> - there seems to be a bug in QSocketDevice.
<li> <code>Impossible</code> - the impossible happened, usually because you confused
QSocketDevice horribly.  Simple example:
<pre>  ::close( sd-&gt;socket() );
  sd-&gt;writeBlock( someData, 42 );
</pre>
<p>The libc ::<a href="#dfe8ce">close</a>() closes the socket, but QSocketDevice is not aware
of that.  So when you call <a href="#61dc32">writeBlock</a>(), the impossible happens.
<li> <code>NoFiles</code> - the operating system will not let QSocketDevice open
another file.
<li> <code>ConnectionRefused</code> - a connection attempt was rejected by the
peer.
<li> <code>NetworkFailure</code> - there is a network failure between this host
and... and whatever.
<li> <code>UnknownError</code> - the operating system reacted in a way that the
Qt developers did not foresee.
</ul>
<h3 class="fn"><a name="Type">QSocketDevice::Type</a></h3>
This enum type describes the type of the socket:
<ul>
<li> <code>Stream</code> - a stream socket
<li> <code>Datagram</code> - a datagram socket
</ul>
<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="f7e4fb"></a>QSocketDevice::QSocketDevice ( <a href="qsocketdevice.html#Type">Type</a> type = Stream )</h3>
<p>Creates a QSocketDevice object for a stream or datagram socket.
<p>The <em>type</em> argument must be either <code>QSocketDevice::Stream</code> for a
reliable, connection-oriented TCP socket, or <code>QSocketDevice::Datagram</code> for an unreliable UDP socket.
<p>See also  <a href="#e073ae">blocking</a>().
<h3 class="fn"><a name="39af37"></a>QSocketDevice::QSocketDevice ( int socket, <a href="qsocketdevice.html#Type">Type</a> type )</h3>
<p>Creates a QSocketDevice object for an existing socket.
<p>The <em>type</em> argument must match the actual socket type;
<code>QSocketDevice::Stream</code> for a reliable, connection-oriented TCP socket, or
<code>QSocketDevice::Datagram</code> for an unreliable, connectionless UDP socket.
<h3 class="fn"><a name="9f301b"></a>QSocketDevice::~QSocketDevice () <code>[virtual]</code></h3>
<p>Destroys the socket device and closes the socket if it is open.
<h3 class="fn">int <a name="8cb9cd"></a>QSocketDevice::accept () <code>[virtual]</code></h3>
<p>Extracts the first connection from the queue of pending connections
for this socket and returns a new socket identifier.  Returns -1
if the operation failed.
<p>See also  <a href="#15d70b">bind</a>() and <a href="#a37b85">listen</a>().
<h3 class="fn"><a href="qhostaddress.html">QHostAddress</a> <a name="ef3dd3"></a>QSocketDevice::address () const</h3>
<p>Returns the address of this socket device.  This may be 0.0.0.0 for a while,
but is set to something sensible when there is a sensible value it can have.
<h3 class="fn">bool <a name="4a6e01"></a>QSocketDevice::addressReusable () const</h3>
<p>Returns TRUE if the address of this socket can be used by other
sockets at the same time, and FALSE if this socket claims exclusive
ownership.
<p>See also  <a href="#30e1dc">setAddressReusable</a>().
<h3 class="fn">bool <a name="aaa87c"></a>QSocketDevice::at ( int ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>The read/write index is meaningless for a socket, therefore
this function does nothing and returns TRUE.
<p>Reimplemented from <a href="qiodevice.html#90fb01">QIODevice.</a>
<h3 class="fn">int <a name="00088b"></a>QSocketDevice::at () const <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>The read/write index is meaningless for a socket, therefore
this function returns 0.
<p>Reimplemented from <a href="qiodevice.html#a8b90e">QIODevice.</a>
<h3 class="fn">bool <a name="394a25"></a>QSocketDevice::atEnd () const <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>The read/write index is meaningless for a socket, therefore
this always returns FALSE.
<p>Reimplemented from <a href="qiodevice.html#d51a01">QIODevice.</a>
<h3 class="fn">bool <a name="15d70b"></a>QSocketDevice::bind ( const <a href="qhostaddress.html">QHostAddress</a> &amp; address, Q_UINT16 port ) <code>[virtual]</code></h3>
<p>Assigns a name to an unnamed socket.  If the operation succeeds,
bind() returns TRUE.  Otherwise, it returns FALSE without changing
what <a href="#07f655">port</a>() and <a href="#ef3dd3">address</a>() return.
<p>bind() is used by servers for setting up incoming connections.
Call bind() before <a href="#a37b85">listen</a>().
<h3 class="fn">bool <a name="e073ae"></a>QSocketDevice::blocking () const</h3>
<p>Returns TRUE if the socket is in blocking mode, or FALSE if it
is in nonblocking mode or if the socket is invalid.
<p>Note that this function does not set <a href="#b717ef">error</a>().<p><b>Warning:</b> On Windows, this function always returns TRUE since the
ioctlsocket() function is broken.
<p>See also  <a href="#9660f4">setBlocking</a>() and <a href="#cc2024">isValid</a>().
<h3 class="fn">int <a name="318632"></a>QSocketDevice::bytesAvailable () const</h3>
<p>Returns the number of bytes available for reading, or -1 if an
error occurred.<p><b>Warning:</b> On Microsoft Windows, we use the ioctlsocket() function
to determine the number of bytes queued on the socket.
According to Microsoft (KB Q125486), ioctlsocket() sometimes
return an incorrect number.  The only safe way to determine the
amount of data on the socket is to read it using <a href="#f51391">readBlock</a>().
<a href="qsocket.html">QSocket</a> has workarounds to deal with this problem.
<h3 class="fn">void <a name="dfe8ce"></a>QSocketDevice::close () <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Closes the socket and sets the socket identifier to -1 (invalid).
<p>(This function ignores errors; if there are any then a file
descriptor leakage might result.  As far as we know, the only error
that can arise is EBADF, and that would of course not cause leakage.
There may be OS-specfic errors that we haven't come across,
however.)
<p>See also  <a href="#32c3be">open</a>().
<p>Reimplemented from <a href="qiodevice.html#50fcfd">QIODevice.</a>
<h3 class="fn">bool <a name="b17573"></a>QSocketDevice::connect ( const <a href="qhostaddress.html">QHostAddress</a> &amp; addr, Q_UINT16 port ) <code>[virtual]</code></h3>
<p>Connects to the IP address and port specified by <em>addr.</em>  Returns
TRUE if it establishes a connection, and FALSE if not.  <a href="#b717ef">error</a>()
explains why.
<p>Note that error() commonly returns NoError for non-blocking sockets;
this just means that you can call connect() again in a little while
and it'll probably succeed.
<h3 class="fn">QSocketDevice::Error <a name="b717ef"></a>QSocketDevice::error() const</h3>
<p>Returns the first error seen.
<h3 class="fn">void <a name="951a6c"></a>QSocketDevice::flush () <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>QSocketDevice does not buffer at all, so this is a no-op.
<p>Reimplemented from <a href="qiodevice.html#dfd9f0">QIODevice.</a>
<h3 class="fn">int <a name="6bb6e4"></a>QSocketDevice::getch () <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.<p><b>Warning:</b> getch() is implemented as a one-byte <a href="#f51391">readBlock</a>(), so it
may be very slow if you call it more than a few times.
<p>See also  <a href="#89d3fd">putch</a>() and <a href="#f51391">readBlock</a>().
<p>Reimplemented from <a href="qiodevice.html#09409b">QIODevice.</a>
<h3 class="fn">bool <a name="cc2024"></a>QSocketDevice::isValid () const</h3>
<p>Returns TRUE if this is a valid socket or FALSE if it is an invalid
socket.  This is actually a shortcut for <a href="#67ea7b">socket</a>() == -1.
<p>See also  <a href="#67ea7b">socket</a>().
<h3 class="fn">bool <a name="a37b85"></a>QSocketDevice::listen ( int backlog ) <code>[virtual]</code></h3>
<p>Specifies how many pending connections a server socket can have.
Returns TRUE if the operation was successful, otherwise FALSE.
<p>The listen() call only applies to sockets where <a href="#e08294">type</a>() is <code>Stream,</code>
not <code>Datagram</code> sockets.  listen() must not be called before <a href="#15d70b">bind</a>()
or after <a href="#8cb9cd">accept</a>().  It is common to use a <em>backlog</em> value of 50 on
most Unix systems.
<p>See also  <a href="#15d70b">bind</a>() and <a href="#8cb9cd">accept</a>().
<h3 class="fn">bool <a name="32c3be"></a>QSocketDevice::open ( int mode ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>Opens the socket using the specified <a href="qiodevice.html">QIODevice</a> file <em>mode.</em>  This function
is called from the QSocketDevice constructors and from the <a href="#23c0f7">setSocket</a>()
function.  You should not call it yourself.
<p>See also  <a href="#dfe8ce">close</a>().
<p>Reimplemented from <a href="qiodevice.html#756b18">QIODevice.</a>
<h3 class="fn"><a href="qhostaddress.html">QHostAddress</a> <a name="a11b1c"></a>QSocketDevice::peerAddress () const</h3>
<p>Returns the address of the port this socket device is connected to. This may
be 0.0.0.0 for a while, but is set to something sensible when there is a
sensible value it can have.
<p>Note that for Datagram sockets, this is the source address of the last packet
received.
<h3 class="fn">Q_UINT16 <a name="3e121a"></a>QSocketDevice::peerPort () const</h3>
<p>Returns the port number of the port this socket device is connected to. This
may be 0 for a while, but is set to something sensible when there is a
sensible value it can have.
<p>Note that for Datagram sockets, this is the source port of the last packet
received.
<h3 class="fn">Q_UINT16 <a name="07f655"></a>QSocketDevice::port () const</h3>
<p>Returns the port number of this socket device. This may be 0 for a while,
but is set to something sensible when there is a sensible value it can have.
<h3 class="fn">int <a name="89d3fd"></a>QSocketDevice::putch ( int ch ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.<p><b>Warning:</b> putch() is implemented as a one-byte <a href="#61dc32">writeBlock</a>(), so it
may be very slow if you call it more than a few times.
<p>See also  <a href="#6bb6e4">getch</a>().
<p>Reimplemented from <a href="qiodevice.html#71cd12">QIODevice.</a>
<h3 class="fn">int <a name="f51391"></a>QSocketDevice::readBlock ( char * data, uint maxlen ) <code>[virtual]</code></h3>
<p>Reads max <em>maxlen</em> bytes from the socket into <em>data</em> and returns
the number of bytes read.  Returns -1 if an error occurred.
<p>Reimplemented from <a href="qiodevice.html#c12e6e">QIODevice.</a>
<h3 class="fn">int <a name="c8d8a5"></a>QSocketDevice::receiveBufferSize () const</h3>
<p>Returns the size of the OS receive buffer.
<p>See also  <a href="#c63fb9">setReceiveBufferSize</a>().
<h3 class="fn">int <a name="1cc0c3"></a>QSocketDevice::sendBufferSize () const</h3>
<p>Returns the size of the OS send buffer.
<p>See also  <a href="#5b9541">setSendBufferSize</a>().
<h3 class="fn">void <a name="30e1dc"></a>QSocketDevice::setAddressReusable ( bool enable ) <code>[virtual]</code></h3>
<p>Sets the address of this socket to be usable by other sockets too
if <em>enable</em> is TRUE, and to be used exclusively by this socket if
<em>enable</em> is FALSE.
<p>When a socket is reusable, other sockets can use the same port
number (and IP address), which is in general good.  Of course other
sockets cannot use the same (address,port,peer-address,peer-port)
4-tuple as this socket, so there is no risk of confusing the two TCP
connections.
<p>See also  <a href="#4a6e01">addressReusable</a>().
<h3 class="fn">void <a name="9660f4"></a>QSocketDevice::setBlocking ( bool enable ) <code>[virtual]</code></h3>
<p>Makes the socket blocking if <em>enable</em> is TRUE or nonblocking if
<em>enable</em> is FALSE.
<p>Sockets are blocking by default, but we recommend using
nonblocking socket operations, especially for GUI programs that need
to be responsive.<p><b>Warning:</b> On Windows, this function does nothing since the
ioctlsocket() function is broken.
<p>Whenever you use a <a href="qsocketnotifier.html">QSocketNotifier</a> on Windows, the socket is immediately
made nonblocking.
<p>See also  <a href="#e073ae">blocking</a>() and <a href="#cc2024">isValid</a>().
<h3 class="fn">void <a name="a1e477"></a>QSocketDevice::setError ( <a href="qsocketdevice.html#Error">Error</a> err ) <code>[protected]</code></h3>
<p>Allows subclasses to set the error state.
<h3 class="fn">void <a name="c63fb9"></a>QSocketDevice::setReceiveBufferSize ( uint size ) <code>[virtual]</code></h3>
<p>Sets the size of the OS receive buffer to <em>size.</em>
<p>The OS receive buffer size effectively limits two things: How much
data can be in transit at any one moment, and how much data can be
received in one iteration of the main event loop.
<p>The default is OS-dependent.  A socket that receives large amounts
of data is probably best off with a buffer size of 49152.
<h3 class="fn">void <a name="5b9541"></a>QSocketDevice::setSendBufferSize ( uint size ) <code>[virtual]</code></h3>
<p>Sets the size of the OS send buffer to <em>size.</em>
<p>The OS send buffer size effectively limits how much data can be in
transit at any one moment.
<p>The default is OS-dependent.  A socket that sends large amounts of
data is probably best off with a buffer size of 49152.
<h3 class="fn">void <a name="23c0f7"></a>QSocketDevice::setSocket ( int socket, <a href="qsocketdevice.html#Type">Type</a> type )</h3>
<p>Sets an existing socket.
<p>The <em>type</em> argument must match the actual socket type;
<code>QSocketDevice::Stream</code> for a reliable, connection-oriented TCP socket, or
<code>QSocketDevice::Datagram</code> for an unreliable, connectionless UDP socket.
<p>Any existing socket is closed.
<p>See also  <a href="#cc2024">isValid</a>() and <a href="#dfe8ce">close</a>().
<h3 class="fn">uint <a name="a126c7"></a>QSocketDevice::size () const <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>The size is meaningless for a socket, therefore this function returns 0.
<p>Reimplemented from <a href="qiodevice.html#8ddedd">QIODevice.</a>
<h3 class="fn">int <a name="67ea7b"></a>QSocketDevice::socket () const</h3>
<p>Returns the socket number, or -1 if it is an invalid socket.
<p>See also  <a href="#cc2024">isValid</a>() and <a href="#e08294">type</a>().
<h3 class="fn"><a href="qsocketdevice.html#Type">Type</a> <a name="e08294"></a>QSocketDevice::type () const</h3>
<p>Returns the socket type; <code>QSocketDevice::Stream</code> for a reliable,
connection-oriented TCP socket, or <code>QSocketDevice::Datagram</code> for an
unreliable UDP socket.
<p>See also  <a href="#67ea7b">socket</a>().
<h3 class="fn">int <a name="68f6c9"></a>QSocketDevice::ungetch ( int ) <code>[virtual]</code></h3>
<p>Reimplemented for internal reasons; the API is not affected.
<p>This implementation of ungetch returns -1 (error).  A socket is a sequential
device and does not allow any ungetch operation.
<p>Reimplemented from <a href="qiodevice.html#05a43c">QIODevice.</a>
<h3 class="fn">int <a name="2baa28"></a>QSocketDevice::waitForMore ( int msecs ) const</h3>
<p>Wait up to <em>msecs</em> milliseconds for more data to be available.
If <em>msecs</em> is -1 the call will block indefinitely.
<p>This is a blocking call and should be avoided in event driven
applications.
<p>Returns the number of bytes available for reading, or -1 if an
error occurred.
<p>See also  <a href="#318632">bytesAvailable</a>().
<h3 class="fn">int <a name="61dc32"></a>QSocketDevice::writeBlock ( const char * data, uint len ) <code>[virtual]</code></h3>
<p>Writes <em>len</em> bytes to the socket from <em>data</em> and returns
the number of bytes written.  Returns -1 if an error occurred.
<p>This is used for <code>QSocketDevice::Stream</code> sockets.
<p>Reimplemented from <a href="qiodevice.html#924d2f">QIODevice.</a>
<h3 class="fn">int <a name="a6eec8"></a>QSocketDevice::writeBlock ( const char * data, uint len, const <a href="qhostaddress.html">QHostAddress</a> &amp; host, Q_UINT16 port ) <code>[virtual]</code></h3>
<p>Writes <em>len</em> bytes to the socket from <em>data</em> and returns
the number of bytes written.  Returns -1 if an error occurred.
<p>This is used for <code>QSocketDevice::Datagram</code> sockets. You have to specify the
<em>host</em> and <em>port</em> of the destination of the data.
<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses
<a href="http://www.trolltech.com">www.trolltech.com</a>):<br>
<form method=post action="http://www.trolltech.com/search.cgi">
<input type=hidden name="version" value="2.3.2"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-2001
<a href="http://www.trolltech.com">Trolltech</a>, all rights reserved.<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2001 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.2</div>
</table></div></address></body></html>
