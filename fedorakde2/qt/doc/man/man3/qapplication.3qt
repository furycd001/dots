'\" t
.TH QApplication 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QApplication \- Manages the GUI application's control flow and main settings
.br
.PP
\fC#include <qapplication.h>\fR
.PP
Inherits QObject.
.PP
Inherited by QXtApplication.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQApplication\fR ( int & " "argc" ", char ** argv ) "
.br
.ti -1c
.BI "\fBQApplication\fR ( int & " "argc" ", char ** " "argv" ", bool GUIenabled ) "
.br
.ti -1c
.BI "enum \fBType\fR { Tty, GuiClient, GuiServer }"
.br
.ti -1c
.BI "\fBQApplication\fR ( int & " "argc" ", char ** " "argv" ", Type ) "
.br
.ti -1c
.BI "virtual \fB~QApplication\fR () "
.br
.ti -1c
.BI "int \fBargc\fR () const"
.br
.ti -1c
.BI "char** \fBargv\fR () const"
.br
.ti -1c
.BI "Type \fBtype\fR () const"
.br
.ti -1c
.BI "enum \fBColorSpec\fR { NormalColor=0, CustomColor=1, ManyColor=2 }"
.br
.ti -1c
.BI "QWidget* \fBmainWidget\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMainWidget\fR ( QWidget * ) "
.br
.ti -1c
.BI "virtual void \fBpolish\fR ( QWidget * ) "
.br
.ti -1c
.BI "QWidget* \fBfocusWidget\fR () const"
.br
.ti -1c
.BI "QWidget* \fBactiveWindow\fR () const"
.br
.ti -1c
.BI "int \fBexec\fR () "
.br
.ti -1c
.BI "void \fBprocessEvents\fR () "
.br
.ti -1c
.BI "void \fBprocessEvents\fR ( int maxtime ) "
.br
.ti -1c
.BI "void \fBprocessOneEvent\fR () "
.br
.ti -1c
.BI "int \fBenter_loop\fR () "
.br
.ti -1c
.BI "void \fBexit_loop\fR () "
.br
.ti -1c
.BI "int \fBloopLevel\fR () const"
.br
.ti -1c
.BI "virtual bool \fBnotify\fR ( QObject *, QEvent * ) "
.br
.ti -1c
.BI "void \fBsetDefaultCodec\fR ( QTextCodec * ) "
.br
.ti -1c
.BI "QTextCodec* \fBdefaultCodec\fR () const"
.br
.ti -1c
.BI "void \fBinstallTranslator\fR ( QTranslator * ) "
.br
.ti -1c
.BI "void \fBremoveTranslator\fR ( QTranslator * ) "
.br
.ti -1c
.BI "QString translate ( const char *, const char * ) const \fI(obsolete)\fR"
.br
.ti -1c
.BI "QString \fBtranslate\fR ( const char *, const char *, const char * ) const"
.br
.ti -1c
.BI "bool \fBisSessionRestored\fR () const"
.br
.ti -1c
.BI "QString \fBsessionId\fR () const"
.br
.ti -1c
.BI "virtual void \fBcommitData\fR ( QSessionManager & sm ) "
.br
.ti -1c
.BI "virtual void \fBsaveState\fR ( QSessionManager & sm ) "
.br
.ti -1c
.BI "void \fBwakeUpGuiThread\fR () "
.br
.ti -1c
.BI "void \fBlock\fR () "
.br
.ti -1c
.BI "void \fBunlock\fR ( bool " "wakeUpGui" " = TRUE ) "
.br
.ti -1c
.BI "bool \fBlocked\fR () "
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "void \fBquit\fR () "
.br
.ti -1c
.BI "void \fBcloseAllWindows\fR () "
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBlastWindowClosed\fR () "
.br
.ti -1c
.BI "void \fBaboutToQuit\fR () "
.br
.ti -1c
.BI "void \fBguiThreadAwake\fR () "
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QStyle& \fBstyle\fR () "
.br
.ti -1c
.BI "void \fBsetStyle\fR ( QStyle * ) "
.br
.ti -1c
.BI "int \fBcolorSpec\fR () "
.br
.ti -1c
.BI "void \fBsetColorSpec\fR ( int ) "
.br
.ti -1c
.BI "QCursor* \fBoverrideCursor\fR () "
.br
.ti -1c
.BI "void \fBsetOverrideCursor\fR ( const QCursor &, bool " "replace" "=FALSE ) "
.br
.ti -1c
.BI "void \fBrestoreOverrideCursor\fR () "
.br
.ti -1c
.BI "bool \fBhasGlobalMouseTracking\fR () "
.br
.ti -1c
.BI "void \fBsetGlobalMouseTracking\fR ( bool enable ) "
.br
.ti -1c
.BI "QPalette \fBpalette\fR ( const QWidget * = 0 ) "
.br
.ti -1c
.BI "void \fBsetPalette\fR ( const QPalette &, bool " "informWidgets" "=FALSE, const char * " "className" " = 0 ) "
.br
.ti -1c
.BI "QFont \fBfont\fR ( const QWidget * = 0 ) "
.br
.ti -1c
.BI "void \fBsetFont\fR ( const QFont &, bool " "informWidgets" "=FALSE, const char * " "className" " = 0 ) "
.br
.ti -1c
.BI "QFontMetrics \fBfontMetrics\fR () "
.br
.ti -1c
.BI "QWidgetList* \fBallWidgets\fR () "
.br
.ti -1c
.BI "QWidgetList* \fBtopLevelWidgets\fR () "
.br
.ti -1c
.BI "QWidget* \fBdesktop\fR () "
.br
.ti -1c
.BI "QWidget* \fBactivePopupWidget\fR () "
.br
.ti -1c
.BI "QWidget* \fBactiveModalWidget\fR () "
.br
.ti -1c
.BI "QClipboard* \fBclipboard\fR () "
.br
.ti -1c
.BI "QWidget* \fBwidgetAt\fR ( int " "x" ", int " "y" ", bool " "child" "=FALSE ) "
.br
.ti -1c
.BI "QWidget* \fBwidgetAt\fR ( const QPoint &, bool " "child" "=FALSE ) "
.br
.ti -1c
.BI "void \fBexit\fR ( int " "retcode" "=0 ) "
.br
.ti -1c
.BI "bool \fBsendEvent\fR ( QObject * " "receiver" ", QEvent * event ) "
.br
.ti -1c
.BI "void \fBpostEvent\fR ( QObject * " "receiver" ", QEvent * event ) "
.br
.ti -1c
.BI "void \fBsendPostedEvents\fR ( QObject * " "receiver" ", int event_type ) "
.br
.ti -1c
.BI "void \fBsendPostedEvents\fR () "
.br
.ti -1c
.BI "void \fBremovePostedEvents\fR ( QObject * receiver ) "
.br
.ti -1c
.BI "bool \fBstartingUp\fR () "
.br
.ti -1c
.BI "bool \fBclosingDown\fR () "
.br
.ti -1c
.BI "void \fBflushX\fR () "
.br
.ti -1c
.BI "void \fBsyncX\fR () "
.br
.ti -1c
.BI "void \fBbeep\fR () "
.br
.ti -1c
.BI "void setWinStyleHighlightColor ( const QColor & ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "const QColor& winStyleHighlightColor () \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBsetDesktopSettingsAware\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBdesktopSettingsAware\fR () "
.br
.ti -1c
.BI "void \fBsetCursorFlashTime\fR ( int ) "
.br
.ti -1c
.BI "int \fBcursorFlashTime\fR () "
.br
.ti -1c
.BI "void \fBsetDoubleClickInterval\fR ( int ) "
.br
.ti -1c
.BI "int \fBdoubleClickInterval\fR () "
.br
.ti -1c
.BI "void \fBsetWheelScrollLines\fR ( int ) "
.br
.ti -1c
.BI "int \fBwheelScrollLines\fR () "
.br
.ti -1c
.BI "void \fBsetGlobalStrut\fR ( const QSize & ) "
.br
.ti -1c
.BI "QSize \fBglobalStrut\fR () "
.br
.ti -1c
.BI "void \fBsetStartDragTime\fR ( int ms ) "
.br
.ti -1c
.BI "int \fBstartDragTime\fR () "
.br
.ti -1c
.BI "void \fBsetStartDragDistance\fR ( int l ) "
.br
.ti -1c
.BI "int \fBstartDragDistance\fR () "
.br
.ti -1c
.BI "bool \fBisEffectEnabled\fR ( Qt::UIEffect ) "
.br
.ti -1c
.BI "void \fBsetEffectEnabled\fR ( Qt::UIEffect, bool " "enable" " = TRUE ) "
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
(Note that these are not member functions.)
.in +1c
.ti -1c
.BI "void \fBqFatal\fR (const char * " "msg" ", ...)"
.br
.ti -1c
.BI "void \fBqWarning\fR (const char * " "msg" ", ...)"
.br
.ti -1c
.BI "const char * \fBqVersion\fR ()"
.br
.ti -1c
.BI "void \fBqAddPostRoutine\fR (Q_CleanUpFunction " "p" ")"
.br
.ti -1c
.BI "void \fBASSERT\fR (bool " "test" ")"
.br
.ti -1c
.BI "void \fBqDebug\fR (const char * " "msg" ", ...)"
.br
.ti -1c
.BI "bool \fBqSysInfo\fR (int * " "wordSize" ", bool * " "bigEndian" ")"
.br
.ti -1c
.BI "void \fBCHECK_PTR\fR (void * " "p" ")"
.br
.ti -1c
.BI "msg_handler \fBqInstallMsgHandler\fR (msg_handler " "h" ")"
.br
.in -1c
.SH DESCRIPTION
The QApplication class manages the GUI application's control flow and main settings.
.PP
It contains the main event loop, where all events from the window system and other sources are processed and dispatched. It also handles the application initialization and finalization, and provides session management. Finally, it handles most system-wide and application-wide settings.
.PP
For any GUI application that uses Qt, there is precisely one QApplication object, no matter whether the application has 0, 1, 2 or even more windows at the moment.
.PP
This object (you can access is using the global variable \fCqApp)\fR does a great many things, most importantly: 
.TP
It initializes the application to the user's desktop settings like palette(), font() or the doubleClickInterval(). It keeps track of these properties in case the user changes the desktop globally in some kind of control panel.
.TP
It performs event handling, meaning that it receives events from the underlying window system and sends them to the destination widgets. By using sendEvent() and postEvent() you can send your own events to widgets.
.TP
It parses common command line arguments and sets its internal state accordingly. See the constructor documentation below for more details about this.
.TP
It defines the application's look and feel, which is encapsulated in a QStyle object. This can be changed during runtime with setStyle().
.TP
It specifies how the application is to allocate colors. See setColorSpec() for details.
.TP
It specifies the default text encoding (see setDefaultCodec() ) and provides localization of strings that are visible to the user via translate().
.TP
It provides some magic objects like the desktop() and the clipboard().
.TP
It knows about the application's windows, and lets you ask which widget is at a certain position using widgetAt(), lets you closeAllWindows(), gives you a list of topLevelWidgets(), etc.
.TP
It manages the application's mouse cursor handling, see setOverrideCursor() and setGlobalMouseTracking().
.TP
On the X window system, it provides functions to flush and sync the communication stream, see flushX() and syncX().
.TP
It provides support to implement sophisticated session management. This makes it possible for applications to terminate gracefully when the user logs out, to cancel a shutdown process if termination isn't possible and even to preserve the entire application state for a future session. See isSessionRestored(), sessionId() and commitData() and saveState() for details.
.IP
.PP
The Application walk-through example contains a typical complete main() that does the usual things with QApplication.
.PP
Since the QApplication object does so much initialization, it is absolutely necessary to create it before any other objects related to the user interface are created.
.PP
Since it also deals with common command line arguments, it is usually a good idea to create it \fIbefore\fR any interpretation or modification of \fCargv\fR is done in the application itself. (Note also that for X11, setMainWidget() may change the main widget according to the \fC-geometry\fR option. To preserve this functionality, you must set your defaults before setMainWidget() and any overrides after.)
.PP
\fBGroups of functions:\fR
.TP
System settings: desktopSettingsAware(), setDesktopSettingsAware(), cursorFlashTime(), setCursorFlashTime(), doubleClickInterval(), setDoubleClickInterval(), wheelScrollLines(), setWheelScrollLines(), palette(), setPalette(), font(), setFont(), fontMetrics().
.TP
Event handling: exec(), processEvents(), processOneEvent(), enter_loop(), exit_loop(), exit(), quit(). sendEvent(), postEvent(), sendPostedEvents(), removePostedEvents(), notify(), x11EventFilter(), x11ProcessEvent(), winEventFilter().
.TP
GUI Styles: style(), setStyle(), polish().
.TP
Color usage: colorSpec(), setColorSpec().
.TP
Text handling: setDefaultCodec(), installTranslator(), removeTranslator() translate().
.TP
Certain widgets: mainWidget(), setMainWidget(), allWidgets(), topLevelWidgets(), desktop(), activePopupWidget(), activeModalWidget(), clipboard(), focusWidget(), activeWindow(), widgetAt().
.TP
Advanced cursor handling: hasGlobalMouseTracking(), setGlobalMouseTracking(), overrideCursor(), setOverrideCursor(), restoreOverrideCursor().
.TP
X Window System synchronization: flushX(), syncX().
.TP
Session management: isSessionRestored(), sessionId(), commitData(), saveState()
.TP
Misc: closeAllWindows(), startingUp(), closingDown(),
.PP
\fBNon-GUI programs\fR
.br
While Qt is not optimized or designed for writing non-GUI programs, it's possible to use some of its classes without creating a QApplication. This can be useful if you wish to share code between a non-GUI server and a GUI client.
.PP
Examples:
.(l
showimg/main.cpp action/main.cpp rangecontrols/main.cpp iconview/main.cpp validator/main.cpp themes/main.cpp listviews/main.cpp aclock/main.cpp checklists/main.cpp drawlines/connect.cpp dclock/main.cpp wizard/main.cpp xform/xform.cpp application/main.cpp cursor/cursor.cpp layout/layout.cpp helpviewer/main.cpp buttongroups/main.cpp life/main.cpp i18n/main.cpp drawdemo/drawdemo.cpp lineedits/main.cpp popup/popup.cpp fileiconview/main.cpp listbox/main.cpp menu/menu.cpp progress/progress.cpp scribble/main.cpp qmag/qmag.cpp tabdialog/main.cpp splitter/splitter.cpp progressbar/main.cpp tooltip/main.cpp richtext/main.cpp qwerty/main.cpp forever/forever.cpp rot13/rot13.cpp xml/tagreader
.)l-with-features/tagreader.cpp
desktop/desktop.cpp scrollview/scrollview.cpp qfd/qfd.cpp addressbook/main.cpp movies/main.cpp picture/picture.cpp hello/main.cpp listboxcombo/main.cpp biff/main.cpp tictac/main.cpp customlayout/main.cpp mdi/main.cpp dirview/main.cpp
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QApplication::QApplication ( int & argc, char ** argv )"
Initializes the window system and constructs an application object with the command line arguments \fIargc\fR and \fIargv.\fR
.PP
The global \fCqApp\fR pointer refers to this application object. Only one application object should be created.
.PP
This application object must be constructed before any paint devices (includes widgets, pixmaps, bitmaps etc.)
.PP
Notice that \fIargc\fR and \fIargv\fR might be changed. Qt removes command line arguments that it recognizes. The original \fIargc\fR and \fIargv\fR are can be accessed later by \fCqApp->argc()\fR and \fCqApp->argv().\fR The documentation for argv() contains a detailed description of how to process command line arguments.
.PP
Qt debugging options (not available if Qt was compiled with the NO_DEBUG flag defined):
.TP
\fC-nograb,\fR tells Qt to never grab the mouse or the keyboard.
.TP
\fC-dograb\fR (only under X11), running under a debugger can cause an implicit -nograb, use -dograb to override.
.TP
\fC-sync\fR (only under X11), switches to synchronous mode for debugging.
.PP
See Debugging Techniques for a more detailed explanation.
.PP
All Qt programs automatically support the following command line options:
.TP
\fC-style=\fR \fIstyle,\fR sets the application GUI style. Possible values are \fCmotif, windows,\fR and \fCplatinum.\fR
.TP
\fC-session=\fR \fIsession,\fR restores the application from an earlier session.
.PP
The X11 version of Qt also supports some traditional X11 command line options:
.TP
\fC-display\fR \fIdisplay,\fR sets the X display (default is $DISPLAY).
.TP
\fC-geometry\fR \fIgeometry,\fR sets the client geometry of the main widget.
.TP
\fC-fn\fR or \fC-font\fR \fIfont,\fR defines the application font.
.TP
\fC-bg\fR or \fC-background\fR \fIcolor,\fR sets the default background color and an application palette (light and dark shades are calculated).
.TP
\fC-fg\fR or \fC-foreground\fR \fIcolor,\fR sets the default foreground color.
.TP
\fC-btn\fR or \fC-button\fR \fIcolor,\fR sets the default button color.
.TP
\fC-name\fR \fIname,\fR sets the application name.
.TP
\fC-title\fR \fItitle,\fR sets the application title (caption).
.TP
\fC-visual TrueColor,\fR forces the application to use a TrueColor visual on an 8-bit display.
.TP
\fC-ncols\fR \fIcount,\fR limits the number of colors allocated in the color cube on a 8-bit display, if the application is using the \fCQApplication::ManyColor\fR color specification. If \fIcount\fR is 216 then a 6x6x6 color cube is used (ie. 6 levels of red, 6 of green, and 6 of blue); for other values, a cube approximately proportional to a 2x3x1 cube is used.
.TP
\fC-cmap,\fR causes the application to install a private color map on an 8-bit display.
.PP
See also argc() and argv().
.SH "QApplication::QApplication ( int & argc, char ** argv, Type type )"
For Qt/Embedded, passing \fIQApplication::GuiServer\fR for \fItype\fR make this application the server (equivalent to running with the -qws option).
.SH "QApplication::QApplication ( int & argc, char ** argv, bool GUIenabled )"
Constructs an application object with the command line arguments \fIargc\fR and \fIargv.\fR If \fIGUIenabled\fR is TRUE, a normal application is constructed, otherwise a non-GUI application is created.
.PP
Set \fIGUIenabled\fR to FALSE for programs without a graphical user interface that should be able to run without a window system.
.PP
On X11, the window system is initialized if \fIGUIenabled\fR is TRUE. If \fIGUIenabled\fR is FALSE, the application does not connect to the X-server.
.PP
On Windows, currently the window system is always initialized, regardless of the value of GUIenabled. This may change in future versions of Qt.
.PP
The following example shows how to create an application that uses a graphical interface when available.
.PP
.nf
.br
  int main( int argc, char **argv )
.br
  {
.br
    QApplication app(argc, argv, useGUI);
.br
.br
    if ( useGUI ) {
.br
       //start GUI version
.br
       ...
.br
    } else {
.br
       //start non-GUI version
.br
       ...
.br
    }
.br
    return app.exec();
.br
  }
.fi
.SH "QApplication::~QApplication () \fC[virtual]\fR"
Cleans up any window system resources that were allocated by this application. Sets the global variable \fCqApp\fR to null.
.SH "void QApplication::aboutToQuit () \fC[signal]\fR"
This signal is emitted when the application is about to quit the main event loop. This may happen either after a call to quit() from inside the application or when the users shuts down the entire desktop session.
.PP
The signal is particularly useful if your application has to do some last-second cleanups. Note that no user interaction is possible at this state.
.PP
See also quit().
.SH "QWidget * QApplication::activeModalWidget () \fC[static]\fR"
Returns the active modal widget.
.PP
A modal widget is a special top level widget which is a subclass of QDialog that specifies the modal parameter of the constructor to TRUE. A modal widget must be finished before the user can continue with other parts of the program.
.PP
The modal widgets are organized in a stack. This function returns the active modal widget on top of the stack.
.PP
See also activePopupWidget() and topLevelWidgets().
.SH "QWidget * QApplication::activePopupWidget () \fC[static]\fR"
Returns the active popup widget.
.PP
A popup widget is a special top level widget that sets the \fCWType_Popup\fR widget flag, e.g. the QPopupMenu widget. When the application opens a popup widget, all events are sent to the popup. Normal widgets and modal widgets cannot be accessed before the popup widget is closed.
.PP
Only other popup widgets may be opened when a popup widget is shown. The popup widgets are organized in a stack. This function returns the active popup widget on top of the stack.
.PP
See also activeModalWidget() and topLevelWidgets().
.SH "QWidget * QApplication::activeWindow () const"
Returns the application top-level window that has the keyboard input focus, or null if no application window has the focus. Note that there might be an activeWindow even if there is no focusWidget(), for example if no widget in that window accepts key events.
.PP
See also QWidget::setFocus(), QWidget::hasFocus() and focusWidget().
.SH "QWidgetList * QApplication::allWidgets () \fC[static]\fR"
Returns a list of all the widgets in the application.
.PP
The list is created using new and must be deleted by the caller.
.PP
The list is empty (QList::isEmpty()) if there are no widgets.
.PP
Note that some of the widgets may be hidden.
.PP
Example:
.PP
.nf
.br
    //
.br
    // Updates all widgets.
.br
    //
.br
    QWidgetList  *list = QApplication::allWidgets();
.br
    QWidgetListIt it( *list );          // iterate over the widgets
.br
    QWidget * w;
.br
    while ( (w=it.current()) != 0 ) {   // for each widget...
.br
        ++it;
.br
        w->update();
.br
    }
.br
    delete list;                        // delete the list, not the widgets
.fi
.PP
The QWidgetList class is defined in the qwidgetlist.h header file.
.PP
\fBWarning:\fR Delete the list away as soon you have finished using it. The widgets in the list may be deleted by someone else at any time.
.PP
See also topLevelWidgets(), QWidget::isVisible() and QList::isEmpty(),.
.SH "int QApplication::argc () const"
Returns the number of command line arguments.
.PP
The documentation for argv() contains a detailed description of how to process command line arguments.
.PP
See also argv() and QApplication::QApplication().
.SH "char ** QApplication::argv () const"
Returns the command line argument vector.
.PP
\fCargv()[0]\fR is the program name, \fCargv()[1]\fR is the first argument and \fCargv()[argc()-1]\fR is the last argument.
.PP
A QApplication object is constructed by passing \fIargc\fR and \fIargv\fR from the \fCmain()\fR function. Some of the arguments may be recognized as Qt options removed from the argument vector. For example, the X11 version of Qt knows about \fC-display, -font\fR and a few more options.
.PP
Example:
.PP
.nf
.br
    // showargs.cpp - displays program arguments in a list box
.br
.br
    #include <qapplication.h>
.br
    #include <qlistbox.h>
.br
.br
    int main( int argc, char **argv )
.br
    {
.br
        QApplication a( argc, argv );
.br
        QListBox b;
.br
        a.setMainWidget( &b );
.br
        for ( int i=0; i<a.argc(); i++ )        // a.argc() == argc
.br
            b.insertItem( a.argv()[i] );        // a.argv()[i] == argv[i]
.br
        b.show();
.br
        return a.exec();
.br
    }
.fi
.PP
If you run \fCshowargs -display unix:0 -font 9x15bold hello world\fR under X11, the list box contains the three strings" showargs", "hello" and "world".
.PP
See also argc() and QApplication::QApplication().
.SH "void QApplication::beep () \fC[static]\fR"
Sounds the bell, using the default volume and sound.
.SH "QClipboard * QApplication::clipboard () \fC[static]\fR"
Returns a pointer to the application global clipboard.
.SH "void QApplication::closeAllWindows () \fC[slot]\fR"
A convenience function that closes all toplevel windows.
.PP
The function is particularly useful for applications with many toplevel windows. It could for example be connected to a "Quit" entry in the file menu as shown in the following code example:
.PP
.nf
.br
    // the "Quit" menu entry should try to close all windows
.br
    QPopupMenu* file = new QPopupMenu( this );
.br
    file->insertItem( tr("&Quit"), qApp, SLOT(closeAllWindows()), CTRL+Key_Q );
.br
.br
    // when the last window was closed, the application should quit
.br
    connect( qApp, SIGNAL( lastWindowClosed() ), qApp, SLOT( quit() ) );
.fi
.PP
The windows are closed in random order, until one window does not accept the close event.
.PP
See also QWidget::close(), QWidget::closeEvent(), lastWindowClosed(), quit(), topLevelWidgets() and QWidget::isTopLevel().
.SH "bool QApplication::closingDown () \fC[static]\fR"
Returns TRUE if the application objects are being destroyed.
.PP
See also startingUp().
.SH "int QApplication::colorSpec () \fC[static]\fR"
Returns the color specification.
.PP
See also QApplication::setColorSpec().
.SH "void QApplication::commitData ( QSessionManager & sm ) \fC[virtual]\fR"
This function deals with session management. It is invoked when the QSessionManager wants the application to commit all its data.
.PP
Usually this means saving of all open files, after getting permission from the user. Furthermore you may want to provide the user a way to cancel the shutdown.
.PP
Note that you should not exit the application within this function. Instead, the session manager may or may not do this afterwards, depending on the context.
.PP
\fBImportant\fR
.br
Within this function, no user interaction is possible, \fIunless\fR you ask the session manager \fIsm\fR for explicit permission. See QSessionManager::allowsInteraction() and QSessionManager::allowsErrorInteraction() for details and example usage.
.PP
The default implementation requests interaction and sends a close event to all visible toplevel widgets. If at least one event was rejected, the shutdown is cancelled.
.PP
See also isSessionRestored(), sessionId() and saveState().
.SH "int QApplication::cursorFlashTime () \fC[static]\fR"
Returns the text cursor's flash time in milliseconds. The flash time is the time required to display, invert and restore the caret display.
.PP
The default value on X11 is 1000 milliseconds. On Windows, the control panel value is used.
.PP
Widgets should not cache this value since it may vary any time the user changes the global desktop settings.
.PP
See also setCursorFlashTime().
.SH "QTextCodec* QApplication::defaultCodec () const"
Returns the default codec (see setDefaultCodec()). Returns 0 by default (no codec).
.SH "QWidget * QApplication::desktop () \fC[static]\fR"
Returns the desktop widget (also called the root window).
.PP
The desktop widget is useful for obtaining the size of the screen. It may also be possible to draw on the desktop. We recommend against assuming that it's possible to draw on the desktop, as it works on some machines and not on others.
.PP
.nf
.br
    QWidget *d = QApplication::desktop();
.br
    int w=d->width();                   // returns screen width
.br
    int h=d->height();                  // returns screen height
.fi
.PP
Examples:
.(l
helpviewer/main.cpp scribble/main.cpp qmag/qmag.cpp
.)l
.SH "bool QApplication::desktopSettingsAware () \fC[static]\fR"
Returns the value set by setDesktopSettingsAware(), by default TRUE.
.PP
See also setDesktopSettingsAware().
.SH "int QApplication::doubleClickInterval () \fC[static]\fR"
Returns the maximum duration for a double click.
.PP
The default value on X11 is 400 milliseconds. On Windows, the control panel value is used.
.PP
See also setDoubleClickInterval().
.SH "int QApplication::enter_loop ()"
This function enters the main event loop (recursively). Do not call it unless you really know what you are doing.
.PP
See also exit_loop() and loopLevel().
.SH "int QApplication::exec ()"
Enters the main event loop and waits until exit() is called or the main widget is destroyed, and Returns the value that was set via to exit() (which is 0 if exit() is called via quit()).
.PP
It is necessary to call this function to start event handling. The main event loop receives events from the window system and dispatches these to the application widgets.
.PP
Generally speaking, no user interaction can take place before calling exec(). As a special case, modal widgets like QMessageBox can be used before calling exec(), because modal widgets call exec() to start a local event loop.
.PP
To make your application perform idle processing, i.e. executing a special function whenever there are no pending events, use a QTimer with 0 timeout. More advanced idle processing schemes can be achieved by using processEvents() and processOneEvent().
.PP
See also quit(), exit(), processEvents() and setMainWidget().
.PP
Examples:
.(l
showimg/main.cpp action/main.cpp rangecontrols/main.cpp iconview/main.cpp validator/main.cpp themes/main.cpp listviews/main.cpp aclock/main.cpp checklists/main.cpp drawlines/connect.cpp dclock/main.cpp mainlyQt/editor.cpp xform/xform.cpp application/main.cpp cursor/cursor.cpp layout/layout.cpp helpviewer/main.cpp buttongroups/main.cpp life/main.cpp i18n/main.cpp drawdemo/drawdemo.cpp lineedits/main.cpp popup/popup.cpp fileiconview/main.cpp listbox/main.cpp menu/menu.cpp progress/progress.cpp scribble/main.cpp qmag/qmag.cpp tabdialog/main.cpp splitter/splitter.cpp progressbar/main.cpp tooltip/main.cpp richtext/main.cpp qwerty/main.cpp forever/forever.cpp rot13/rot13.cpp xml/tagreader
.)l-with-features/tagreader.cpp
scrollview/scrollview.cpp qfd/qfd.cpp addressbook/main.cpp movies/main.cpp picture/picture.cpp hello/main.cpp listboxcombo/main.cpp biff/main.cpp tictac/main.cpp customlayout/main.cpp mdi/main.cpp dirview/main.cpp
.SH "void QApplication::exit ( int retcode=0 ) \fC[static]\fR"
Tells the application to exit with a return code.
.PP
After this function has been called, the application leaves the main event loop and returns from the call to exec(). The exec() function returns \fIretcode.\fR
.PP
By convention, \fIretcode\fR 0 means success, any non-zero value indicates an error.
.PP
Note that unlike the C library function of the same name, this function \fIdoes\fR returns to the caller - it is event processing that stops.
.PP
See also quit() and exec().
.PP
Examples:
.(l
picture/picture.cpp
.)l
.SH "void QApplication::exit_loop ()"
This function leaves from a recursive call to the main event loop. Do not call it unless you are an expert.
.PP
See also enter_loop() and loopLevel().
.SH "void QApplication::flushX () \fC[static]\fR"
Flushes the X event queue in the X11 implementation. This normally returns almost immediately. Does nothing on other platforms.
.PP
See also syncX().
.SH "QWidget * QApplication::focusWidget () const"
Returns the application widget that has the keyboard input focus, or null if no widget in this application has the focus.
.PP
See also QWidget::setFocus(), QWidget::hasFocus() and activeWindow().
.SH "QFont QApplication::font ( const QWidget * w = 0 ) \fC[static]\fR"
Returns the default font for a widget. Basically this function uses w->className() to get a font for it.
.PP
If \fIw\fR is 0 the default application font is returned.
.PP
See also setFont(), fontMetrics() and QWidget::font().
.SH "QFontMetrics QApplication::fontMetrics () \fC[static]\fR"
Returns display (screen) font metrics for the application font.
.PP
See also font(), setFont(), QWidget::fontMetrics() and QPainter::fontMetrics().
.SH "QSize QApplication::globalStrut () \fC[static]\fR"
Returns the global strut of the application.
.PP
See also setGlobalStrut().
.SH "void QApplication::guiThreadAwake () \fC[signal]\fR"
This signal is emitted when the GUI threads is about to process a cycle of the event loop.
.PP
See also wakeUpGuiThread().
.SH "bool QApplication::hasGlobalMouseTracking () \fC[static]\fR"
Returns TRUE if global mouse tracking is enabled, otherwise FALSE.
.PP
See also setGlobalMouseTracking().
.SH "void QApplication::installTranslator ( QTranslator * mf )"
Adds \fImf\fR to the list of message files to be used for localization. Message files are searched starting with the most recently added file.
.PP
See also removeTranslator(), translate() and QObject::tr().
.SH "bool QApplication::isEffectEnabled ( Qt::UIEffect effect ) \fC[static]\fR"
Returns TRUE if \fIeffect\fR is enabled, otherwise FALSE.
.PP
By default, Qt will try to use the desktop settings, and setDesktopSettingsAware() must be called to prevent this.
.PP
sa\\ setEffectEnabled(), Qt::UIEffect.
.SH "bool QApplication::isSessionRestored () const"
Returns whether the application has been restored from an earlier session.
.PP
See also sessionId(), commitData() and saveState().
.SH "void QApplication::lastWindowClosed () \fC[signal]\fR"
This signal is emitted when the user has closed the last remaining top level window.
.PP
The signal is very useful when your application has many top level widgets but no main widget. You can then connect it to the quit() slot.
.PP
For convenience, transient toplevel widgets such as popup menus and dialogs are omitted.
.PP
See also mainWidget(), topLevelWidgets(), QWidget::isTopLevel() and QWidget::close().
.SH "void QApplication::lock ()"
Lock the Qt library mutex. If another thread has already locked the mutex, the calling thread will block until the other thread has unlocked the mutex.
.PP
See also unlock() and locked().
.SH "bool QApplication::locked ()"
Returns TRUE if the Qt library mutex is locked by a different thread, otherwise returns FALSE.
.PP
\fINOTE:\fR Due to differing implementations of recursive mutexes on various platforms, calling this function from the same thread that previous locked the mutex will return undefined results.
.PP
See also lock() and unlock().
.SH "int QApplication::loopLevel () const"
Returns the current loop level
.PP
See also enter_loop() and exit_loop().
.SH "QWidget * QApplication::mainWidget () const"
Returns the main application widget, or a null pointer if there is not a defined main widget.
.PP
See also setMainWidget().
.SH "bool QApplication::notify ( QObject * receiver, QEvent * event ) \fC[virtual]\fR"
Sends \fIevent\fR to \fIreceiver:\fR \fCreceiver->event( event )\fR Returns the value that is returned from the receiver's event handler.
.PP
Reimplementing this virtual function is one of five ways to process an event: 
.IP 1
Reimplementing this function. Very powerful, you get \fIcomplete\fR control, but of course only one subclass can be qApp.
.IP 2
Installing an event filter on qApp. Such an event filter gets to process all events for all widgets, so it's just as powerful as reimplementing notify(), and in this way it's possible to have more than one application-global event filter. Global event filter get to see even mouse events for disabled widgets, and if global mouse tracking is enabled, mouse move events for all widgets.
.IP 3
Reimplementing QObject::event() (as QWidget does). If you do this you get tab key-presses, and you get to see the events before any widget-specific event filters.
.IP 4
Installing an event filter on the object. Such an even filter gets all the events except Tab and Shift-Tab key presses.
.IP 5
Finally, reimplementing paintEvent(), mousePressEvent() and so on. This is the normal, easiest and least powerful way. 
.PP
See also QObject::event() and installEventFilter().
.SH "QCursor * QApplication::overrideCursor () \fC[static]\fR"
Returns the active application override cursor.
.PP
This function returns 0 if no application cursor has been defined (i.e. the internal cursor stack is empty).
.PP
See also setOverrideCursor() and restoreOverrideCursor().
.SH "QPalette QApplication::palette ( const QWidget * w = 0 ) \fC[static]\fR"
Returns a pointer to the default application palette. There is always an application palette, i.e. the returned pointer is guaranteed to be non-null.
.PP
If a widget is passed as argument, the default palette for the widget's class is returned. This may or may not be the application palett. In most cases there isn't be a special palette for certain types of widgets, but one notable exception is the popup menu under Windows, if the user has defined a special background color for menus in the display settings.
.PP
See also setPalette() and QWidget::palette().
.SH "void QApplication::polish ( QWidget * w ) \fC[virtual]\fR"
Polishing of widgets.
.PP
Usually widgets call this automatically when they are polished. It may be used to do some style-based central customization of widgets.
.PP
Note that you are not limited to public functions of QWidget. Instead, based on meta information like QObject::className() you are able to customize any kind of widgets.
.PP
See also QStyle::polish(), QWidget::polish(), setPalette() and setFont().
.SH "void QApplication::postEvent ( QObject * receiver, QEvent * event ) \fC[static]\fR"
Stores the event in a queue and returns immediately.
.PP
The event must be allocated on the heap, as it is deleted when the event has been posted.
.PP
When control returns to the main event loop, all events that are stored in the queue will be sent using the notify() function.
.PP
See also sendEvent().
.SH "void QApplication::processEvents ()"
Processes pending events, for 3 seconds or until there are no more events to process, whichever is shorter.
.PP
You can call this function occasionally when your program is busy doing a long operation (e.g. copying a file).
.PP
See also processOneEvent(), exec() and QTimer.
.SH "void QApplication::processEvents ( int maxtime )"
Processes pending events for \fImaxtime\fR milliseconds or until there are no more events to process, whichever is shorter.
.PP
You can call this function occasionally when you program is busy doing a long operation (e.g. copying a file).
.PP
See also processOneEvent(), exec() and QTimer.
.SH "void QApplication::processOneEvent ()"
Waits for an event to occur, processes it, then returns.
.PP
This function is useful for adapting Qt to situations where the event processing must be grafted into existing program loops. Using this function in new applications may be an indication of design problems.
.PP
See also processEvents(), exec() and QTimer.
.SH "void QApplication::quit () \fC[slot]\fR"
Tells the application to exit with return code 0 (success). Equivalent to calling QApplication::exit( 0 ).
.PP
This function is a slot, so you may connect any signal to activate quit().
.PP
Example:
.PP
.nf
.br
    QPushButton *quitButton = new QPushButton( "Quit" );
.br
    connect( quitButton, SIGNAL(clicked()), qApp, SLOT(quit()) );
.fi
.PP
See also exit() and aboutToQuit().
.SH "void QApplication::removePostedEvents ( QObject * receiver ) \fC[static]\fR"
Removes all events posted using postEvent() for \fIreceiver.\fR
.PP
The events are \fInot\fR dispatched, simply removed from the queue. You should never need to call this function. If you do call it, be aware that killing events may cause \fIreceiver\fR to break one or more invariants.
.SH "void QApplication::removeTranslator ( QTranslator * mf )"
Removes \fImf\fR from the list of message files used by this application. Does not, of course, delete mf.
.PP
See also installTranslator(), translate() and QObject::tr().
.SH "void QApplication::restoreOverrideCursor () \fC[static]\fR"
Undoes the last setOverrideCursor().
.PP
If setOverrideCursor() has been called twice, calling restoreOverrideCursor() will activate the first cursor set. Calling this function a second time restores the original widgets cursors.
.PP
See also setOverrideCursor() and overrideCursor().
.SH "void QApplication::saveState ( QSessionManager & sm ) \fC[virtual]\fR"
This function deals with session management. It is invoked when the session manager wants the application to preserve its state for a future session.
.PP
For a text editor this would mean creating a temporary file that includes the current contents of the edit buffers, the location of the cursor and other aspects of the current editing session.
.PP
Note that you should never exit the application within this function. Instead, the session manager may or may not do this afterwards, depending on the context. Futhermore, most session managers will very likely request a saved state immediately after the application has been started. This permits the session manager to learn about the application's restart policy.
.PP
\fBImportant\fR
.br
Within this function, no user interaction is possible, \fIunless\fR you ask the session manager \fIsm\fR for explicit permission. See QSessionManager::allowsInteraction() and QSessionManager::allowsErrorInteraction() for details.
.PP
See also isSessionRestored(), sessionId() and commitData().
.SH "bool QApplication::sendEvent ( QObject * receiver, QEvent * event ) \fC[static]\fR"
Sends an event directly to a receiver, using the notify() function. Returns the value that was returned from the event handler.
.PP
See also postEvent() and notify().
.PP
Examples:
.(l
popup/popup.cpp
.)l
.SH "void QApplication::sendPostedEvents () \fC[static]\fR"
Dispatches all posted events.
.SH "void QApplication::sendPostedEvents ( QObject * receiver, int event_type ) \fC[static]\fR"
Immediately dispatches all events which have been previously enqueued with QApplication::postEvent() and which are for the object \fIreceiver\fR and have the \fIevent_type.\fR
.PP
Some event compression may occur. Note that events from the window system are \fInot\fR dispatched by this function.
.SH "QString QApplication::sessionId () const"
Returns the identifier of the current session.
.PP
If the application has been restored from an earlier session, this identifier is the same as it was in that previous session.
.PP
The session identifier is guaranteed to be unique for both different applications and different instances of the same application.
.PP
See also isSessionRestored(), commitData() and saveState().
.SH "void QApplication::setColorSpec ( int spec ) \fC[static]\fR"
Sets the color specification for the application to \fIspec.\fR
.PP
The color specification controls how your application allocates colors when run on a display with a limited amount of colors, i.e. 8 bit / 256 color displays.
.PP
The color specification must be set before you create the QApplication object.
.PP
The choices are:
.TP
\fCQApplication::NormalColor.\fR This is the default color allocation strategy. Use this choice if your application uses buttons, menus, texts and pixmaps with few colors. With this choice, the application uses system global colors. This works fine for most applications under X11, but on Windows machines it may cause dithering of non-standard colors.
.TP
\fCQApplication::CustomColor.\fR Use this choice if your application needs a small number of custom colors. On X11, this choice is the same as NormalColor. On Windows, Qt creates a Windows palette, and allocates colors in it on demand.
.TP
\fCQApplication::ManyColor.\fR Use this choice if your application is very color hungry (e.g. it wants thousands of colors). Under X11 the effect is: 
.TP
For 256-color displays which have at best a 256 color true color visual, the default visual is used, and colors are allocated from a color cube. The color cube is the 6x6x6 (216 color) "Web palette", but the number of colors can be changed by the \fI-ncols\fR option. The user can force the application to use the true color visual by the -visual option.
.TP
For 256-color displays which have a true color visual with more than 256 colors, use that visual. Silicon Graphics X servers have this feature, for example. They provide an 8 bit visual by default but can deliver true color when asked. On Windows, Qt creates a Windows palette, and fills it with a color cube.
.PP
Be aware that the CustomColor and ManyColor choices may lead to colormap flashing: The foreground application gets (most) of the available colors, while the background windows will look less good.
.PP
Example:
.PP
.nf
.br
  int main( int argc, char **argv )
.br
  {
.br
      QApplication::setColorSpec( QApplication::ManyColor );
.br
      QApplication a( argc, argv );
.br
      ...
.br
  }
.fi
.PP
QColor provides more functionality for controlling color allocation and freeing up certain colors. See QColor::enterAllocContext() for more information.
.PP
To see what mode you end up with, you can call QColor::numBitPlanes() once the QApplication object exists. A value greater than 8 (typically 16, 24 or 32) means true color.
.PP
The color cube used by Qt are all those colors with red, green, and blue components of either 0x00, 0x33, 0x66, 0x99, 0xCC, or 0xFF.
.PP
See also colorSpec(), QColor::numBitPlanes() and QColor::enterAllocContext().
.PP
Examples:
.(l
showimg/main.cpp themes/main.cpp tetrix/tetrix.cpp helpviewer/main.cpp
.)l
.SH "void QApplication::setCursorFlashTime ( int msecs ) \fC[static]\fR"
Sets the text cursor's flash time to \fImsecs\fR milliseconds. The flash time is the time required to display, invert and restore the caret display: A full flash cycle. Usually, the text cursor is displayed for \fImsecs/2\fR milliseconds, then hidden for \fImsecs/2\fR milliseconds, but this may vary.
.PP
Note that on Microsoft Windows, calling this function sets the cursor flash time for all windows.
.PP
See also cursorFlashTime().
.SH "void QApplication::setDefaultCodec ( QTextCodec * codec )"
If the literal quoted text in the program is not in the Latin1 encoding, this function can be used to set the appropriate encoding. For example, software developed by Korean programmers might use eucKR for all the text in the program, in which case main() would be:
.PP
.nf
.br
    main(int argc, char** argv)
.br
    {
.br
        QApplication app(argc, argv);
.br
        ... install any additional codecs ...
.br
        app.setDefaultCodec( QTextCodec::codecForName("eucKR") );
.br
        ...
.br
    }
.fi
.PP
Note that this is \fInot\fR the way to select the encoding that the \fIuser\fR has chosen. For example, to convert an application containing literal English strings to Korean, all that is needed is for the English strings to be passed through tr() and for translation files to be loaded. For details of internationalization, see the Qt Internationalization documentation.
.PP
Note also that some Qt built-in classes call tr() with various strings. These strings are in English, so for a full translation, a codec would be required for these strings.
.SH "void QApplication::setDesktopSettingsAware ( bool on ) \fC[static]\fR"
By default, Qt will try to get the current standard colors, fonts etc. from the underlying window system's desktop settings (resources), and use them for all relevant widgets. This behavior can be switched off by calling this function with \fIon\fR set to FALSE.
.PP
This static function must be called before creating the QApplication object, like this:
.PP
.nf
.br
  int main( int argc, char** argv ) {
.br
    QApplication::setDesktopSettingsAware( FALSE ); // I know better than the user
.br
    QApplication myApp( argc, argv );           // gimme default fonts & colors
.br
    ...
.br
  }
.fi
.PP
See also desktopSettingsAware().
.SH "void QApplication::setDoubleClickInterval ( int ms ) \fC[static]\fR"
Sets the time limit that distinguishes a double click from two consecutive mouse clicks to \fIms\fR milliseconds.
.PP
Note that on Microsoft Windows, calling this function sets the double click interval for all windows.
.PP
See also doubleClickInterval().
.SH "void QApplication::setEffectEnabled ( Qt::UIEffect effect, bool enable = TRUE ) \fC[static]\fR"
Enables the UI effect \fIeffect\fR if \fIenable\fR is TRUE, otherwise the effect will not be used.
.PP
See also isEffectEnabled(), Qt::UIEffect and setDesktopSettingsAware().
.SH "void QApplication::setFont ( const QFont & font, bool informWidgets=FALSE, const char * className = 0 ) \fC[static]\fR"
Changes the default application font to \fIfont.\fR If \fIinformWidgets\fR is TRUE, then existing widgets are informed about the change and thus may adjust themselves to the new application setting. Otherwise the change only affects newly created widgets. If \fIclassName\fR is passed, the change applies only to classes that inherit \fIclassName\fR (as reported by QObject::inherits()).
.PP
On application start-up, the default font depends on the window system. It can vary both with window system version and with locale. This function lets you override it. Note that overriding it may be a bad idea, for example some locales need extra-big fonts to support their special characters.
.PP
See also font(), fontMetrics() and QWidget::setFont().
.PP
Examples:
.(l
showimg/main.cpp desktop/desktop.cpp qfd/qfd.cpp
.)l
.SH "void QApplication::setGlobalMouseTracking ( bool enable ) \fC[static]\fR"
Enables global mouse tracking if \fIenable\fR is TRUE or disables it if \fIenable\fR is FALSE.
.PP
Enabling global mouse tracking makes it possible for widget event filters or application event filters to get all mouse move events, even when no button is depressed. This is useful for special GUI elements, e.g. tool tips.
.PP
Global mouse tracking does not affect widgets and their mouseMoveEvent(). For a widget to get mouse move events when no button is depressed, it must do QWidget::setMouseTracking(TRUE).
.PP
This function uses an internal counter. Each setGlobalMouseTracking(TRUE) must have a corresponding setGlobalMouseTracking(FALSE):
.PP
.nf
.br
    // at this point global mouse tracking is off
.br
    QApplication::setGlobalMouseTracking( TRUE );
.br
    QApplication::setGlobalMouseTracking( TRUE );
.br
    QApplication::setGlobalMouseTracking( FALSE );
.br
    // at this point it's still on
.br
    QApplication::setGlobalMouseTracking( FALSE );
.br
    // but now it's off
.fi
.PP
See also hasGlobalMouseTracking() and QWidget::hasMouseTracking().
.SH "void QApplication::setGlobalStrut ( const QSize & strut ) \fC[static]\fR"
Sets the application strut to \fIstrut.\fR No GUI-element that can be interacted with should be smaller than the provided size. This should be considered when reimplementing items that may be used on touch-screens or with similar IO-devices.
.PP
Example:
.PP
.nf
.br
  QSize& WidgetClass::sizeHint() const
.br
  {
.br
      return QSize( 80, 25 ).expandedTo( QApplication::globalStrut() );
.br
  }
.fi
.PP
See also golbalStrut().
.SH "void QApplication::setMainWidget ( QWidget * mainWidget ) \fC[virtual]\fR"
Sets the main widget of the application.
.PP
The main widget is like any other, in most respects except that if it is deleted, the application exits.
.PP
You need not have a main widget; connecting lastWindowClosed() to quit() is another alternative.
.PP
For X11, this function also resizes and moves the main widget according to the \fI-geometry\fR command-line option, so you should set the default geometry (using QWidget::setGeometry()) before calling setMainWidget().
.PP
See also mainWidget(), exec() and quit().
.PP
Examples:
.(l
rangecontrols/main.cpp iconview/main.cpp validator/main.cpp themes/main.cpp listviews/main.cpp aclock/main.cpp checklists/main.cpp drawlines/connect.cpp dclock/main.cpp mainlyQt/editor.cpp xform/xform.cpp cursor/cursor.cpp layout/layout.cpp buttongroups/main.cpp life/main.cpp i18n/main.cpp drawdemo/drawdemo.cpp lineedits/main.cpp popup/popup.cpp fileiconview/main.cpp listbox/main.cpp menu/menu.cpp progress/progress.cpp scribble/main.cpp qmag/qmag.cpp tabdialog/main.cpp splitter/splitter.cpp progressbar/main.cpp tooltip/main.cpp richtext/main.cpp forever/forever.cpp rot13/rot13.cpp xml/tagreader
.)l-with-features/tagreader.cpp
qfd/qfd.cpp addressbook/main.cpp picture/picture.cpp hello/main.cpp listboxcombo/main.cpp biff/main.cpp tictac/main.cpp customlayout/main.cpp dirview/main.cpp
.SH "void QApplication::setOverrideCursor ( const QCursor & cursor, bool replace=FALSE ) \fC[static]\fR"
Sets the application override cursor to \fIcursor.\fR
.PP
Application override cursors are intended for showing the user that the application is in a special state, for example during an operation that might take some time.
.PP
This cursor will be displayed in all the widgets of the application until restoreOverrideCursor() or another setOverrideCursor() is called.
.PP
Application cursors are stored on an internal stack. setOverrideCursor() pushes the cursor onto the stack, and restoreOverrideCursor() pops the active cursor off the stack. Every setOverrideCursor() must eventually be followed by a corresponding restoreOverrideCursor(), otherwise the stack will never be emptied.
.PP
If \fIreplace\fR is TRUE, the new cursor will replace the last override cursor (the stack keeps its depth). If \fIreplace\fR is FALSE, the new stack is pushed onto the top of the stack.
.PP
Example:
.PP
.nf
.br
    QApplication::setOverrideCursor( Qt::waitCursor );
.br
    calculateHugeMandelbrot();                  // lunch time...
.br
    QApplication::restoreOverrideCursor();
.fi
.PP
See also overrideCursor(), restoreOverrideCursor() and QWidget::setCursor().
.SH "void QApplication::setPalette ( const QPalette & palette, bool informWidgets=FALSE, const char * className = 0 ) \fC[static]\fR"
Changes the default application palette to \fIpalette.\fR If \fIinformWidgets\fR is TRUE, then existing widgets are informed about the change and thus may adjust themselves to the new application setting. Otherwise the change only affects newly created widgets. If \fIclassName\fR is passed, the change applies only to classes that inherit \fIclassName\fR (as reported by QObject::inherits()).
.PP
The palette may be changed according to the current GUI style in QStyle::polish().
.PP
See also QWidget::setPalette(), palette() and QStyle::polish().
.SH "void QApplication::setStartDragDistance ( int l ) \fC[static]\fR"
Sets the distance after which a drag should start.
.PP
See also startDragDistance().
.SH "void QApplication::setStartDragTime ( int ms ) \fC[static]\fR"
Sets the time after which a drag should start.
.PP
See also startDragTime().
.SH "void QApplication::setStyle ( QStyle * style ) \fC[static]\fR"
Sets the application GUI style to \fIstyle.\fR Ownership of the style object is transferred to QApplication, so QApplication will delete the style object on application exit or when a new style is set.
.PP
Example usage:
.PP
.nf
.br
    QApplication::setStyle( new QWindowStyle );
.fi
.PP
When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.
.PP
See also style(), QStyle, setPalette() and desktopSettingsAware().
.SH "void QApplication::setWheelScrollLines ( int n ) \fC[static]\fR"
Sets the number of lines to scroll when the mouse wheel is rotated.
.PP
If this number exceeds the number of visible lines in a certain widget, the widget should interpret the scroll operation as a single page up / page down operation instead.
.PP
See also wheelScrollLines().
.SH "void QApplication::setWinStyleHighlightColor ( const QColor & c ) \fC[static]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Sets the color used to mark selections in windows style for all widgets in the application. Will repaint all widgets if the color is changed.
.PP
The default color is \fCdarkBlue.\fR
.PP
See also winStyleHighlightColor().
.SH "int QApplication::startDragDistance () \fC[static]\fR"
If you support drag'n'drop in you application and a drag should start after a mouse click and after moving the mouse a certain distance, you should use the value which this method returns as the distance. So if the mouse position of the click is stored in \fCstartPos\fR and the current position (e.g. in the mouse move event) is \fCcurrPos,\fR you can find out if a drag should be started with a code like this:
.PP
.nf
.br
  if ( ( startPos - currPos ).manhattanLength() > QApplication::startDragDistance() )
.br
      startTheDrag();
.fi
.PP
Qt internally uses this value too, e.g. in the QFileDialog.
.PP
The default value is set to 4 pixels.
.PP
See also setStartDragDistance(), startDragTime() and QPoint::manhattanLength().
.SH "int QApplication::startDragTime () \fC[static]\fR"
If you support drag'n'drop in you application and a drag should start after a mouse click and after a certain time elapsed, you should use the value which this method returns as delay (in ms).
.PP
Qt internally uses also this delay e.g. in QMultiLineEdit for starting a drag.
.PP
The default value is set to 500 ms.
.PP
See also setStartDragTime() and startDragDistance().
.SH "bool QApplication::startingUp () \fC[static]\fR"
Returns TRUE if an application object has not been created yet.
.PP
See also closingDown().
.SH "QStyle& QApplication::style () \fC[static]\fR"
Returns the style object of the application.
.PP
See also setStyle() and QStyle.
.SH "void QApplication::syncX () \fC[static]\fR"
Synchronizes with the X server in the X11 implementation. This normally takes some time. Does nothing on other platforms.
.PP
See also flushX().
.SH "QWidgetList * QApplication::topLevelWidgets () \fC[static]\fR"
Returns a list of the top level widgets in the application.
.PP
The list is created using \fCnew\fR and must be deleted by the caller.
.PP
The list is empty (QList::isEmpty()) if there are no top level widgets.
.PP
Note that some of the top level widgets may be hidden, for example the tooltip if no tooltip is currently shown.
.PP
Example:
.PP
.nf
.br
    //
.br
    // Shows all hidden top level widgets.
.br
    //
.br
    QWidgetList  *list = QApplication::topLevelWidgets();
.br
    QWidgetListIt it( *list );  // iterate over the widgets
.br
    QWidget * w;
.br
    while ( (w=it.current()) != 0 ) {   // for each top level widget...
.br
        ++it;
.br
        if ( !w->isVisible() )
.br
            w->show();
.br
    }
.br
    delete list;                // delete the list, not the widgets
.fi
.PP
\fBWarning:\fR Delete the list away as soon you have finished using it. The widgets in the list may be deleted by someone else at any time.
.PP
See also allWidgets(), QWidget::isTopLevel(), QWidget::isVisible() and QList::isEmpty().
.SH "QString QApplication::translate ( const char * scope, const char * key, const char * comment ) const"
Returns the translation text for \fIkey,\fR by querying the installed messages files. The message file that was installed last is asked first.
.PP
QObject::tr() offers a more convenient way to use this functionality.
.PP
\fIcontext\fR is typically a class name (e.g. \fCMyDialog)\fR and \fIkey\fR is either English text or a short marker text, if the output text will be very long (as for help texts).
.PP
\fIcomment\fR is a disambiguating comment, for when the same text is used in different roles within one context.
.PP
See the QTranslator documentation for more information about keys, contexts and comments.
.PP
If none of the message files contain a translation for \fIkey\fR in \fIscope,\fR this function returns \fIkey.\fR
.PP
This function is not virtual, but you can add alternative translation techniques by installing subclasses of QTranslator.
.PP
See also QObject::tr(), installTranslator(), removeTranslator() and QTranslator.
.SH "QString QApplication::translate ( const char * context, const char * key ) const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version of the function uses "" as comment.
.SH "void QApplication::unlock ( bool wakeUpGui = TRUE )"
Unlock the Qt library mutex. if \fIwakeUpGui\fR is TRUE (default argument), then the GUI thread will be woken with QApplication::wakeUpGuiThread().
.PP
See also lock() and locked().
.SH "void QApplication::wakeUpGuiThread ()"
Wakes up the GUI thread.
.PP
See also guiThreadAwake().
.SH "int QApplication::wheelScrollLines () \fC[static]\fR"
Returns the number of lines to scroll when the mouse wheel is rotated.
.PP
See also setWheelScrollLines().
.SH "QWidget * QApplication::widgetAt ( int x, int y, bool child=FALSE ) \fC[static]\fR"
Returns a pointer to the widget at global screen position \fI(x,y),\fR or a null pointer if there is no Qt widget there.
.PP
If \fIchild\fR is FALSE and there is a child widget at position \fI(x,y),\fR the top-level widget containing it is returned. If \fIchild\fR is TRUE the child widget at position \fI(x,y)\fR is returned.
.PP
This function is normally rather slow.
.PP
See also QCursor::pos(), QWidget::grabMouse() and QWidget::grabKeyboard().
.SH "QWidget * QApplication::widgetAt ( const QPoint & pos, bool child=FALSE ) \fC[static]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "const QColor& QApplication::winStyleHighlightColor () \fC[static]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Returns the color used to mark selections in windows style.
.PP
See also setWinStyleHighlightColor().
.SH RELATED FUNCTION DOCUMENTATION
.SH "void qFatal (const char * msg, ...)"
Prints a fatal error message and exits, or calls the message handler (if it has been installed).
.PP
This function takes a format string and a list of arguments, similar to the C printf() function.
.PP
Example:
.PP
.nf
.br
    int divide( int a, int b )
.br
    {
.br
        if ( b == 0 )                           // program error
.br
            qFatal( "divide: cannot divide by zero" );
.br
        return a/b;
.br
    }
.fi
.PP
Under X11, the text is printed to stderr. Under Windows, the text is sent to the debugger.
.PP
\fBWarning:\fR The internal buffer is limited to 8196 bytes (including the 0-terminator).
.PP
See also qDebug(), qWarning(), qInstallMsgHandler() and Debugging
.SH "void qWarning (const char * msg, ...)"
Prints a warning message, or calls the message handler (if it has been installed).
.PP
This function takes a format string and a list of arguments, similar to the C printf() function.
.PP
Example:
.PP
.nf
.br
    void f( int c )
.br
    {
.br
        if ( c > 200 )
.br
            qWarning( "f: bad argument, c == %d", c );
.br
    }
.fi
.PP
Under X11, the text is printed to stderr. Under Windows, the text is sent to the debugger.
.PP
\fBWarning:\fR The internal buffer is limited to 8196 bytes (including the 0-terminator).
.PP
See also qDebug(), qFatal(), qInstallMsgHandler() and Debugging
.PP
Examples:
.(l
life/main.cpp progress/progress.cpp tictac/main.cpp
.)l
.SH "const char * qVersion ()"
Returns the Qt version number for the library, typically "1.30" or "2.1.0".
.SH "void qAddPostRoutine (Q_CleanUpFunction p)"
Adds a global routine that will be called from the QApplication destructor. This function is normally used to add cleanup routines for program-wide functionality.
.PP
The function given by \fIp\fR should take no arguments and return nothing, like this:
.PP
.nf
.br
    static int *global_ptr = 0;
.br
.br
    static void cleanup_ptr()
.br
    {
.br
        delete [] global_ptr;
.br
        global_ptr = 0;
.br
    }
.br
.br
    void init_ptr()
.br
    {
.br
        global_ptr = new int[100];      // allocate data
.br
        qAddPostRoutine( cleanup_ptr ); // delete later
.br
    }
.fi
.PP
Note that for an application- or module-wide cleanup, qAddPostRoutine() is often not suitable. People have a tendency to make such modules dynamically loaded, and then unload those modules long before the QApplication destructor is called, for example.
.PP
For modules and libraries, using a reference-counted initialization manager or Qt' parent-child delete mechanism may be better. Here is an example of a private class which uses the parent-child mechanism to call a cleanup function at the right time:
.PP
.nf
.br
    class MyPrivateInitStuff: public QObject {
.br
    private:
.br
        MyPrivateInitStuff( QObject * parent ): QObject( parent) {
.br
            // initialization goes here
.br
        }
.br
        MyPrivateInitStuff * p;
.br
.br
    public:
.br
        static MyPrivateInitStuff * initStuff( QObject * parent ) {
.br
            if ( !p )
.br
                p = new MyPrivateInitStuff( parent );
.br
            return p;
.br
        }
.br
.br
        ~MyPrivateInitStuff() {
.br
            // cleanup (the "post routine") goes here
.br
        }
.br
    }
.fi
.PP
By selecting the right parent widget/object, this can often be made to clean up the module's data at the exact right moment.
.SH "void ASSERT (bool test)"
Prints a warning message containing the source code file name and line number if \fItest\fR is FALSE.
.PP
This is really a macro defined in qglobal.h.
.PP
ASSERT is useful for testing required conditions in your program.
.PP
Example:
.PP
.nf
.br
    //
.br
    // File: div.cpp
.br
    //
.br
.br
    #include <qglobal.h>
.br
.br
    int divide( int a, int b )
.br
    {
.br
        ASSERT( b != 0 );                       // this is line 9
.br
        return a/b;
.br
    }
.fi
.PP
If \fCb\fR is zero, the ASSERT statement will output the following message using the qWarning() function:
.PP
.nf
.br
    ASSERT: "b == 0" in div.cpp (9)
.fi
.PP
See also qWarning() and Debugging
.SH "void qDebug (const char * msg, ...)"
Prints a debug message, or calls the message handler (if it has been installed).
.PP
This function takes a format string and a list of arguments, similar to the C printf() function.
.PP
Example:
.PP
.nf
.br
    qDebug( "my window handle = %x", myWidget->id() );
.fi
.PP
Under X11, the text is printed to stderr. Under Windows, the text is sent to the debugger.
.PP
\fBWarning:\fR The internal buffer is limited to 8196 bytes (including the 0-terminator).
.PP
See also qWarning(), qFatal(), qInstallMsgHandler() and Debugging
.SH "bool qSysInfo (int * wordSize, bool * bigEndian)"
Obtains information about the system.
.PP
The system's word size in bits (typically 32) is returned in \fI*wordSize.\fR The \fI*bigEndian\fR is set to TRUE if this is a big-endian machine, or to FALSE if this is a little-endian machine.
.PP
This function calls qFatal() with a message if the computer is truly weird (i.e. different endianness for 16 bit and 32 bit integers).
.SH "void CHECK_PTR (void * p)"
If \fIp\fR is null, a fatal messages says that the program ran out of memory and exits. If \fIp\fR is not null, nothing happens.
.PP
This is really a macro defined in qglobal.h.
.PP
Example:
.PP
.nf
.br
    int *a;
.br
    CHECK_PTR( a = new int[80] );       // never do this!
.br
      // do this instead:
.br
    a = new int[80];
.br
    CHECK_PTR( a );                     // this is fine
.fi
.PP
See also qFatal() and Debugging
.SH "msg_handler qInstallMsgHandler (msg_handler h)"
Installs a Qt message handler. Returns a pointer to the message handler previously defined.
.PP
The message handler is a function that prints out debug messages, warnings and fatal error messages. The Qt library (debug version) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. If you implement your own message handler, you get total control of these messages.
.PP
The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.
.PP
Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.
.PP
To restore the message handler, call \fCqInstallMsgHandler(0).\fR
.PP
Example:
.PP
.nf
.br
    #include <qapplication.h>
.br
    #include <stdio.h>
.br
    #include <stdlib.h>
.br
.br
    void myMessageOutput( QtMsgType type, const char *msg )
.br
    {
.br
        switch ( type ) {
.br
            case QtDebugMsg:
.br
                fprintf( stderr, "Debug: %s\\n", msg );
.br
                break;
.br
            case QtWarningMsg:
.br
                fprintf( stderr, "Warning: %s\\n", msg );
.br
                break;
.br
            case QtFatalMsg:
.br
                fprintf( stderr, "Fatal: %s\\n", msg );
.br
                abort();                        // dump core on purpose
.br
        }
.br
    }
.br
.br
    int main( int argc, char **argv )
.br
    {
.br
        qInstallMsgHandler( myMessageOutput );
.br
        QApplication a( argc, argv );
.br
        ...
.br
        return a.exec();
.br
    }
.fi
.PP
See also  qDebug(), qWarning(), qFatal() and Debugging
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qapplication.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qapplication.3qt) and the Qt
version (2.3.2).
