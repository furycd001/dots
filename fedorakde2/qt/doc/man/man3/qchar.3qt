'\" t
.TH QChar 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QChar \- Light-weight Unicode character
.br
.PP
\fC#include <qstring.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQChar\fR () "
.br
.ti -1c
.BI "\fBQChar\fR ( char c ) "
.br
.ti -1c
.BI "\fBQChar\fR ( uchar c ) "
.br
.ti -1c
.BI "\fBQChar\fR ( uchar " "c" ", uchar r ) "
.br
.ti -1c
.BI "\fBQChar\fR ( const QChar & c ) "
.br
.ti -1c
.BI "\fBQChar\fR ( ushort rc ) "
.br
.ti -1c
.BI "\fBQChar\fR ( short rc ) "
.br
.ti -1c
.BI "\fBQChar\fR ( uint rc ) "
.br
.ti -1c
.BI "\fBQChar\fR ( int rc ) "
.br
.ti -1c
.BI "enum \fBCategory\fR { NoCategory, Mark_NonSpacing, Mark_SpacingCombining, Mark_Enclosing, Number_DecimalDigit, Number_Letter, Number_Other, Separator_Space, Separator_Line, Separator_Paragraph, Other_Control, Other_Format, Other_Surrogate, Other_PrivateUse, Other_NotAssigned, Letter_Uppercase, Letter_Lowercase, Letter_Titlecase, Letter_Modifier, Letter_Other, Punctuation_Connector, Punctuation_Dask, Punctuation_Open, Punctuation_Close, Punctuation_InitialQuote, Punctuation_FinalQuote, Punctuation_Other, Symbol_Math, Symbol_Currency, Symbol_Modifier, Symbol_Other }"
.br
.ti -1c
.BI "enum \fBDirection\fR { DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON, DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN }"
.br
.ti -1c
.BI "enum \fBDecomposition\fR { Single, Canonical, Font, NoBreak, Initial, Medial, Final, Isolated, Circle, Super, Sub, Vertical, Wide, Narrow, Small, Square, Compat, Fraction }"
.br
.ti -1c
.BI "enum \fBJoining\fR { OtherJoining, Dual, Right, Center }"
.br
.ti -1c
.BI "int \fBdigitValue\fR () const"
.br
.ti -1c
.BI "QChar \fBlower\fR () const"
.br
.ti -1c
.BI "QChar \fBupper\fR () const"
.br
.ti -1c
.BI "Category \fBcategory\fR () const"
.br
.ti -1c
.BI "Direction \fBdirection\fR () const"
.br
.ti -1c
.BI "Joining \fBjoining\fR () const"
.br
.ti -1c
.BI "bool \fBmirrored\fR () const"
.br
.ti -1c
.BI "QChar \fBmirroredChar\fR () const"
.br
.ti -1c
.BI "QString \fBdecomposition\fR () const"
.br
.ti -1c
.BI "Decomposition \fBdecompositionTag\fR () const"
.br
.ti -1c
.BI "char \fBlatin1\fR () const"
.br
.ti -1c
.BI "ushort \fBunicode\fR () const"
.br
.ti -1c
.BI "operator \fBchar\fR ()const"
.br
.ti -1c
.BI "bool \fBisNull\fR () const"
.br
.ti -1c
.BI "bool \fBisPrint\fR () const"
.br
.ti -1c
.BI "bool \fBisPunct\fR () const"
.br
.ti -1c
.BI "bool \fBisSpace\fR () const"
.br
.ti -1c
.BI "bool \fBisMark\fR () const"
.br
.ti -1c
.BI "bool \fBisLetter\fR () const"
.br
.ti -1c
.BI "bool \fBisNumber\fR () const"
.br
.ti -1c
.BI "bool \fBisLetterOrNumber\fR () const"
.br
.ti -1c
.BI "bool \fBisDigit\fR () const"
.br
.ti -1c
.BI "uchar& \fBcell\fR () "
.br
.ti -1c
.BI "uchar& \fBrow\fR () "
.br
.ti -1c
.BI "uchar \fBcell\fR () const"
.br
.ti -1c
.BI "uchar \fBrow\fR () const"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "bool \fBnetworkOrdered\fR () "
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
(Note that these are not member functions.)
.in +1c
.ti -1c
.BI "int \fBoperator>=\fR (QChar " "c1" ", QChar " "c2" ")"
.br
.ti -1c
.BI "int \fBoperator>\fR (QChar " "c1" ", QChar " "c2" ")"
.br
.ti -1c
.BI "int \fBoperator==\fR (QChar " "c1" ", QChar " "c2" ")"
.br
.ti -1c
.BI "int \fBoperator<\fR (char " "ch" ", QChar " "c" ")"
.br
.ti -1c
.BI "int \fBoperator>=\fR (char " "ch" ", QChar " "c" ")"
.br
.ti -1c
.BI "int \fBoperator==\fR (char " "ch" ", QChar " "c" ")"
.br
.ti -1c
.BI "int \fBoperator!=\fR (QChar " "c" ", char " "ch" ")"
.br
.ti -1c
.BI "int \fBoperator==\fR (QChar " "c" ", char " "ch" ")"
.br
.ti -1c
.BI "int \fBoperator<=\fR (QChar " "c1" ", QChar " "c2" ")"
.br
.ti -1c
.BI "int \fBoperator<=\fR (char " "ch" ", QChar " "c" ")"
.br
.ti -1c
.BI "int \fBoperator>=\fR (QChar " "c" ", char " "ch" ")"
.br
.ti -1c
.BI "int \fBoperator!=\fR (char " "ch" ", QChar " "c" ")"
.br
.ti -1c
.BI "int \fBoperator<=\fR (QChar " "c" ", char " "ch" ")"
.br
.ti -1c
.BI "int \fBoperator>\fR (char " "ch" ", QChar " "c" ")"
.br
.ti -1c
.BI "int \fBoperator<\fR (QChar " "c1" ", QChar " "c2" ")"
.br
.ti -1c
.BI "int \fBoperator<\fR (QChar " "c" ", char " "ch" ")"
.br
.ti -1c
.BI "int \fBoperator>\fR (QChar " "c" ", char " "ch" ")"
.br
.ti -1c
.BI "int \fBoperator!=\fR (QChar " "c1" ", QChar " "c2" ")"
.br
.in -1c
.SH DESCRIPTION
The QChar class provides a light-weight Unicode character.
.PP
Unicode characters are (so far) 16-bit entities without any markup or structure. This class represents such an entity. It is rather light-weight, so it can be used everywhere. Most compilers treat it approximately like "short int". (In a few years, it may be necessary to make QChar 32-bit, once more than 65536 Unicode code points have been defined and come into use.)
.PP
QChar provides a full complement of testing/classification functions, conversion to and from other formats, from composed to decomposed unicode, and will try to compare and case-convert if you ask it to.
.PP
The classification functions include functions like those in ctype.h, but operating on the full range of unicode characters. They all return TRUE if the character is a certain type of character, and FALSE otherwise.
.PP
These functions are: isNull() (returns TRUE if the character is U+0000), isPrint() (TRUE if the character is any sort of printable character, including whitespace), isPunct() (any sort of punctation), isMark() (Unicode Marks), isLetter (letters), isNumber() (any sort of numeric characters), isLetterOrNumber(), and isDigit() (decimal digits). All of these are wrappers around category(), which returns the unicode-defined category of each character.
.PP
QChar further provides direction(), which indicates the "natural" writing direction of this character, joining(), which indicates how this character joins with its neighbors (needed mostly for Arabic) and finally mirrored(), which indicates whether this character needs to be mirrored when it is printed in its unnatural writing direction.
.PP
Composed Unicode characters (like &aring;) can be converted to decomposed Unicode ("a" followed by "ring above") using decomposition().
.PP
In Unicode, comparison is not necessarily possible, and case conversion is at best very hard. Unicode, covering the "entire" globe, also includes a globe-sized collection of case and sorting problems. Qt tries, but not very hard: operator== and friends will do comparison based purely on the numeric Unicode value (code point) of the characters, and upper() and lower() will do case changes when the character has a well-defined upper/lower-case equivalent. There is no provision for locale-dependent case folding rules or comparison: These functions are meant to be fast, so they can be used unambiguously in data structures.
.PP
The conversion functions include unicode() (to a scalar), latin1() (to scalar, but converts all non-Latin1 characters to 0), row() (gives the Unicode row), cell() (gives the unicode cell), digitValue() (gives the integer value of any of the numerous digit characters), and a host of constructors.
.PP
See also QString, QCharRef and About Unicode
.SS "Member Type Documentation"
.SH "QChar::Category"
This enum maps the Unicode character categories. The currently known categories are: 
.TP
\fCNoCategory\fR - used when Qt is dazed and confused and cannot make sense of anything.
.TP
\fCMark_NonSpacing\fR - (Mn) -
.TP
\fCMark_SpacingCombining\fR - (Mc) -
.TP
\fCMark_Enclosing\fR - (Me) -
.TP
\fCNumber_DecimalDigit\fR - (Nd) -
.TP
\fCNumber_Letter\fR - (Nl) -
.TP
\fCNumber_Other\fR - (No) -
.TP
\fCSeparator_Space\fR - (Zs) -
.TP
\fCSeparator_Line\fR - (Zl) -
.TP
\fCSeparator_Paragraph\fR - (Zp) -
.TP
\fCOther_Control\fR - (Cc) -
.TP
\fCOther_Format\fR - (Cf) -
.TP
\fCOther_Surrogate\fR - (Cs) -
.TP
\fCOther_PrivateUse\fR - (Co) -
.TP
\fCOther_NotAssigned\fR - (Cn) -
.TP
\fCLetter_Uppercase\fR - (Lu) -
.TP
\fCLetter_Lowercase\fR - (Ll) -
.TP
\fCLetter_Titlecase\fR - (Lt) -
.TP
\fCLetter_Modifier\fR - (Lm) -
.TP
\fCLetter_Other\fR - (Lo) -
.TP
\fCPunctuation_Connector\fR - (Pc) -
.TP
\fCPunctuation_Dask\fR - (Pd) -
.TP
\fCPunctuation_Open\fR - (Ps) -
.TP
\fCPunctuation_Close\fR - (Pe) -
.TP
\fCPunctuation_InitialQuote\fR - (Pi) -
.TP
\fCPunctuation_FinalQuote\fR - (Pf) -
.TP
\fCPunctuation_Other\fR - (Po) -
.TP
\fCSymbol_Math\fR - (Sm) -
.TP
\fCSymbol_Currency\fR - (Sc) -
.TP
\fCSymbol_Modifier\fR - (Sk) -
.TP
\fCSymbol_Other\fR - (So) -
.IP
.SH "QChar::Decomposition"
This enum type defines the Unicode decomposition attributes. See the Unicode Standard for a description of the values.
.SH "QChar::Direction"
This enum type defines the Unicode direction attributes. See the Unicode Standard for a description of the values.
.PP
In order to conform to C/C++ naming conventions "Dir" is prepended to the codes used in The Unicode Standard.
.SH "QChar::Joining"
This enum type defines the Unicode decomposition attributes. See the Unicode Standard for a description of the values.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QChar::QChar ()"
Constructs a null QChar (one that isNull()).
.SH "QChar::QChar ( char c )"
Constructs a QChar corresponding to ASCII/Latin1 character \fIc.\fR
.SH "QChar::QChar ( const QChar & c )"
Constructs a copy of \fIc.\fR This is a deep copy, if such a light-weight object can be said to have deep copies.
.SH "QChar::QChar ( int rc )"
Constructs a QChar for the character with Unicode code point \fIrc.\fR
.SH "QChar::QChar ( short rc )"
Constructs a QChar for the character with Unicode code point \fIrc.\fR
.SH "QChar::QChar ( uchar c )"
Constructs a QChar corresponding to ASCII/Latin1 character \fIc.\fR
.SH "QChar::QChar ( uchar c, uchar r )"
Constructs a QChar for Unicode cell \fIc\fR in row \fIr.\fR
.SH "QChar::QChar ( uint rc )"
Constructs a QChar for the character with Unicode code point \fIrc.\fR
.SH "QChar::QChar ( ushort rc )"
Constructs a QChar for the character with Unicode code point \fIrc.\fR
.SH "QChar::operator char () const"
Returns the Latin1 character equivalent to the QChar, or 0. This is mainly useful for non-internationalized software.
.PP
See also unicode().
.SH "QChar::Category QChar::category() const"
Returns the character category.
.PP
See also Category.
.SH "uchar QChar::cell () const"
Returns the cell (least significant byte) of the Unicode character.
.SH "uchar& QChar::cell ()"
Returns a reference to the cell (least significant byte) of the Unicode character.
.SH "QString QChar::decomposition () const"
Decomposes a character into its parts. Returns QString::null if no decomposition exists.
.SH "QChar::Decomposition QChar::decompositionTag() const"
Returns the tag defining the composition of the character. Returns QChar::Single if no decomposition exists.
.SH "int QChar::digitValue () const"
Returns the numeric value of the digit, or -1 if the character is not a digit.
.SH "QChar::Direction QChar::direction() const"
Returns the characters directionality.
.PP
See also Direction.
.SH "bool QChar::isDigit () const"
Returns whether the character is a decimal digit (Number_DecimalDigit).
.SH "bool QChar::isLetter () const"
Returns whether the character is a letter (Letter_* categories).
.SH "bool QChar::isLetterOrNumber () const"
Returns whether the character is a letter or number (Letter_* or Number_* categories).
.SH "bool QChar::isMark () const"
Returns whether the character is a mark (Mark_* categories).
.SH "bool QChar::isNull () const"
Returns TRUE if the characters is the unicode character 0x0000, ie. ASCII NUL.
.SH "bool QChar::isNumber () const"
Returns whether the character is a number (of any sort - Number_* categories).
.PP
See also isDigit().
.SH "bool QChar::isPrint () const"
Returns whether the character is a printable character. This is any character not of category Cc or Cn. Note that this gives no indication of whether the character is available in some font.
.SH "bool QChar::isPunct () const"
Returns whether the character is punctuation (Punctuation_* categories).
.SH "bool QChar::isSpace () const"
Returns whether the character is a separator character (Separator_* categories).
.SH "QChar::Joining QChar::joining() const"
This function is not supported (it may change to use Unicode character classes).
.PP
Returns information about the joining properties of the character (needed for arabic).
.SH "char QChar::latin1 () const"
Returns a latin-1 copy of this character, if this character is in the latin-1 character set. If not, this function returns 0.
.SH "QChar QChar::lower () const"
Returns the lowercase equivalent if the character is uppercase, or the character itself otherwise.
.SH "bool QChar::mirrored () const"
Returns whether the character is a mirrored character (one that should be reversed if the text direction is reversed).
.SH "QChar QChar::mirroredChar () const"
Returns the mirrored char if this character is a mirrored char, the char itself otherwise.
.SH "bool QChar::networkOrdered () \fC[static]\fR"
Returns TRUE if this character is in network byte order (MSB first), and FALSE if it is not. This is a platform-dependent property, so we strongly advise against using this function in portable code.
.SH "uchar QChar::row () const"
Returns the row (most significant byte) of the Unicode character.
.SH "uchar& QChar::row ()"
Returns a reference to the row (most significant byte) of the Unicode character.
.SH "ushort QChar::unicode () const"
Returns the numeric Unicode value equal to the QChar. Normally, you should use QChar objects as they are equivalent, but for some low-level tasks (eg. indexing into an array of Unicode information), this function is useful.
.SH "QChar QChar::upper () const"
Returns the uppercase equivalent if the character is lowercase, or the character itself otherwise.
.SH RELATED FUNCTION DOCUMENTATION
.SH "int operator>= (QChar c1, QChar c2)"
Returns TRUE if the numeric Unicode value of \fIc1\fR is greater than that of \fIc2,\fR or they are the same Unicode character.
.SH "int operator> (QChar c1, QChar c2)"
Returns TRUE if the numeric Unicode value of \fIc1\fR is greater than that of \fIc2.\fR
.SH "int operator== (QChar c1, QChar c2)"
Returns TRUE if \fIc1\fR and \fIc2\fR are the same Unicode character.
.SH "int operator< (char ch, QChar c)"
Returns TRUE if the numeric Unicode value of the ASCII/Latin1 character \fIch\fR is less than that of \fIc.\fR
.SH "int operator>= (char ch, QChar c)"
Returns TRUE if the numeric Unicode value of the ASCII/Latin1 character \fIch\fR is greater than or equal to that of \fIc.\fR
.SH "int operator== (char ch, QChar c)"
Returns TRUE if \fIc\fR is the ASCII/Latin1 character \fIch.\fR
.SH "int operator!= (QChar c, char ch)"
Returns TRUE if \fIc\fR is not the ASCII/Latin1 character \fIch.\fR
.SH "int operator== (QChar c, char ch)"
Returns TRUE if \fIc\fR is the ASCII/Latin1 character \fIch.\fR
.SH "int operator<= (QChar c1, QChar c2)"
Returns TRUE if the numeric Unicode value of \fIc1\fR is less than that of \fIc2,\fR or they are the same Unicode character.
.SH "int operator<= (char ch, QChar c)"
Returns TRUE if the numeric Unicode value of the ASCII/Latin1 character \fIch\fR is less than or equal to that of \fIc.\fR
.SH "int operator>= (QChar c, char ch)"
Returns TRUE if the numeric Unicode value of \fIc\fR is greater than or equal to that of the ASCII/Latin1 character \fIch.\fR
.SH "int operator!= (char ch, QChar c)"
Returns TRUE if \fIc\fR is not the ASCII/Latin1 character \fIch.\fR
.SH "int operator<= (QChar c, char ch)"
Returns TRUE if the numeric Unicode value of \fIc\fR is less than or equal to that of the ASCII/Latin1 character \fIch.\fR
.SH "int operator> (char ch, QChar c)"
Returns TRUE if the numeric Unicode value of the ASCII/Latin1 character \fIch\fR is greater than that of \fIc.\fR
.SH "int operator< (QChar c1, QChar c2)"
Returns TRUE if the numeric Unicode value of \fIc1\fR is less than that of \fIc2.\fR
.SH "int operator< (QChar c, char ch)"
Returns TRUE if the numeric Unicode value of \fIc\fR is less than that of the ASCII/Latin1 character \fIch.\fR
.SH "int operator> (QChar c, char ch)"
Returns TRUE if the numeric Unicode value of \fIc\fR is greater than that of the ASCII/Latin1 character \fIch.\fR
.SH "int operator!= (QChar c1, QChar c2)"
Returns TRUE if \fIc1\fR and \fIc2\fR are not the same Unicode character.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qchar.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qchar.3qt) and the Qt
version (2.3.2).
