'\" t
.TH QComboBox 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QComboBox \- Combined button and popup list
.br
.PP
\fC#include <qcombobox.h>\fR
.PP
Inherits QWidget.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQComboBox\fR ( QWidget * " "parent" "=0, const char * " "name" "=0 ) "
.br
.ti -1c
.BI "\fBQComboBox\fR ( bool " "rw" ", QWidget * " "parent" "=0, const char * " "name" "=0 ) "
.br
.ti -1c
.BI "\fB~QComboBox\fR () "
.br
.ti -1c
.BI "int \fBcount\fR () const"
.br
.ti -1c
.BI "void \fBinsertStringList\fR ( const QStringList &, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertStrList\fR ( const QStrList &, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertStrList\fR ( const QStrList *, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertStrList\fR ( const char **, int " "numStrings" "=-1, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QString & " "text" ", int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QPixmap & " "pixmap" ", int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QPixmap & " "pixmap" ", const QString & " "text" ", int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBremoveItem\fR ( int index ) "
.br
.ti -1c
.BI "void \fBclear\fR () "
.br
.ti -1c
.BI "QString \fBcurrentText\fR () const"
.br
.ti -1c
.BI "QString \fBtext\fR ( int index ) const"
.br
.ti -1c
.BI "const QPixmap* \fBpixmap\fR ( int index ) const"
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QString & " "text" ", int index ) "
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QPixmap & " "pixmap" ", int index ) "
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QPixmap & " "pixmap" ", const QString & " "text" ", int index ) "
.br
.ti -1c
.BI "int \fBcurrentItem\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCurrentItem\fR ( int index ) "
.br
.ti -1c
.BI "bool autoResize () const \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void setAutoResize ( bool ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void \fBsetBackgroundColor\fR ( const QColor & ) "
.br
.ti -1c
.BI "virtual void \fBsetPalette\fR ( const QPalette & ) "
.br
.ti -1c
.BI "virtual void \fBsetFont\fR ( const QFont & ) "
.br
.ti -1c
.BI "virtual void \fBsetSizeLimit\fR ( int ) "
.br
.ti -1c
.BI "int \fBsizeLimit\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMaxCount\fR ( int ) "
.br
.ti -1c
.BI "int \fBmaxCount\fR () const"
.br
.ti -1c
.BI "enum \fBPolicy\fR { NoInsertion, AtTop, AtCurrent, AtBottom, AfterCurrent, BeforeCurrent }"
.br
.ti -1c
.BI "virtual void \fBsetInsertionPolicy\fR ( Policy policy ) "
.br
.ti -1c
.BI "Policy \fBinsertionPolicy\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetValidator\fR ( const QValidator * ) "
.br
.ti -1c
.BI "const QValidator* \fBvalidator\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetListBox\fR ( QListBox * ) "
.br
.ti -1c
.BI "QListBox* \fBlistBox\fR () const"
.br
.ti -1c
.BI "QLineEdit* \fBlineEdit\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetAutoCompletion\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBautoCompletion\fR () const"
.br
.ti -1c
.BI "void \fBsetDuplicatesEnabled\fR ( bool enable ) "
.br
.ti -1c
.BI "bool \fBduplicatesEnabled\fR () const"
.br
.ti -1c
.BI "bool \fBeditable\fR () const"
.br
.ti -1c
.BI "void \fBsetEditable\fR ( bool ) "
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "void \fBclearValidator\fR () "
.br
.ti -1c
.BI "void \fBclearEdit\fR () "
.br
.ti -1c
.BI "virtual void \fBsetEditText\fR ( const QString & ) "
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBactivated\fR ( int index ) "
.br
.ti -1c
.BI "void \fBhighlighted\fR ( int index ) "
.br
.ti -1c
.BI "void \fBactivated\fR ( const QString & ) "
.br
.ti -1c
.BI "void \fBhighlighted\fR ( const QString & ) "
.br
.ti -1c
.BI "void \fBtextChanged\fR ( const QString & ) "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "void \fBpopup\fR () "
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
bool	editable	editable	setEditable
int	count	count
QString	currentText	currentText
int	currentItem	currentItem	setCurrentItem
bool	autoResize	autoResize	setAutoResize
int	sizeLimit	sizeLimit	setSizeLimit
int	maxCount	maxCount	setMaxCount
Policy	insertionPolicy	insertionPolicy	setInsertionPolicy
bool	autoCompletion	autoCompletion	setAutoCompletion
bool	duplicatesEnabled	duplicatesEnabled	setDuplicatesEnabled
.TE
.fi

.SH DESCRIPTION
The QComboBox widget is a combined button and popup list.
.PP
A combo box may be defined as a selection widget which displays the current selection, and which can pop up a list of possible selections. Some combo boxes also allow the user to select arbitrary strings, using a line editor.
.PP
Since combo boxes occupy little screen space and always display the current selection, they are very well suited to displaying and selecting modes (such as font family and size): The user can always see what mode he/she is in, and the majority of the screen space is available for real work.
.PP
QComboBox supports three different appearances: Motif 1.x, Motif 2.0 and Windows 95. In Motif 1.x, a combo box was called XmOptionMenu. In Motif 2.0, OSF introduced an improved combo box and named that XmComboBox. QComboBox provides both.
.PP
QComboBox provides two different constructors. The simplest one creates an old-style combo box in Motif style:
.PP
.nf
.br
      QComboBox * c = new QComboBox( this, "read-only combo" );
.fi
.PP
The other one creates a new-style combo box in Motif style, and can create both read-only and read-write combo boxes:
.PP
.nf
.br
      QComboBox * c1 = new QComboBox( FALSE, this, "read-only combo" );
.br
      QComboBox * c2 = new QComboBox( TRUE, this, "read-write combo" );
.fi
.PP
New-style combo boxes use a list box in both Motif and Windows styles, and both the content size and the on-screen size of the list box can be limited. Old-style combo boxes use a popup in Motif style, and that popup will happily grow larger than the desktop if you put enough data in it.
.PP
The two constructors create identical-looking combos in Windows style.
.PP
Combo boxes can contain pixmaps as well as texts; the insert() and changeItem() functions are suitably overloaded. For read-write combo boxes, the function clearEdit() is provided, to clear the displayed string without changing the combo box' contents.
.PP
A combo box emits two signals, activated() and highlighted(), when a new item has been activated (selected) or highlighted (set to current). Both signals exist in two versions, one with a \fCchar*\fR argument and one with an \fCint\fR argument. If the user highlights or activates a pixmap, only the \fCint\fR signals are emitted.
.PP
When the user enters a new string in a read-write combo, the widget may or may not insert it, and it can insert it in several locations. The default policy is is \fCAtBottom,\fR you can change it using setInsertionPolicy().
.PP
It is possible to constrain the input to an editable combo box using QValidator; see setValidator(). By default, all input is accepted.
.PP
If the combo box is not editable then it has a default focusPolicy() of \fCTabFocus,\fR i.e. it will not grab focus if clicked. This differs from both Windows and Motif. If the combo box is editable then it has a default focusPolicy() of \fCStrongFocus,\fR i.e. it will grab focus if clicked.
.PP
.ce 1
.B "[Image Omitted]"
.PP
(Motif 1, read-only)
.br
.ce 1
.B "[Image Omitted]"
.PP
(Motif 2, read-write)
.br
.ce 1
.B "[Image Omitted]"
.PP
(Motif 2, read-only)
.br
.ce 1
.B "[Image Omitted]"
.PP
(Windows style)
.PP
See also QLineEdit, QListBox, QSpinBox, QRadioButton, QButtonGroup, GUI Design Handbook: Combo Box, and GUI Design Handbook: Drop-Down List Box.
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SS "Member Type Documentation"
.SH "QComboBox::Policy"
This enum type specifies what QComboBox should do with a new string entered by the user. The following policies are defined: 
.TP
\fCNoInsertion\fR means not to insert the string in the combo.
.TP
\fCAtTop\fR means to insert the string at the top of the combo box.
.TP
\fCAtCurrent\fR means to replace the previously selected item with the typed string.
.TP
\fCAtBottom\fR means to insert the string at the bottom of the combo box.
.TP
\fCAfterCurrent\fR means to to insert the string just after the previously selected item.
.TP
\fCBeforeCurrent\fR means to to insert the string just before the previously selected item.
.IP
.PP
activated() is always emitted, of course.
.PP
If inserting the new string would cause the combo box to breach its content size limit, the item at the other end of the list is deleted. The definition of "other end" is implementation-dependent.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QComboBox::QComboBox ( QWidget * parent=0, const char * name=0 )"
Constructs a combo box widget with a parent and a name.
.PP
This constructor creates a popup menu if the program uses Motif look and feel; this is compatible with Motif 1.x.
.SH "QComboBox::QComboBox ( bool rw, QWidget * parent=0, const char * name=0 )"
Constructs a combo box with a maximum size and either Motif 2.0 or Windows look and feel.
.PP
The input field can be edited if \fIrw\fR is TRUE, otherwise the user may only choose one of the items in the combo box.
.SH "QComboBox::~QComboBox ()"
Destructs the combo box.
.SH "void QComboBox::activated ( const QString & string ) \fC[signal]\fR"
This signal is emitted when a new item has been activated (selected). \fIstring\fR is the activated string.
.PP
You can also use activated(int) signal, but be aware that its argument is meaningful only for selected strings, not for typed strings.
.SH "void QComboBox::activated ( int index ) \fC[signal]\fR"
This signal is emitted when a new item has been activated (selected). The \fIindex\fR is the position of the item in the popup list.
.SH "bool QComboBox::autoCompletion () const"
Returns TRUE if this combo box is in auto-completion mode.
.PP
See also setAutoCompletion().
.SH "bool QComboBox::autoResize () const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Returns TRUE if auto-resizing is enabled, or FALSE if auto-resizing is disabled.
.PP
Auto-resizing is disabled by default.
.PP
See also setAutoResize().
.SH "void QComboBox::changeItem ( const QPixmap & im, const QString & t, int index )"
Replaces the item at position \fIindex\fR with a pixmap plus text.
.PP
See also insertItem().
.SH "void QComboBox::changeItem ( const QPixmap & im, int index )"
Replaces the item at position \fIindex\fR with a pixmap, unless the combo box is writable.
.PP
See also insertItem().
.SH "void QComboBox::changeItem ( const QString & t, int index )"
Replaces the item at position \fIindex\fR with a text.
.SH "void QComboBox::clear ()"
Removes all combo box items.
.SH "void QComboBox::clearEdit () \fC[slot]\fR"
Clears the line edit without changing the combo's contents. Does nothing if the combo isn't editable.
.PP
This is particularly handy when using a combo box as a line edit with history. For example you can connect the combo's activated() signal to clearEdit() in order to present the user with a new, empty line as soon as return is pressed.
.PP
See also setEditText().
.SH "void QComboBox::clearValidator () \fC[slot]\fR"
This slot is equivalent to setValidator( 0 ).
.SH "int QComboBox::count () const"
Returns the number of items in the combo box.
.SH "int QComboBox::currentItem () const"
Returns the index of the current combo box item.
.PP
See also setCurrentItem().
.SH "QString QComboBox::currentText () const"
Returns the text item being edited, or the current text item if the combo box is not editable.
.PP
See also text().
.SH "bool QComboBox::duplicatesEnabled () const"
Returns TRUE if the same text can be inserted multiple times into the list of the combobox, else FALSE.
.PP
See also setDuplicatesEnabled();.
.SH "bool QComboBox::editable () const"
Returns whether the combobox is editable or not.
.PP
See also setEditable().
.SH "bool QComboBox::eventFilter ( QObject * object, QEvent * event ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QObject.
.SH "void QComboBox::focusInEvent ( QFocusEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QComboBox::highlighted ( const QString & string ) \fC[signal]\fR"
This signal is emitted when a new item has been highlighted. \fIstring\fR is the highlighted string.
.PP
You can also use highlighted(int) signal.
.SH "void QComboBox::highlighted ( int index ) \fC[signal]\fR"
This signal is emitted when a new item has been set to current. The \fIindex\fR is the position of the item in the popup list.
.SH "void QComboBox::insertItem ( const QPixmap & pixmap, const QString & text, int index=-1 )"
Inserts a pixmap item with additional text \fItext\fR at position \fIindex.\fR The item will be appended if \fIindex\fR is negative.
.SH "void QComboBox::insertItem ( const QPixmap & pixmap, int index=-1 )"
Inserts a pixmap item at position \fIindex.\fR The item will be appended if \fIindex\fR is negative.
.SH "void QComboBox::insertItem ( const QString & t, int index=-1 )"
Inserts a text item at position \fIindex.\fR The item will be appended if \fIindex\fR is negative.
.SH "void QComboBox::insertStrList ( const QStrList * list, int index=-1 )"
Inserts the list of strings at the index \fIindex\fR in the combo box.
.PP
This is only for compatibility, as it does not support Unicode strings. See insertStringList().
.SH "void QComboBox::insertStrList ( const char ** strings, int numStrings=-1, int index=-1 )"
Inserts the array of ASCII strings at the index \fIindex\fR in the combo box.
.PP
The \fInumStrings\fR argument is the number of strings. If \fInumStrings\fR is -1 (default), the \fIstrs\fR array must be terminated with 0.
.PP
Example:
.PP
.nf
.br
    static const char* items[] = { "red", "green", "blue", 0 };
.br
    combo->insertStrList( items );
.fi
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "void QComboBox::insertStrList ( const QStrList & list, int index=-1 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QComboBox::insertStringList ( const QStringList & list, int index=-1 )"
Inserts the list of strings at the index \fIindex\fR in the combo box.
.SH "QComboBox::Policy QComboBox::insertionPolicy() const"
Returns the current insertion policy of the combo box.
.PP
See also setInsertionPolicy().
.SH "void QComboBox::keyPressEvent ( QKeyEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QLineEdit* QComboBox::lineEdit () const"
Returns the line editor, or 0 if there is no line editor currently.
.PP
Only editable listboxes have a line editor.
.SH "QListBox * QComboBox::listBox () const"
Returns the current list box, or 0 if there is no list box currently. (QComboBox can use QPopupMenu instead of QListBox.) Provided to match setListBox().
.PP
See also setListBox().
.SH "int QComboBox::maxCount () const"
Returns the current maximum size of the combo box. By default, there is no limit, so this function returns INT_MAX.
.PP
See also setMaxCount() and count().
.SH "void QComboBox::mouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QComboBox::mouseMoveEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QComboBox::mousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QComboBox::mouseReleaseEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QComboBox::paintEvent ( QPaintEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "const QPixmap * QComboBox::pixmap ( int index ) const"
Returns the pixmap item at a given index, or 0 if the item is not a pixmap.
.SH "void QComboBox::popup () \fC[protected]\fR"
Popups the combo box popup list.
.PP
If the list is empty, no selections appear.
.SH "void QComboBox::removeItem ( int index )"
Removes the item at position \fIindex.\fR
.SH "void QComboBox::resizeEvent ( QResizeEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QComboBox::setAutoCompletion ( bool enable ) \fC[virtual]\fR"
Sets this combo box to offer auto-completion while the user is editing if \fIenable\fR is TRUE, or not to offer auto-completion of \fIenable\fR is FALSE (the default).
.PP
The combo box uses the list of items as candidates for completion.
.PP
Note: This will only work on editable combo boxes, so make the combo box editable before you call this function or it will not work.
.PP
See also autoCompletion() and setEditText().
.SH "void QComboBox::setAutoResize ( bool enable ) \fC[virtual]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Enables auto-resizing if \fIenable\fR is TRUE, or disables it if \fIenable\fR is FALSE.
.PP
When auto-resizing is enabled, the combo box button will resize itself whenever the current combo box item change.
.PP
See also autoResize() and adjustSize().
.SH "void QComboBox::setBackgroundColor ( const QColor & color ) \fC[virtual]\fR"
Reimplements QWidget::setBackgroundColor().
.PP
Sets the background color for both the combo box button and the combo box popup list.
.SH "void QComboBox::setCurrentItem ( int index ) \fC[virtual]\fR"
Sets the current combo box item. This is the item to be displayed on the combo box button.
.PP
See also currentItem().
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "void QComboBox::setDuplicatesEnabled ( bool enable )"
If the combobox is editable and the user enters some text in the lineedit of the combobox and presses return (and the insertionPolicy() is different from \fCNoInsertion),\fR the entered text is inserted into the list of this combobox. Now, if you set \fIenable\fR to TRUE here, this new text is always inserted, else it's only inserted if it doesn't already exist in the list. If you set \fIenable\fR to FALSE and the text exists already in the list, the item which contains the same text like which should be inserted, this item gets the new current item.
.PP
This setting only applies when the user want's to insert a text with pressing the return key. It does \fInot\fR affect methods like insertItem() and similar.
.SH "void QComboBox::setEditText ( const QString & newText ) \fC[virtual slot]\fR"
Sets the text in the embedded line edit to \fInewText\fR without changing the combo's contents. Does nothing if the combo isn't editable.
.PP
This is useful e.g. for providing a good starting point for the user's editing and entering the change in the combo only when the user presses enter.
.PP
See also clearEdit() and insertItem().
.SH "void QComboBox::setEditable ( bool y )"
Make the input field editable, if \fIy\fR is TRUE. Otherwise the user may only choose one of the items in the combo box.
.PP
See also editable().
.SH "void QComboBox::setEnabled ( bool enable ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QComboBox::setFont ( const QFont & font ) \fC[virtual]\fR"
Reimplements QWidget::setFont().
.PP
Sets the font for both the combo box button and the combo box popup list.
.SH "void QComboBox::setInsertionPolicy ( Policy policy )"
Sets the insertion policy of the combo box to \fIpolicy.\fR
.PP
The insertion policy governs where items typed in by the user are inserted in the list. The possible values are 
.TP
\fCNoInsertion:\fR Strings typed by the user aren't inserted anywhere 
.TP
\fCAtTop:\fR Strings typed by the user are inserted above the top item in the list 
.TP
AtCurrent: Strings typed by the user replace the last selected item 
.TP
AtBottom: Strings typed by the user are inserted at the bottom of the list. 
.PP
The default insertion policy is \fCAtBottom.\fR
.PP
See also insertionPolicy().
.SH "void QComboBox::setListBox ( QListBox * newListBox ) \fC[virtual]\fR"
Sets the combo box to use \fInewListBox\fR instead of the current list box or popup. As a side effect, clears the combo box of its current contents.
.PP
\fBWarning:\fR QComboBox assumes that newListBox->text(n) returns non-null for 0 <= n < newListbox->count(). This assumption is necessary because of the line edit in QComboBox.
.SH "void QComboBox::setMaxCount ( int count ) \fC[virtual]\fR"
Sets the maximum number of items the combo box can hold to \fIcount.\fR
.PP
If \fIcount\fR is smaller than the current number of items, the list is truncated at the end. There is no limit by default.
.PP
See also maxCount() and count().
.SH "void QComboBox::setPalette ( const QPalette & palette ) \fC[virtual]\fR"
Reimplements QWidget::setPalette().
.PP
Sets the palette for both the combo box button and the combo box popup list.
.SH "void QComboBox::setSizeLimit ( int lines ) \fC[virtual]\fR"
Sets the maximum on-screen size of the combo box to \fIlines.\fR This is disregarded in Motif 1.x style. The default limit is ten lines.
.PP
If the number of items in the combo box is/grows larger than \fClines,\fR a list box is added.
.PP
See also sizeLimit(), count() and setMaxCount().
.SH "void QComboBox::setValidator ( const QValidator * v ) \fC[virtual]\fR"
Sets this combo box to be editable only as allowed by \fIv.\fR
.PP
This function does nothing if the combo is not editable.
.PP
See also validator(), clearValidator() and QValidator.
.SH "QSize QComboBox::sizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "int QComboBox::sizeLimit () const"
Returns the current maximum on-screen size of the combo box. The default is ten lines.
.PP
See also setSizeLimit(), count() and maxCount().
.SH "QSizePolicy QComboBox::sizePolicy () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QComboBox::styleChange ( QStyle & s ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QString QComboBox::text ( int index ) const"
Returns the text item at a given index, or null string if the item is not a string.
.PP
See also currentText().
.SH "void QComboBox::textChanged ( const QString & string ) \fC[signal]\fR"
This signal is useful for editable comboboxes. It is emitted whenever the contents of the text entry field changes.
.SH "void QComboBox::updateMask () \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "const QValidator * QComboBox::validator () const"
Returns the validator which constrains editing for this combo box if there is any, or else 0.
.PP
See also  setValidator(), clearValidator() and QValidator.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qcombobox.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qcombobox.3qt) and the Qt
version (2.3.2).
