'\" t
.TH QIconView 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QIconView \- Area with movable labelled icons
.br
.PP
\fC#include <qiconview.h>\fR
.PP
Inherits QScrollView.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBSelectionMode\fR { Single = 0, Multi, Extended, NoSelection }"
.br
.ti -1c
.BI "enum \fBArrangement\fR { LeftToRight = 0, TopToBottom }"
.br
.ti -1c
.BI "enum \fBResizeMode\fR { Fixed = 0, Adjust }"
.br
.ti -1c
.BI "enum \fBItemTextPos\fR { Bottom = 0, Right }"
.br
.ti -1c
.BI "\fBQIconView\fR ( QWidget * " "parent" " = 0, const char * " "name" " = 0, WFlags " "f" " = 0 ) "
.br
.ti -1c
.BI "virtual \fB~QIconView\fR () "
.br
.ti -1c
.BI "virtual void \fBinsertItem\fR ( QIconViewItem * " "item" ", QIconViewItem * " "after" " = 0L ) "
.br
.ti -1c
.BI "virtual void \fBtakeItem\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "int \fBindex\fR ( const QIconViewItem * item ) const"
.br
.ti -1c
.BI "QIconViewItem* \fBfirstItem\fR () const"
.br
.ti -1c
.BI "QIconViewItem* \fBlastItem\fR () const"
.br
.ti -1c
.BI "QIconViewItem* \fBcurrentItem\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCurrentItem\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "virtual void \fBsetSelected\fR ( QIconViewItem * " "item" ", bool " "s" ", bool " "cb" " = FALSE ) "
.br
.ti -1c
.BI "uint \fBcount\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetSelectionMode\fR ( SelectionMode m ) "
.br
.ti -1c
.BI "SelectionMode \fBselectionMode\fR () const"
.br
.ti -1c
.BI "QIconViewItem* \fBfindItem\fR ( const QPoint & pos ) const"
.br
.ti -1c
.BI "QIconViewItem* \fBfindItem\fR ( const QString & text ) const"
.br
.ti -1c
.BI "virtual void \fBselectAll\fR ( bool select ) "
.br
.ti -1c
.BI "virtual void \fBclearSelection\fR () "
.br
.ti -1c
.BI "virtual void \fBinvertSelection\fR () "
.br
.ti -1c
.BI "virtual void \fBrepaintItem\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "void \fBensureItemVisible\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "QIconViewItem* \fBfindFirstVisibleItem\fR ( const QRect & r ) const"
.br
.ti -1c
.BI "QIconViewItem* \fBfindLastVisibleItem\fR ( const QRect & r ) const"
.br
.ti -1c
.BI "virtual void \fBclear\fR () "
.br
.ti -1c
.BI "virtual void \fBsetGridX\fR ( int rx ) "
.br
.ti -1c
.BI "virtual void \fBsetGridY\fR ( int ry ) "
.br
.ti -1c
.BI "int \fBgridX\fR () const"
.br
.ti -1c
.BI "int \fBgridY\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetSpacing\fR ( int sp ) "
.br
.ti -1c
.BI "int \fBspacing\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetItemTextPos\fR ( ItemTextPos pos ) "
.br
.ti -1c
.BI "ItemTextPos \fBitemTextPos\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetItemTextBackground\fR ( const QBrush & b ) "
.br
.ti -1c
.BI "QBrush \fBitemTextBackground\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetArrangement\fR ( Arrangement am ) "
.br
.ti -1c
.BI "Arrangement \fBarrangement\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetResizeMode\fR ( ResizeMode am ) "
.br
.ti -1c
.BI "ResizeMode \fBresizeMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMaxItemWidth\fR ( int w ) "
.br
.ti -1c
.BI "int \fBmaxItemWidth\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMaxItemTextLength\fR ( int w ) "
.br
.ti -1c
.BI "int \fBmaxItemTextLength\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetAutoArrange\fR ( bool b ) "
.br
.ti -1c
.BI "bool \fBautoArrange\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetShowToolTips\fR ( bool b ) "
.br
.ti -1c
.BI "bool \fBshowToolTips\fR () const"
.br
.ti -1c
.BI "void \fBsetSorting\fR ( bool " "sort" ", bool " "ascending" " = TRUE ) "
.br
.ti -1c
.BI "bool \fBsorting\fR () const"
.br
.ti -1c
.BI "bool \fBsortDirection\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetItemsMovable\fR ( bool b ) "
.br
.ti -1c
.BI "bool \fBitemsMovable\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetWordWrapIconText\fR ( bool b ) "
.br
.ti -1c
.BI "bool \fBwordWrapIconText\fR () const"
.br
.ti -1c
.BI "virtual void \fBsort\fR ( bool " "ascending" " = TRUE ) "
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBarrangeItemsInGrid\fR ( const QSize & " "grid" ", bool " "update" " = TRUE ) "
.br
.ti -1c
.BI "virtual void \fBarrangeItemsInGrid\fR ( bool " "update" " = TRUE ) "
.br
.ti -1c
.BI "virtual void \fBupdateContents\fR () (internal)"
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBselectionChanged\fR () "
.br
.ti -1c
.BI "void \fBselectionChanged\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "void \fBcurrentChanged\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "void \fBclicked\fR ( QIconViewItem * ) "
.br
.ti -1c
.BI "void \fBclicked\fR ( QIconViewItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBpressed\fR ( QIconViewItem * ) "
.br
.ti -1c
.BI "void \fBpressed\fR ( QIconViewItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBdoubleClicked\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "void \fBreturnPressed\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "void \fBrightButtonClicked\fR ( QIconViewItem * " "item" ", const QPoint & pos ) "
.br
.ti -1c
.BI "void \fBrightButtonPressed\fR ( QIconViewItem * " "item" ", const QPoint & pos ) "
.br
.ti -1c
.BI "void \fBmouseButtonPressed\fR ( int " "button" ", QIconViewItem * " "item" ", const QPoint & pos ) "
.br
.ti -1c
.BI "void \fBmouseButtonClicked\fR ( int " "button" ", QIconViewItem * " "item" ", const QPoint & pos ) "
.br
.ti -1c
.BI "void \fBdropped\fR ( QDropEvent * " "e" ", const QValueList<QIconDragItem> & lst ) "
.br
.ti -1c
.BI "void \fBmoved\fR () "
.br
.ti -1c
.BI "void \fBonItem\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "void \fBonViewport\fR () "
.br
.ti -1c
.BI "void \fBitemRenamed\fR ( QIconViewItem * " "item" ", const QString & ) "
.br
.ti -1c
.BI "void \fBitemRenamed\fR ( QIconViewItem * item ) "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual void \fBdrawRubber\fR ( QPainter * p ) "
.br
.ti -1c
.BI "virtual QDragObject* \fBdragObject\fR () "
.br
.ti -1c
.BI "virtual void \fBstartDrag\fR () "
.br
.ti -1c
.BI "virtual void \fBinsertInGrid\fR ( QIconViewItem * item ) "
.br
.ti -1c
.BI "virtual void \fBdrawBackground\fR ( QPainter * " "p" ", const QRect & r ) "
.br
.ti -1c
.BI "void \fBemitSelectionChanged\fR ( QIconViewItem * " "i" " = 0 ) "
.br
.ti -1c
.BI "void \fBemitRenamed\fR ( QIconViewItem * item ) (internal)"
.br
.ti -1c
.BI "QIconViewItem* \fBmakeRowLayout\fR ( QIconViewItem * " "begin" ", int & y ) "
.br
.in -1c
.SS "Protected Slots"
.in +1c
.ti -1c
.BI "virtual void \fBdoAutoScroll\fR () "
.br
.ti -1c
.BI "virtual void \fBadjustItems\fR () "
.br
.ti -1c
.BI "virtual void \fBslotUpdate\fR () "
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
bool	sorting	sorting
bool	sortDirection	sortDirection
SelectionMode	selectionMode	selectionMode	setSelectionMode
int	gridX	gridX	setGridX
int	gridY	gridY	setGridY
int	spacing	spacing	setSpacing
ItemTextPos	itemTextPos	itemTextPos	setItemTextPos
QBrush	itemTextBackground	itemTextBackground	setItemTextBackground
Arrangement	arrangement	arrangement	setArrangement
ResizeMode	resizeMode	resizeMode	setResizeMode
int	maxItemWidth	maxItemWidth	setMaxItemWidth
int	maxItemTextLength	maxItemTextLength	setMaxItemTextLength
bool	autoArrange	autoArrange	setAutoArrange
bool	itemsMovable	itemsMovable	setItemsMovable
bool	wordWrapIconText	wordWrapIconText	setWordWrapIconText
bool	showToolTips	showToolTips	setShowToolTips
uint	count	count
.TE
.fi

.SH DESCRIPTION
The QIconView class provides an area with movable labelled icons.
.PP
It can display and control a grid or other 2-d layout of items, and provides the ability to add or remove new items at any time, lets the user select one or may items, rearrange the items, provides drag and drop of items, and so on.
.PP
Each item (a QIconViewItem) contains a text and a pixmap (the icon itself).
.PP
The simplest usage of QIconView is to create the object, create some QIconViewItems with the view as parent, set the view's geometry, and show it.
.PP
When an item is inserted, QIconView allocates a spot for it. The default Arrangement is \fCLeftToRight\fR - QIconView fills up the leftmost column first, then goes rightwards. You can change that using setArrangement(), or insert items in a specified position by calling the appropriate constructors or QIconViewItem::insertItem(), or sort while the view is on-screen using setSorting() and/or sort().
.PP
Each (selectable) item can be selected, and the view provides various SelectionMode settings. The default is \fCSingle\fR - when one item is selected, the previously selected item is unselected.
.PP
The QIconView provides a widget which can contain lots of iconview items which can be selected, dragged and so on.
.PP
Items can be inserted in a grid and can flow from top to bottom (TopToBottom) or from left to right (LeftToRight). The text can be either displayed at the bottom of the icons or the the right of the icons. Items can also be inserted in a sorted order. There are also methods to re-arrange and re-sort the items after they have been inserted.
.PP
There is a variety of selection modes, described in the QIconView::SelectionMode documentation. The default is single-selection, and you can change it using setSelectionMode().
.PP
Since QIconView offers multiple selection it has to display keyboard focus and selection state separately. Therefore there are functions both to set the selection state of an item, setSelected(), and to select which item displays keyboard focus, setCurrentItem().
.PP
When multiple items may be selected, the iconview provides a rubberband too.
.PP
Items can also be in-place renamed.
.PP
The normal way to insert some items is to create QIconViewItems and pass the iconview as parent. By using insertItem(), items can be inserted manually too. The QIconView offers basic methods similar to the QListView and QListBox, like QIconView::takeItem(), QIconView::clearSelection(), QIconView::setSelected(), QIconView::setCurrentItem(), QIconView::currentItem() and much more.
.PP
As the internal structure to store the iconview items is linear (a double linked list), no iterator class is needed to iterate over all items. This can be easily done with a code like
.PP
.nf
.br
  QIconView *iv = the iconview
.br
  for ( QIconViewItem *i = iv->firstItem(); i; i = i->nextItem() ) {
.br
      i->doSmething();
.br
  }
.fi
.PP
To notify the application about changes in the iconview there are several signals which are emitted by the QIconView.
.PP
The QIconView is designed for Drag'n'Drop, as the icons are also moved inside the iconview itself using DnD. So the QIconView provides some methods for extended DnD too. To use DnD correctly in the iconview, please read following instructions:
.PP
There are two different ways to do that, depending what you want. The first case is the simple one, in which case just the dragobject you created is dragged around. If you want, that drag shapes (the rectangles of the dragged items with exact positions) are drawn, you have to choose the more complicated way. Here first the simple case is described:
.PP
In the simple case you only need for starting a drag to reimplement QIconView::dragObject(). There you create a QDragObject with the data you want to drag and return it. And for entering drags you don't need to do anything special then. Just connect to dropped() signal to get notified about drops onto the viewport and reimplement QIconViewItem::acceptDrop() and QIconViewItem::dropped() to be able to react on drops onto an iconview item.
.PP
If you want to have drag shapes drawn, you have to do quite a bit more and complex things:
.PP
The first part is starting drags: If you want to use extended DnD in the QIconView, you should use QIconDrag (or a derived class from that) as dragobject and in dragObject() create such an object and return it. Before returning it, fill it there with QIconDragItems. Normally such a drag should offer data of each selected item. So in dragObject() you should iterate over all items, create for each selected item a QIconDragItem and append this with QIconDrag::append() to the QIconDrag object. With QIconDragItem::setData() you can set the data of each item which should be dragged. If you want to offer the data in additional mime-types, it's the best to use a class derived from QIconDrag which implements additional encoding and decoding functions.
.PP
Now, when a drag enters the iconview, there is not much todo. Just connect to the dropped() signal and reimplement QIconViewItem::dropped() and QIconViewItem::acceptDrop(). The only special thing in this case is the second argument in the dropped() signal and in QIconViewItem::dropped(). Fur further details about that look at the documentation of these signal/method.
.PP
For an example implementation of the complex Drag'n'Drop stuff look at the qfileiconview example (qt/examples/qfileiconview)
.PP
Finally, see also QIconViewItem::setDragEnabled(), QIconViewItem::setDropEnabled(), QIconViewItem::acceptDrop() and QIconViewItem::dropped()
.PP
.ce 1
.B "[Image Omitted]"
.PP

.ce 1
.B "[Image Omitted]"
.PP
Examples:
.(l
iconview/main.cpp
.)l
.SS "Member Type Documentation"
.SH "QIconView::Arrangement"
This enum type decides in which direction the items, which do not fit onto the screen anymore flow.
.TP
\fCLeftToRight\fR - Items, which don't fit onto the view, go further down (you get a vertical scrollbar)
.TP
\fCTopToBottom\fR - Items, which don't fit onto the view, go further right (you get a horizontal scrollbar)
.SH "QIconView::ItemTextPos"
This enum type specifies the position of the item text in relation to the icon.
.TP
\fCBottom\fR - The text is drawn at the bottom of the icon)
.TP
\fCRight\fR - The text is drawn at the right of the icon)
.SH "QIconView::ResizeMode"
This enum type decides how QIconView should treat the positions of its icons when the widget is resized. The currently defined modes are: 
.TP
\fCFixed\fR - the icons' positions are not changed.
.TP
\fCAdjust\fR - the icons' positions are adjusted to be within the new geometry, if possible.
.IP
.SH "QIconView::SelectionMode"
This enumerated type is used by QIconView to indicate how it reacts to selection by the user. It has four values: 
.TP
\fCSingle\fR - When the user selects an item, any already-selected item becomes unselected, and the user cannot unselect the selected item. This means that the user can never clear the selection, even though the selection may be cleared by the application programmer using QIconView::clearSelection().
.TP
\fCMulti\fR - When the user selects an item in the most ordinary way, the selection status of that item is toggled and the other items are left alone.
.TP
\fCExtended\fR - When the user selects an item in the most ordinary way, the selection is cleared and the new item selected. However, if the user presses the CTRL key when clicking on an item, the clicked item gets toggled and all other items are left untouched. And if the user presses the SHIFT key while clicking on an item, all items between the current item and the clicked item get selected or unselected depending on the state of the clicked item. Also multiple items can be selected by dragging the mouse while the left mouse button stayes pressed.
.TP
\fCNoSelection\fR - Items cannot be selected.
.IP
.PP
In other words, \fCSingle\fR is a real single-selection iconview, \fCMulti\fR a real multi-selection iconview, and \fCExtended\fR iconview where users can select multiple items but usually want to select either just one or a range of contiguous items, and \fCNoSelection\fR is for a iconview where the user can look but not touch.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QIconView::QIconView ( QWidget * parent = 0, const char * name = 0, WFlags f = 0 )"
Constructs an empty icon view.
.SH "QIconView::~QIconView () \fC[virtual]\fR"
Destructs the iconview and deletes all items.
.SH "void QIconView::adjustItems () \fC[virtual protected slot]\fR"
Adjusts the positions of the items to the geometry of the iconview.
.SH "void QIconView::arrangeItemsInGrid ( bool update = TRUE ) \fC[virtual slot]\fR"
Arranges all items in the grid. For the grid the specified values, given by QIconView::setGridX() and QIconView::setGridY() are used. Even if QIconView::sorting() is enabled, the items are not resorted in this method. If you want to sort and re-arrange all items, use iconview->sort( iconview->sortDirection() );
.PP
If \fIupdate\fR is TRUE, the viewport is repainted.
.PP
See also QIconView::setGridX(), QIconView::setGridY() and QIconView::sort().
.SH "void QIconView::arrangeItemsInGrid ( const QSize & grid, bool update = TRUE ) \fC[virtual slot]\fR"
Arranges all items in the \fIgrid;\fR If the grid is invalid (see QSize::isValid(), an invalid size is created when using the default constructor of QSize()) the best fitting grid is calculated first and used then.
.PP
if \fIupdate\fR is TRUE, the viewport is repainted.
.SH "QIconView::Arrangement QIconView::arrangement() const"
Returns the arrangement mode of the iconview.
.PP
See also QIconView::setArrangement().
.SH "bool QIconView::autoArrange () const"
Returns TRUE if all items are re-arranged in the grid if a new one is inserted, else FALSE.
.PP
See also QIconView::setAutoArrange().
.SH "void QIconView::clear () \fC[virtual]\fR"
Cleares the iconview.
.SH "void QIconView::clearSelection () \fC[virtual]\fR"
Unselects all items.
.SH "void QIconView::clicked ( QIconViewItem * item ) \fC[signal]\fR"
This signal is emitted when the user clicked (pressed + released) with any mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0).
.SH "void QIconView::clicked ( QIconViewItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted when the user clicked (pressed + released) with any mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0). \fIpos\fR the position of the mouse cursor.
.SH "void QIconView::contentsDragEnterEvent ( QDragEnterEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsDragLeaveEvent ( QDragLeaveEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsDragMoveEvent ( QDragMoveEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsDropEvent ( QDropEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsMouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsMouseMoveEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsMousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::contentsMouseReleaseEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "uint QIconView::count () const"
Returns the number of items in the iconview.
.SH "void QIconView::currentChanged ( QIconViewItem * item ) \fC[signal]\fR"
This signal is emitted, when the different items got current. \fIitem\fR is the new current item or 0, if no item is current now.
.SH "QIconViewItem * QIconView::currentItem () const"
Returns a pointer to the current item fo the iconview, or 0, if no item is current.
.SH "void QIconView::doAutoScroll () \fC[virtual protected slot]\fR"
Does autoscrolling when selecting multiple icons with the rubber band.
.SH "void QIconView::doubleClicked ( QIconViewItem * item ) \fC[signal]\fR"
This signal is emitted, if the user double-clicked on the item \fIitem.\fR
.SH "QDragObject * QIconView::dragObject () \fC[virtual protected]\fR"
Returns the QDragObject which should be used for DnD. This method is called by the iconview when starting a drag to get the dragobject which should be used for the drag. Subclasses may reimplement this.
.PP
See also QIconDrag.
.SH "void QIconView::drawBackground ( QPainter * p, const QRect & r ) \fC[virtual protected]\fR"
This method is called to draw the rectangle \fIr\fR of the background using the painter \fIp.\fR xOffset and yOffset are known using the methods contentsX() and contentsY().
.PP
The default implementation only fills \fIr\fR with colorGroup().base(). Subclasses may reimplement this to draw fency backgrounds.
.SH "void QIconView::drawContents ( QPainter * p, int cx, int cy, int cw, int ch ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::drawRubber ( QPainter * p ) \fC[virtual protected]\fR"
Draws the rubber band using the painter \fIp.\fR
.SH "void QIconView::dropped ( QDropEvent * e, const QValueList<QIconDragItem> & lst ) \fC[signal]\fR"
This signal is emitted, when a drop event occurred onto the viewport (not onto an icon), which the iconview itself can't handle.
.PP
\fIe\fR gives you all information about the drop. If the drag object of the drop was a QIconDrag, \fIlst\fR contains the list of the dropped items. You can get the data using QIconDragItem::data() of each item then.
.PP
So, if \fIlst\fR is not empty, use this data for further operations, else the drag was not a QIconDrag, so you have to decode \fIe\fR yourself and work with that.
.SH "void QIconView::emitSelectionChanged ( QIconViewItem * i = 0 ) \fC[protected]\fR"
Emits signals, that indicate selection changes.
.SH "void QIconView::ensureItemVisible ( QIconViewItem * item )"
Makes sure, that \fIitem\fR is visible, and scrolls the view if required.
.SH "void QIconView::enterEvent ( QEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "bool QIconView::eventFilter ( QObject * o, QEvent * e ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QObject.
.SH "QIconViewItem* QIconView::findFirstVisibleItem ( const QRect & r ) const"
Finds the first item which is visible in the rectangle \fIr\fR in contents coordinates. If no items are visible at all, 0 is returned.
.SH "QIconViewItem * QIconView::findItem ( const QPoint & pos ) const"
Returns a pointer to the item which contains \fIpos,\fR which is given on contents coordinates.
.SH "QIconViewItem * QIconView::findItem ( const QString & text ) const"
Returns a pointer to the first item which could be found that contains \fItext,\fR or 0 if no such item could be found.
.SH "QIconViewItem* QIconView::findLastVisibleItem ( const QRect & r ) const"
Finds the last item which is visible in the rectangle \fIr\fR in contents coordinates. If no items are visible at all, 0 is returned.
.SH "QIconViewItem * QIconView::firstItem () const"
Returns a pointer to the first item fo the iconview, or 0, if there are no items in the iconview.
.SH "void QIconView::focusInEvent ( QFocusEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::focusOutEvent ( QFocusEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "int QIconView::gridX () const"
Returns the horizontal grid.
.PP
See also QIconView::setGridX().
.SH "int QIconView::gridY () const"
Returns the vertica grid.
.PP
See also QIconView::setGridY().
.SH "int QIconView::index ( const QIconViewItem * item ) const"
Returns the index of \fIitem\fR or -1 if \fIitem\fR doesn't exist in this icon view.
.SH "void QIconView::insertInGrid ( QIconViewItem * item ) \fC[virtual protected]\fR"
Inserts an item in the grid of the iconview. You should never need to call this manually.
.SH "void QIconView::insertItem ( QIconViewItem * item, QIconViewItem * after = 0L ) \fC[virtual]\fR"
Inserts the iconview item \fIitem\fR after \fIafter.\fR If \fIafter\fR is 0, \fIitem\fR is appended.
.PP
You should never need to call this method yourself, you should rather do
.PP
.nf
.br
    (void) new QIconViewItem( iconview, "This is the text of the item", pixmap );
.fi
.PP
This does everything required for inserting an item.
.SH "void QIconView::invertSelection () \fC[virtual]\fR"
Inverts the selection. Works only in Multi and Extended selection mode.
.SH "void QIconView::itemRenamed ( QIconViewItem * item ) \fC[signal]\fR"
If the \fIitem\fR has been renamed (e.g. by in-place renaming), this signal is emitted.
.SH "void QIconView::itemRenamed ( QIconViewItem * item, const QString & name ) \fC[signal]\fR"
If the \fIitem\fR has been renamed (e.g. by in-place renaming), this signal is emitted. \fIname\fR is the new text (name) of the item.
.SH "QBrush QIconView::itemTextBackground () const"
Returns the brush which is used to draw the background of an item text
.PP
See also setItemTextBackground().
.SH "QIconView::ItemTextPos QIconView::itemTextPos() const"
Returns the position, at which the text of the items are drawn.
.PP
See also QIconView::setItemTextPos().
.SH "bool QIconView::itemsMovable () const"
Returns TRUE, if the user is allowed to move items around in the iconview, else FALSE;
.PP
See also QIconView::setItemsMovable().
.SH "void QIconView::keyPressEvent ( QKeyEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "QIconViewItem * QIconView::lastItem () const"
Returns a pointer to the last item fo the iconview, or 0, if there are no items in the iconview.
.SH "QIconViewItem * QIconView::makeRowLayout ( QIconViewItem * begin, int & y ) \fC[protected]\fR"
Lays out a row of icons (in Arrangement == TopToBottom this is a column). Starts laying out with the item \fIbegin. y\fR is the starting coordinate. Returns the last item of the row and sets the new starting coordinate to \fIy.\fR
.PP
This function may be made private in a future version of Qt. We recommend not calling it.
.SH "int QIconView::maxItemTextLength () const"
Returns the maximum length (in characters), which the text of an icon may have.
.PP
See also QIconView::setMaxItemTextLength().
.SH "int QIconView::maxItemWidth () const"
Returns the maximum width (in pixels), which an item may have.
.PP
See also QIconView::setMaxItemWidth().
.SH "QSize QIconView::minimumSizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QIconView::mouseButtonClicked ( int button, QIconViewItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted when the user clicked (pressed + released) with any mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0). \fIbutton\fR is the number of the mouse button which the user clicked, and \fIpos\fR the position of the mouse cursor.
.SH "void QIconView::mouseButtonPressed ( int button, QIconViewItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted when the user pressed with any mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0). \fIbutton\fR is the number of the mouse button which the user pressed, and \fIpos\fR the position of the mouse cursor.
.SH "void QIconView::moved () \fC[signal]\fR"
This signal is emitted after successfully dropping an (or some) item(s) of the iconview somewhere and if they should be removed now.
.SH "void QIconView::onItem ( QIconViewItem * i ) \fC[signal]\fR"
This signal is emitted, when the user moves the mouse cursor onto an item. It´s only emitted once per item.
.SH "void QIconView::onViewport () \fC[signal]\fR"
This signal is emitted, when the user moves the mouse cursor, which was on an item away from the item onto the viewport.
.SH "void QIconView::pressed ( QIconViewItem * item ) \fC[signal]\fR"
This signal is emitted when the user pressed with any mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0).
.SH "void QIconView::pressed ( QIconViewItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted when the user pressed with any mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0). \fIpos\fR the position of the mouse cursor.
.SH "void QIconView::repaintItem ( QIconViewItem * item ) \fC[virtual]\fR"
Repaints the \fIitem.\fR
.SH "void QIconView::resizeEvent ( QResizeEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "QIconView::ResizeMode QIconView::resizeMode() const"
Returns the resize mode of the iconview.
.PP
See also QIconView::setResizeMode().
.SH "void QIconView::returnPressed ( QIconViewItem * item ) \fC[signal]\fR"
This signal is emitted, if the user pressed the return or enter button. \fIitem\fR is the item which was current while return or enter was pressed.
.SH "void QIconView::rightButtonClicked ( QIconViewItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted when the user clicked (pressed + released) with the right mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0). \fIpos\fR the position of the mouse cursor.
.SH "void QIconView::rightButtonPressed ( QIconViewItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted when the user pressed with the right mouse button on either and item (then \fIitem\fR is the item under the mouse cursor) or somewhere else (then \fIitem\fR is 0). \fIpos\fR the position of the mouse cursor.
.SH "void QIconView::selectAll ( bool select ) \fC[virtual]\fR"
If \fIselect\fR is TRUE, all items get selected, else all get unselected. This works only in the selection modes Multi and Extended. In Single and NoSelection mode the selection of the current item is just set to \fIselect.\fR
.SH "void QIconView::selectionChanged () \fC[signal]\fR"
This signal is emitted when the selection has been changed. It's emitted in each selection mode.
.SH "void QIconView::selectionChanged ( QIconViewItem * item ) \fC[signal]\fR"
This signal is emitted when the selection has been changed. \fIitem\fR is the new selected item. This signal is only emitted in single selection mode.
.SH "QIconView::SelectionMode QIconView::selectionMode() const"
Returns the selection mode of the iconview. The initial mode is \fCSingle.\fR
.PP
See also setSelectionMode().
.SH "void QIconView::setArrangement ( Arrangement am )"
Sets the arrangement mode of the iconview to \fIam,\fR which must be one of \fCLeftToRight\fR and TopToBottom.
.PP
See also Arrangement.
.SH "void QIconView::setAutoArrange ( bool b ) \fC[virtual]\fR"
If \fIb\fR is TRUE, all items are re-arranged in the grid if a new one is inserted. Else, the best fitting place for the new item is searched and the other ones are not touched.
.PP
This setting only applies if the iconview is visible. If you insert items and the iconview is not visible, the icons are reordered when it gets visible.
.SH "void QIconView::setContentsPos ( int x, int y ) \fC[virtual slot]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::setCurrentItem ( QIconViewItem * item ) \fC[virtual]\fR"
Makes \fIitem\fR the new current item of the iconview.
.SH "void QIconView::setFont ( const QFont & f ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::setGridX ( int rx ) \fC[virtual]\fR"
Sets the horizontal grid to \fIrx.\fR If \fIrx\fR is -1, there is no horizontal grid used for arranging items.
.SH "void QIconView::setGridY ( int ry ) \fC[virtual]\fR"
Sets the vertical grid to \fIry.\fR If \fIry\fR is -1, there is no vertical grid used for arranging items.
.SH "void QIconView::setItemTextBackground ( const QBrush & brush ) \fC[virtual]\fR"
Sets the \fIbrush,\fR which should be used when drawing the background of an item text. By default, this brush is set to NoBrush, which means no extra brush is used for drawing the item text background (just the normal iconview background).
.SH "void QIconView::setItemTextPos ( ItemTextPos pos )"
Sets the position, where the text of the items is drawn. This can be Bottom or Right.
.SH "void QIconView::setItemsMovable ( bool b ) \fC[virtual]\fR"
If \fIb\fR is TRUE, the user is allowed to move items around in the iconview. if \fIb\fR is FALSE, the user is not allowed to do that.
.SH "void QIconView::setMaxItemTextLength ( int w ) \fC[virtual]\fR"
Sets the maximum length (in characters), which an item text may have.
.SH "void QIconView::setMaxItemWidth ( int w ) \fC[virtual]\fR"
Sets the maximum width, which an item may have. If a gridX() is set, this value is ignored, and the gridX() value is used.
.SH "void QIconView::setPalette ( const QPalette & p ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QIconView::setResizeMode ( ResizeMode rm )"
Sets the resize mode of the iconview to \fIrm,\fR which must be one of \fCFixed\fR and Adjust.
.PP
See also ResizeMode.
.SH "void QIconView::setSelected ( QIconViewItem * item, bool s, bool cb = FALSE ) \fC[virtual]\fR"
Selects or unselects \fIitem\fR depending on \fIs,\fR and may also unselect other items, depending on QIconView::selectionMode() and \fIcb.\fR
.PP
If \fIs\fR is FALSE, \fIitem\fR is unselected.
.PP
If \fIs\fR is TRUE and QIconView::selectionMode() is \fCSingle,\fR \fIitem\fR is selected, and the item which was selected is unselected.
.PP
If \fIs\fR is TRUE and QIconView::selectionMode() is \fCExtended,\fR \fIitem\fR is selected. If \fIcb\fR is TRUE, the other items of the iconview are not touched. If \fIcb\fR is FALSE (the default) all other items are unselected.
.PP
If \fIs\fR is TRUE and QIconView::selectionMode() is \fCMulti\fR \fIitem\fR is selected.
.PP
Note that \fIcb\fR is used only if QIconView::selectionMode() is \fCExtended.\fR \fIcb\fR defaults to FALSE.
.PP
All items whose selection status change repaint themselves.
.SH "void QIconView::setSelectionMode ( SelectionMode m )"
Sets the selection mode of the iconview to \fIm,\fR which may be one of \fCSingle\fR (the default), \fCExtended, Multi\fR or \fCNoSelection.\fR
.PP
See also selectionMode().
.PP
Examples:
.(l
iconview/main.cpp
.)l
.SH "void QIconView::setShowToolTips ( bool b ) \fC[virtual]\fR"
If wordWrapIconText() is FALSE, it happens that an item text is truncated because it's too large for one line. If you specify TRUE for \fIb\fR here and the user moves the mouse onto the item a tooltip with the whole item text is shown. If you pass \fIFALSE\fR here this feature is switched off.
.PP
See also setWordWrapIconText().
.SH "void QIconView::setSorting ( bool sort, bool ascending = TRUE )"
If \fIsort\fR is TRUE, new items are inserted sorted. The sort direction is specified using \fIascending.\fR
.PP
Inserting items sorted only works when re-arranging items is set to TRUE as well (using QIconView::setAutoArrange()).
.PP
See also QIconView::setAutoArrange() and QIconView::autoArrange().
.SH "void QIconView::setSpacing ( int sp ) \fC[virtual]\fR"
Sets the space between iconview items to \fIsp.\fR
.SH "void QIconView::setWordWrapIconText ( bool b ) \fC[virtual]\fR"
If the width of an item text is larger than the maximal item width, there are two possibilities how the QIconView can deal with this. Either it does a word wrap of the item text, so that it uses multiple lines. Or it truncates the item text so that it shrinks to the maximal item width and appends three dots "..." to the displayed text to indicate that not the full text is displayed.
.PP
If you set \fIb\fR to TRUE, a word wrap is done, else the text is displayed truncated.
.PP
NOTE: Both possibilities just change the way how the text is displayed, they do NOT modify the item text itslef.
.PP
See also setShowToolTips().
.SH "void QIconView::showEvent ( QShowEvent * ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "bool QIconView::showToolTips () const"
Returns TRUE if a tooltip is shown for truncated item texts and FALSE otherwise.
.PP
See also setShowToolTips() and setWordWrapIconText().
.SH "QSize QIconView::sizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Examples:
.(l
iconview/main.cpp
.)l
.PP
Reimplemented from QWidget.
.SH "QSizePolicy QIconView::sizePolicy () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QIconView::slotUpdate () \fC[virtual protected slot]\fR"
Because of efficiency, the iconview is not redrawn immediately after inserting a new item, but with a very small delay using a QTimer. The result of this is, that if lots of items are inserted in a short time (e.g. in a loop), the iconview is not redrawn after each inserted item, but after inserting all of them, which makes the operation much faster and flicker-free.
.SH "void QIconView::sort ( bool ascending = TRUE ) \fC[virtual]\fR"
Sorts the items of the listview and re-arranges them afterwards. If \fIascending\fR is TRUE, the items are sorted in increasing order, else in decreasing order. For sorting QIconViewItem::compare() is used. The default sort direction is set to the sort direction you set here.
.PP
See also QIconViewItem::key(), QIconViewItem::setKey(), QIconViewItem::compare(), QIconView::setSorting() and QIconView::sortDirection().
.SH "bool QIconView::sortDirection () const"
Returns TRUE if the sort direction for inserting new items is ascending, FALSE means descending. This sort direction has only a meaning if re-sorting and re-arranging of new inserted items is enabled.
.PP
See also QIconView::setSorting() and QIconView::setAutoArrange().
.SH "bool QIconView::sorting () const"
Returns TRUE if new items are inserted sorted, else FALSE.
.PP
See also QIconView::setSorting().
.SH "int QIconView::spacing () const"
Returns the spacing between iconview items.
.SH "void QIconView::startDrag () \fC[virtual protected]\fR"
Starts a drag.
.SH "void QIconView::styleChange ( QStyle & old ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QIconView::takeItem ( QIconViewItem * item ) \fC[virtual]\fR"
Takes the iconview item \fIitem\fR out of the iconview and causes an update of the screen display. The item is not deleted. You should normally not need to call this function, as QIconViewItem::~QIconViewItem() calls it. The normal way to delete an item is \fCdelete.\fR
.SH "bool QIconView::wordWrapIconText () const"
Returns TRUE, if an item text which needs too much space (to the width) is displayed word wrapped, or FALSE if it gets displayed truncated.
.PP
See also setWordWrapIconText() and setShowToolTips().
.SH "void QIconView::emitRenamed ( QIconViewItem * item ) \fC[protected]\fR"
For internal use only.
.SH "void QIconView::updateContents () \fC[virtual slot]\fR"
For internal use only.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qiconview.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qiconview.3qt) and the Qt
version (2.3.2).
