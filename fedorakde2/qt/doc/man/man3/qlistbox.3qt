'\" t
.TH QListBox 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QListBox \- List of selectable, read-only items
.br
.PP
\fC#include <qlistbox.h>\fR
.PP
Inherits QScrollView.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQListBox\fR ( QWidget * " "parent" "=0, const char * " "name" "=0, WFlags " "f" "=0 ) "
.br
.ti -1c
.BI "\fB~QListBox\fR () "
.br
.ti -1c
.BI "uint \fBcount\fR () const"
.br
.ti -1c
.BI "void \fBinsertStringList\fR ( const QStringList &, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertStrList\fR ( const QStrList *, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertStrList\fR ( const QStrList &, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertStrList\fR ( const char **, int " "numStrings" "=-1, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QListBoxItem *, int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QListBoxItem *, const QListBoxItem * after ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QString & " "text" ", int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QPixmap & " "pixmap" ", int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBinsertItem\fR ( const QPixmap & " "pixmap" ", const QString & " "text" ", int " "index" "=-1 ) "
.br
.ti -1c
.BI "void \fBremoveItem\fR ( int index ) "
.br
.ti -1c
.BI "void \fBclear\fR () "
.br
.ti -1c
.BI "QString \fBtext\fR ( int index ) const"
.br
.ti -1c
.BI "const QPixmap* \fBpixmap\fR ( int index ) const"
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QListBoxItem *, int index ) "
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QString & " "text" ", int index ) "
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QPixmap & " "pixmap" ", int index ) "
.br
.ti -1c
.BI "void \fBchangeItem\fR ( const QPixmap & " "pixmap" ", const QString & " "text" ", int index ) "
.br
.ti -1c
.BI "void \fBtakeItem\fR ( const QListBoxItem * ) "
.br
.ti -1c
.BI "int \fBnumItemsVisible\fR () const"
.br
.ti -1c
.BI "int \fBcurrentItem\fR () const"
.br
.ti -1c
.BI "QString \fBcurrentText\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCurrentItem\fR ( int index ) "
.br
.ti -1c
.BI "virtual void \fBsetCurrentItem\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBcenterCurrentItem\fR () "
.br
.ti -1c
.BI "int \fBtopItem\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetTopItem\fR ( int index ) "
.br
.ti -1c
.BI "virtual void \fBsetBottomItem\fR ( int index ) "
.br
.ti -1c
.BI "long \fBmaxItemWidth\fR () const"
.br
.ti -1c
.BI "enum \fBSelectionMode\fR { Single, Multi, Extended, NoSelection }"
.br
.ti -1c
.BI "virtual void \fBsetSelectionMode\fR ( SelectionMode ) "
.br
.ti -1c
.BI "SelectionMode \fBselectionMode\fR () const"
.br
.ti -1c
.BI "void setMultiSelection ( bool multi ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "bool isMultiSelection () const \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void \fBsetSelected\fR ( QListBoxItem *, bool ) "
.br
.ti -1c
.BI "void \fBsetSelected\fR ( int, bool ) "
.br
.ti -1c
.BI "bool \fBisSelected\fR ( int ) const"
.br
.ti -1c
.BI "bool \fBisSelected\fR ( const QListBoxItem * ) const"
.br
.ti -1c
.BI "QListBoxItem* \fBitem\fR ( int index ) const"
.br
.ti -1c
.BI "int \fBindex\fR ( const QListBoxItem * ) const"
.br
.ti -1c
.BI "QListBoxItem* \fBfindItem\fR ( const QString & text ) const"
.br
.ti -1c
.BI "void \fBtriggerUpdate\fR ( bool doLayout ) "
.br
.ti -1c
.BI "bool \fBitemVisible\fR ( int index ) "
.br
.ti -1c
.BI "bool \fBitemVisible\fR ( const QListBoxItem * ) "
.br
.ti -1c
.BI "enum \fBLayoutMode\fR { FixedNumber, FitToWidth, FitToHeight = FitToWidth, Variable }"
.br
.ti -1c
.BI "virtual void \fBsetColumnMode\fR ( LayoutMode ) "
.br
.ti -1c
.BI "virtual void \fBsetColumnMode\fR ( int ) "
.br
.ti -1c
.BI "virtual void \fBsetRowMode\fR ( LayoutMode ) "
.br
.ti -1c
.BI "virtual void \fBsetRowMode\fR ( int ) "
.br
.ti -1c
.BI "LayoutMode \fBcolumnMode\fR () const"
.br
.ti -1c
.BI "LayoutMode \fBrowMode\fR () const"
.br
.ti -1c
.BI "int \fBnumColumns\fR () const"
.br
.ti -1c
.BI "int \fBnumRows\fR () const"
.br
.ti -1c
.BI "bool \fBvariableWidth\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetVariableWidth\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBvariableHeight\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetVariableHeight\fR ( bool ) "
.br
.ti -1c
.BI "int \fBitemHeight\fR ( int " "index" " = 0 ) const"
.br
.ti -1c
.BI "QListBoxItem* \fBitemAt\fR ( QPoint ) const"
.br
.ti -1c
.BI "QRect \fBitemRect\fR ( QListBoxItem * item ) const"
.br
.ti -1c
.BI "QListBoxItem* \fBfirstItem\fR () const"
.br
.ti -1c
.BI "void \fBsort\fR ( bool " "ascending" " = TRUE ) "
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBensureCurrentVisible\fR () "
.br
.ti -1c
.BI "virtual void \fBclearSelection\fR () "
.br
.ti -1c
.BI "void \fBselectAll\fR ( bool select ) "
.br
.ti -1c
.BI "void \fBinvertSelection\fR () "
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBhighlighted\fR ( int index ) "
.br
.ti -1c
.BI "void \fBselected\fR ( int index ) "
.br
.ti -1c
.BI "void \fBhighlighted\fR ( const QString & ) "
.br
.ti -1c
.BI "void \fBselected\fR ( const QString & ) "
.br
.ti -1c
.BI "void \fBhighlighted\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBselected\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBselectionChanged\fR () "
.br
.ti -1c
.BI "void \fBselectionChanged\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBcurrentChanged\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBclicked\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBclicked\fR ( QListBoxItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBpressed\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBpressed\fR ( QListBoxItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBdoubleClicked\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBreturnPressed\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "void \fBrightButtonClicked\fR ( QListBoxItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBrightButtonPressed\fR ( QListBoxItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBmouseButtonPressed\fR ( int, QListBoxItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBmouseButtonClicked\fR ( int, QListBoxItem *, const QPoint & ) "
.br
.ti -1c
.BI "void \fBonItem\fR ( QListBoxItem * item ) "
.br
.ti -1c
.BI "void \fBonViewport\fR () "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "void \fBupdateItem\fR ( int index ) "
.br
.ti -1c
.BI "void \fBupdateItem\fR ( QListBoxItem * ) "
.br
.ti -1c
.BI "virtual void \fBpaintCell\fR ( QPainter *, int " "row" ", int col ) "
.br
.ti -1c
.BI "void \fBtoggleCurrentItem\fR () "
.br
.ti -1c
.BI "bool \fBisRubberSelecting\fR () const"
.br
.ti -1c
.BI "void \fBdoLayout\fR () const"
.br
.in -1c
.SS "Protected Slots"
.in +1c
.ti -1c
.BI "void \fBclearInputString\fR () (internal)"
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
uint	count	count
int	numItemsVisible	numItemsVisible
int	currentItem	currentItem	setCurrentItem	DESIGNABLE false
QString	currentText	currentText
int	topItem	topItem	setTopItem	DESIGNABLE false
SelectionMode	selectionMode	selectionMode	setSelectionMode
bool	multiSelection	isMultiSelection	setMultiSelection	DESIGNABLE false
LayoutMode	columnMode	columnMode	setColumnMode
LayoutMode	rowMode	rowMode	setRowMode
int	numColumns	numColumns
int	numRows	numRows
bool	variableWidth	variableWidth	setVariableWidth
bool	variableHeight	variableHeight	setVariableHeight
.TE
.fi

.SH DESCRIPTION
The QListBox widget provides a list of selectable, read-only items.
.PP
This is typically a single-column list where zero or one items are selected at once, but can also be used in many other ways.
.PP
QListBox will add scroll bars as necessary, but isn't intended for \fIreally\fR big lists. If you want more than a few thousand items, it's probably better to use a different widget, chiefly because the scroll bars won't provide very good navigation, but also because QListBox may become slow at larger sizes.
.PP
There is a variety of selection modes, described in the QListBox::SelectionMode documentation. The default is single-selection, and you can change it using setSelectionMode(). For compatibility with previous Qt versions there is still the setMultiSelection() methode. Calling setMultiSelection( TRUE ) is equivalent to setSelectionMode( Multi ), and setMultiSelection( FALSE ) is equivalent to setSelectionMode( Single ). It's suggested not to use setMultiSelection() anymore, but to use setSelectionMode() instead.
.PP
Since QListBox offers multiple selection it has to display keyboard focus and selection state separately. Therefore there are functions both to set the selection state of an item, setSelected(), and to select which item displays keyboard focus, setCurrentItem().
.PP
The list box normally arranges its items in a single column with a vertical scroll bar if necessary, but it is also possible to have a different fixed number of columns (setColumnMode()), or as many columns as will fit in the list box' assigned screen space (setColumnMode( FitToWidth )), or to have a fixed number of rows (setRowMode()), or as many rows as will fit in the list box' assigned screen space (setRowMode( FitToHeight )). In all these cases, QListBox will add scroll bars as appropriate in at least one direction.
.PP
If multiple rows is used, each row can be as high as necessary (the normal setting), or you can request that all items will have the same height by calling setVariableHeight( FALSE ). Of course there is a similar setVariableWidth().
.PP
The items discussed are QListBoxItem objects. QListBox provides methods to insert new items as a string, as pixmaps, and as QListBoxItem * (insertItem() with various arguments), and to replace an existing item with a new string, pixmap or QListBoxItem (changeItem() with various arguments). You can also remove items (surprise: removeItem()) and clear() the entire list box. Note that if you create a QListBoxItem yourself and insert it, it becomes the property of QListBox and you may not delete it. (QListBox will delete it when appropriate.)
.PP
You can also create a QListBoxItem such as QListBoxText or QListBoxPixmap with the list box as first parameter. The item will then append itself. When you delete an item, it is automatically removed from the listbox.
.PP
The list of items can be arbitrarily big; if necessary, QListBox adds scroll bars. It can be single-column (as most list boxes are) or multi-column, and offers both single and multiple selection. (QListBox does however not support multiple-column items; QListView does that job.) Also a listbox can display items arranged in a tree. But this is quite limited, and if you really want to display and work with a tree, you should use a QListView. The tree stuff in the QListBox is only supported because it´s needed in comboboxes.
.PP
The list box items can be accessed both as QListBoxItem objects (recommended) and using integer indexes (the original QListBox implementation used an array of strings internally, and the API still supports this mode of operation). Everything can be done using the new objects; most things can be done using the indexes too but unfortunately not everything.
.PP
Each item in a QListBox contains a QListBoxItem. One of the items can be the current item. The highlighted() signal is emitted when a new item gets highlighted, e.g. because the user clicks on it or QListBox::setCurrentItem() is called. The selected() signal is emitted when the user double-clicks on an item or presses return when an item is highlighted.
.PP
If the user does not select anything, no signals are emitted and currentItem() returns -1.
.PP
A list box has \fCWheelFocus\fR as a default focusPolicy(), i.e. it can get keyboard focus both by tabbing, clicking and the mouse wheel.
.PP
New items may be inserted using either insertItem(), insertStrList() or insertStringList(). inSort() is obsolete, as this method is quite inefficient. It's preferable to insert the items normally and call sort() afterwards, or insert a sorted QStringList().
.PP
By default, vertical and horizontal scroll bars are added and removed as necessary. setHScrollBarMode() and setVScrollBarMode() can be used to change this policy.
.PP
If you need to insert other types than texts and pixmaps, you must define new classes which inherit QListBoxItem.
.PP
\fBWarning:\fR The list box assumes ownership of all list box items and will delete them when it does not need them any more.
.PP
.ce 1
.B "[Image Omitted]"
.PP

.ce 1
.B "[Image Omitted]"
.PP
See also QListView, QComboBox, QButtonGroup and GUI Design Handbook: List Box (two sections)
.SS "Member Type Documentation"
.SH "QListBox::LayoutMode"
This enum type decides how QListBox lays out its rows and columns. The two modes interact, of course.
.PP
The possible values for each mode are: 
.TP
\fCFixedNumber\fR - there is a fixed number of rows (or columns).
.TP
\fCFitToHeight\fR - there are as many rows as will fit on-screen. (Ditto with \fCFitToWidth\fR and columns.)
.TP
\fCVariable\fR - there are as many rows as are required by the column mode. (Or as many columns as required by the row mode.)
.IP
.PP
Example: When you call setRowMode( FitToHeight ), columnMode() automatically becomes \fCVariable\fR to accomodate the row mode you've set.
.SH "QListBox::SelectionMode"
This enumerated type is used by QListBox to indicate how it reacts to selection by the user. It has four values: 
.TP
\fCSingle\fR - When the user selects an item, any already-selected item becomes unselected, and the user cannot unselect the selected item. This means that the user can never clear the selection, even though the selection may be cleared by the application programmer using QListBox::clearSelection().
.TP
\fCMulti\fR - When the user selects an item in the most ordinary way, the selection status of that item is toggled and the other items are left alone.
.TP
\fCExtended\fR - When the user selects an item in the most ordinary way, the selection is cleared and the new item selected. However, if the user presses the CTRL key when clicking on an item, the clicked item gets toggled and all other items are left untouched. And if the user presses the SHIFT key while clicking on an item, all items between the current item and the clicked item get selected or unselected depending on the state of the clicked item. Also multiple items can be selected by dragging the mouse while the left mouse button stayes pressed.
.TP
\fCNoSelection\fR - Items cannot be selected.
.IP
.PP
In other words, \fCSingle\fR is a real single-selection list box, \fCMulti\fR a real multi-selection list box, and \fCExtended\fR list box where users can select multiple items but usually want to select either just one or a range of contiguous items, and \fCNoSelection\fR is for a list box where the user can look but not touch.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QListBox::QListBox ( QWidget * parent=0, const char * name=0, WFlags f=0 )"
Constructs a new empty list box, with \fIparent\fR as a parent and \fIname\fR as object name.
.PP
Performance is boosted by modifying the widget flags \fIf\fR so that only part of the QListBoxItem children is redrawn. This may be unsuitable for custom QListBoxItem classes, in which case \fCWNorthWestGravity\fR and \fCWRepaintNoErase\fR should be cleared.
.PP
See also QWidget::clearWFlags() and Qt::WidgetFlags.
.SH "QListBox::~QListBox ()"
Destroys the list box. Deletes all list box items.
.SH "void QListBox::centerCurrentItem ()"
If there is a current item, the listbox is scrolled, so that this item is displayed centered.
.PP
See also QListBox::ensureCurrentVisible().
.SH "void QListBox::changeItem ( const QListBoxItem * lbi, int index )"
Replaces the item at position \fIindex\fR with \fIlbi.\fR If \fIindex\fR is negative or too large, changeItem() does nothing.
.PP
See also insertItem() and removeItem().
.SH "void QListBox::changeItem ( const QPixmap & pixmap, const QString & text, int index )"
Replaces the item at position \fIindex\fR with \fIpixmap\fR and \fItext.\fR
.PP
The operation is ignored if \fIindex\fR is out of range.
.PP
See also insertItem() and removeItem().
.SH "void QListBox::changeItem ( const QPixmap & pixmap, int index )"
Replaces the item at position \fIindex\fR with \fIpixmap.\fR
.PP
The operation is ignored if \fIindex\fR is out of range.
.PP
See also insertItem() and removeItem().
.SH "void QListBox::changeItem ( const QString & text, int index )"
Replaces the item at position \fIindex\fR with \fItext.\fR
.PP
The operation is ignored if \fIindex\fR is out of range.
.PP
See also insertItem() and removeItem().
.SH "void QListBox::clear ()"
Deletes all items in the list.
.PP
See also removeItem().
.SH "void QListBox::clearSelection () \fC[virtual slot]\fR"
Deselects all items, if possible.
.PP
Note that a single-selection listbox will automatically select an item if it has keyboard focus.
.SH "void QListBox::clicked ( QListBoxItem * item ) \fC[signal]\fR"
This signal is emitted whenever the user clicks (mouse pressed + mouse released) into the listbox. \fIitem\fR is the pointer to the clicked listbox item or NULL, if the user didn't click on an item.
.PP
Note that you may not delete any QListBoxItem objects in slots connected to this signal.
.SH "void QListBox::clicked ( QListBoxItem * item, const QPoint & pnt ) \fC[signal]\fR"
This signal is emitted whenever the user clicks (mouse pressed + mouse released) into the listbox. \fIitem\fR is the pointer to the clicked listbox item or NULL, if the user didn't click on an item. \fIpnt\fR is the position where the user has clicked.
.PP
Note that you may not delete any QListBoxItem objects in slots connected to this signal.
.SH "QListBox::LayoutMode QListBox::columnMode() const"
Returns the column layout mode for this list box. This is normally \fCFixedNumber,\fR but can be changed by calling setColumnMode()
.PP
See also rowMode(), setColumnMode() and numColumns().
.SH "uint QListBox::count () const"
Returns the number of items in the list box.
.SH "void QListBox::currentChanged ( QListBoxItem * item ) \fC[signal]\fR"
This signal is emitted when the user highlights a new current item. The argument is the index of the new item, which is already current.
.PP
See also setCurrentItem() and currentItem().
.SH "int QListBox::currentItem () const"
Returns the index of the current (highlighted) item of the list box, or -1 if no item has been selected.
.PP
See also topItem().
.SH "QString QListBox::currentText () const"
Returns the text of the current item.
.PP
This is equivalent to text(currentItem()).
.SH "void QListBox::doLayout () const \fC[protected]\fR"
This function does the hard layout work. You should never need to call it.
.SH "void QListBox::doubleClicked ( QListBoxItem * item ) \fC[signal]\fR"
This signal is emitted whenever an item is double-clicked. It's emitted on the second button press, not the second button release. \fIitem\fR is the listbox item onto which the user did the double click.
.SH "void QListBox::ensureCurrentVisible () \fC[virtual slot]\fR"
Ensures that the current item is visible.
.SH "QListBoxItem * QListBox::findItem ( const QString & text ) const"
Finds the first listbox item which starts with \fItext\fR and returns it, or returns 0 of no such item could be found. The search is done case-insensitive.
.SH "QListBoxItem * QListBox::firstItem () const"
Returns the first item of this listbox.
.SH "void QListBox::focusInEvent ( QFocusEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::focusOutEvent ( QFocusEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::highlighted ( QListBoxItem * ) \fC[signal]\fR"
This signal is emitted when the user highlights a new current item. The argument is a pointer to the new current item.
.PP
See also selected(), currentItem() and selectionChanged().
.SH "void QListBox::highlighted ( const QString & ) \fC[signal]\fR"
This signal is emitted when the user highlights a new current item and the new item is a string. The argument is the text of the new current item.
.PP
See also selected(), currentItem() and selectionChanged().
.SH "void QListBox::highlighted ( int index ) \fC[signal]\fR"
This signal is emitted when the user highlights a new current item. The argument is the index of the new item, which is already current.
.PP
See also selected(), currentItem() and selectionChanged().
.SH "int QListBox::index ( const QListBoxItem * lbi ) const"
Returns the index of \fIlbi,\fR or -1 if the item is not in this list box or \fIlbi\fR is a NULL-Pointer.
.PP
See also item().
.SH "void QListBox::insertItem ( const QListBoxItem * lbi, const QListBoxItem * after )"
Inserts the item \fIlbi\fR into the list after the item \fIafter.\fR
.PP
If \fIafter\fR is NULL, \fIlbi\fR is inserted at the beginning.
.PP
See also insertStrList().
.SH "void QListBox::insertItem ( const QListBoxItem * lbi, int index=-1 )"
Inserts the item \fIlbi\fR into the list at \fIindex.\fR
.PP
If \fIindex\fR is negative or larger than the number of items in the list box, \fIlbi\fR is inserted at the end of the list.
.PP
See also insertStrList().
.SH "void QListBox::insertItem ( const QPixmap & pixmap, const QString & text, int index=-1 )"
Inserts \fIpixmap\fR and \fItext\fR into the list at \fIindex.\fR
.PP
If \fIindex\fR is negative, \fIpixmap\fR is inserted at the end of the list.
.PP
See also insertStrList().
.SH "void QListBox::insertItem ( const QPixmap & pixmap, int index=-1 )"
Inserts \fIpixmap\fR into the list at \fIindex.\fR
.PP
If \fIindex\fR is negative, \fIpixmap\fR is inserted at the end of the list.
.PP
See also insertStrList().
.SH "void QListBox::insertItem ( const QString & text, int index=-1 )"
Inserts \fItext\fR into the list at \fIindex.\fR
.PP
If \fIindex\fR is negative, \fItext\fR is inserted at the end of the list.
.PP
See also insertStrList().
.SH "void QListBox::insertStrList ( const QStrList & list, int index=-1 )"
Inserts the string list \fIlist\fR into the list at item \fIindex.\fR
.PP
If \fIindex\fR is negative, \fIlist\fR is inserted at the end of the list. If \fIindex\fR is too large, the operation is ignored.
.PP
\fBWarning:\fR This function uses \fCconst char *\fR rather than QString, so we recommend against using it. It is provided so that legacy code will continue to work, and so that programs that certainly will not need to handle code outside a single 8-bit locale can use it. See insertStringList() - it uses real QStrings.
.PP
\fBWarning:\fR This function is never significantly faster than a loop around insertItem().
.PP
See also insertItem() and insertStringList().
.SH "void QListBox::insertStrList ( const QStrList * list, int index=-1 )"
Inserts the string list \fIlist\fR into the list at item \fIindex.\fR
.PP
If \fIindex\fR is negative, \fIlist\fR is inserted at the end of the list. If \fIindex\fR is too large, the operation is ignored.
.PP
\fBWarning:\fR This function uses \fCconst char *\fR rather than QString, so we recommend against using it. It is provided so that legacy code will continue to work, and so that programs that certainly will not need to handle code outside a single 8-bit locale can use it. See insertStringList() - it uses real QStrings.
.PP
\fBWarning:\fR This function is never significantly faster than a loop around insertItem().
.PP
See also insertItem() and insertStringList().
.SH "void QListBox::insertStrList ( const char ** strings, int numStrings=-1, int index=-1 )"
Inserts the \fInumStrings\fR strings of the array \fIstrings\fR into the list at item\fIindex.\fR
.PP
If \fIindex\fR is negative, insertStrList() inserts \fIstrings\fR at the end of the list. If \fIindex\fR is too large, the operation is ignored.
.PP
\fBWarning:\fR This function uses \fCconst char *\fR rather than QString, so we recommend against using it. It is provided so that legacy code will continue to work, and so that programs that certainly will not need to handle code outside a single 8-bit locale can use it. See insertStringList() - it uses real QStrings.
.PP
\fBWarning:\fR This function is never significantly faster than a loop around insertItem().
.PP
See also insertItem() and insertStringList().
.SH "void QListBox::insertStringList ( const QStringList & list, int index=-1 )"
Inserts the string list \fIlist\fR into the list at item \fIindex.\fR
.PP
If \fIindex\fR is negative, \fIlist\fR is inserted at the end of the list. If \fIindex\fR is too large, the operation is ignored.
.PP
\fBWarning:\fR This function is never significantly faster than a loop around insertItem().
.PP
See also insertItem() and insertStrList().
.SH "void QListBox::invertSelection () \fC[slot]\fR"
Inverts the selection. Works only in Multi and Extended selection mode.
.SH "bool QListBox::isMultiSelection () const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Consider using selectionMode() instead of this method.
.PP
Returns TRUE if the listbox is in multi-selection mode or extended selection mode, and FALSE if it is in single-selection mode or no-selection more.
.PP
See also selectionMode() and setSelectionMode().
.SH "bool QListBox::isRubberSelecting () const \fC[protected]\fR"
Returns whether the user is selecting items using a rubber rectangle.
.SH "bool QListBox::isSelected ( const QListBoxItem * i ) const"
Returns TRUE if item \fIi\fR is selected. Returns FALSE if it is not selected or if there is an error.
.SH "bool QListBox::isSelected ( int i ) const"
Returns TRUE if item \fIi\fR is selected. Returns FALSE if it is not selected or if there is an error.
.SH "QListBoxItem * QListBox::item ( int index ) const"
Returns a pointer to the item at position \fIindex,\fR or 0 if \fIindex\fR is out of bounds.
.PP
See also index().
.SH "QListBoxItem * QListBox::itemAt ( QPoint p ) const"
Returns a pointer to the item at \fIp,\fR which is in on-screen coordinates, or a null pointer if there is no item at \fIp.\fR
.SH "int QListBox::itemHeight ( int index = 0 ) const"
Returns the height in pixels of the item with index \fIindex. index\fR defaults to 0.
.PP
If \fIindex\fR is too large, this function returns 0.
.SH "QRect QListBox::itemRect ( QListBoxItem * item ) const"
Returns the rectangle on the screen \fIitem\fR occupies in viewport()'s coordinates, or an invalid rectangle if \fIi\fR is a null pointer or is not currently visible.
.SH "bool QListBox::itemVisible ( const QListBoxItem * item )"
Returns TRUE if \fIitem\fR is at least partly visible, or else FALSE.
.SH "bool QListBox::itemVisible ( int index )"
Returns TRUE if the item at position \fIindex\fR is at least partly visible.
.SH "void QListBox::keyPressEvent ( QKeyEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "long QListBox::maxItemWidth () const"
Returns the width of the largest item in the listbox.
.SH "QSize QListBox::minimumSizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::mouseButtonClicked ( int button, QListBoxItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted whenever the user clicks (mouse pressed + mouse released) into the listbox. \fIbutton\fR is the mouse button, which the user pressed. \fIitem\fR is the pointer to the clicked listbox item or NULL, if the user didn't click on an item. \fIpos\fR is the position where the user has clicked.
.PP
Note that you may not delete any QListBoxItem objects in slots connected to this signal.
.SH "void QListBox::mouseButtonPressed ( int button, QListBoxItem * item, const QPoint & pos ) \fC[signal]\fR"
This signal is emitted whenever the user presses the mouse button on a listbox. \fIbutton\fR is the mouse button, which the user pressed. \fIitem\fR is the pointer to the listbox item onto which the user pressed the mouse button or NULL, if the user didn't press the mouse on an item. \fIpos\fR is the position of the mouse cursor where the mouse cursor was when the user pressed the mouse button.
.PP
Note that you may not delete any QListBoxItem objects in slots connected to this signal.
.SH "void QListBox::mouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::mouseMoveEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::mousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::mouseReleaseEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "int QListBox::numColumns () const"
Returns the number of columns in the list box. This is normally 1, but can be different if setColumnMode() or setRowMode() has been called.
.PP
See also setColumnMode(), setRowMode() and numRows().
.SH "int QListBox::numItemsVisible () const"
Returns the number of visible items. Both partially and entirely visible items are counted.
.SH "int QListBox::numRows () const"
Returns the number of rows in the list box. This is equal to the number of items in the default single-column layout, but can be different.
.PP
See also setRowMode() and numColumns().
.SH "void QListBox::onItem ( QListBoxItem * i ) \fC[signal]\fR"
This signal is emitted, when the user moves the mouse cursor onto an item. It´s only emitted once per item.
.SH "void QListBox::onViewport () \fC[signal]\fR"
This signal is emitted, when the user moves the mouse cursor, which was on an item away from the item onto the viewport.
.SH "void QListBox::paintCell ( QPainter * p, int row, int col ) \fC[virtual protected]\fR"
Provided for compatibility with the old QListBox. We recommend using QListBoxItem::paint().
.SH "const QPixmap * QListBox::pixmap ( int index ) const"
Returns a pointer to the pixmap at position \fIindex,\fR or 0 if there is no pixmap there.
.PP
See also text().
.SH "void QListBox::pressed ( QListBoxItem * item ) \fC[signal]\fR"
This signal is emitted whenever the user presses the mouse button on a listbox. \fIitem\fR is the pointer to the listbox item onto which the user pressed the mouse button or NULL, if the user didn't press the mouse on an item.
.PP
Note that you may not delete any QListBoxItem objects in slots connected to this signal.
.SH "void QListBox::pressed ( QListBoxItem * item, const QPoint & pnt ) \fC[signal]\fR"
This signal is emitted whenever the user presses the mouse button on a listbox. \fIitem\fR is the pointer to the listbox item onto which the user pressed the mouse button or NULL, if the user didn't press the mouse on an item. \fIpnt\fR is the position of the mouse cursor where the mouse cursor was when the user pressed the mouse button.
.PP
Note that you may not delete any QListBoxItem objects in slots connected to this signal.
.SH "void QListBox::removeItem ( int index )"
Removes and deletes the item at position \fIindex.\fR If \fIindex\fR is equal to currentItem(), a new item gets highlighted and the highlighted() signal is emitted.
.PP
See also insertItem() and clear().
.SH "void QListBox::resizeEvent ( QResizeEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::returnPressed ( QListBoxItem * ) \fC[signal]\fR"
This signal is emitted when enter or return is pressed. The argument is currentItem().
.SH "void QListBox::rightButtonClicked ( QListBoxItem *, const QPoint & ) \fC[signal]\fR"
This signal is emitted when the right button is clicked (ie. when it's released). The arguments are the relevant QListBoxItem (may be 0) and the point in global coordinates.
.SH "void QListBox::rightButtonPressed ( QListBoxItem *, const QPoint & ) \fC[signal]\fR"
This signal is emitted when the right button is pressed. Then arguments are the relevant QListBoxItem (may be 0) and the point in global coordinates.
.SH "QListBox::LayoutMode QListBox::rowMode() const"
Returns the row layout mode for this list box. This is normally \fCVariable,\fR but can be changed by calling setRowMode().
.PP
See also columnMode(), setRowMode() and numRows().
.SH "void QListBox::selectAll ( bool select ) \fC[slot]\fR"
If \fIselect\fR is TRUE, all items get selected, else all get unselected. This works only in the selection modes Multi and Extended. In Single and NoSelection mode the selection of the current item is just set to \fIselect.\fR
.SH "void QListBox::selected ( QListBoxItem * ) \fC[signal]\fR"
This signal is emitted when the user double-clicks on an item or presses return when an item is highlighted. The argument is a pointer to the new selected item.
.PP
See also highlighted() and selectionChanged().
.SH "void QListBox::selected ( const QString & ) \fC[signal]\fR"
This signal is emitted when the user double-clicks on an item or presses return while an item is highlighted, and the selected item is (or has) a string. The argument is the text of the selected item.
.PP
See also highlighted() and selectionChanged().
.SH "void QListBox::selected ( int index ) \fC[signal]\fR"
This signal is emitted when the user double-clicks on an item or presses return when an item is highlighted. The argument is the index of the selected item.
.PP
See also highlighted() and selectionChanged().
.SH "void QListBox::selectionChanged () \fC[signal]\fR"
This signal is emitted when the selection set of a listbox changes. This signal is emitted in each selection mode If the user selects five items by drag-selecting, QListBox tries to emit just one selectionChanged() signal, so the signal can be connected to computationally expensive slots.
.PP
See also selected() and currentItem().
.SH "void QListBox::selectionChanged ( QListBoxItem * item ) \fC[signal]\fR"
This signal is emitted when the selection in a single-selection listbox changes. \fIitem\fR is the new selected listbox item.
.PP
See also selected() and currentItem().
.SH "QListBox::SelectionMode QListBox::selectionMode() const"
Returns the selection mode of the list box. The initial mode is \fCSingle.\fR
.PP
See also setSelectionMode().
.SH "void QListBox::setBottomItem ( int index ) \fC[virtual]\fR"
Scrolls the list box so the item at position \fIindex\fR in the list is displayed in the bottom row of the list box.
.PP
See also setTopItem().
.SH "void QListBox::setColumnMode ( LayoutMode mode )"
Sets the column layout mode to \fImode,\fR and the number of displayed columns accordingly.
.PP
The row layout mode implicitly becomes \fCVariable.\fR
.PP
If \fImode\fR is \fCVariable,\fR this function returns without doing anything.
.PP
See also setRowMode() and columnMode().
.SH "void QListBox::setColumnMode ( int columns ) \fC[virtual]\fR"
Sets the column layout mode for this list box to \fCFixedNumber,\fR and sets the number of displayed columns accordingly.
.PP
See also setRowMode(), columnMode() and numColumns().
.SH "void QListBox::setCurrentItem ( QListBoxItem * i ) \fC[virtual]\fR"
Sets the highlighted item to the item \fIi.\fR The highlighting is moved and the list box scrolled as necessary.
.PP
See also currentItem().
.SH "void QListBox::setCurrentItem ( int index ) \fC[virtual]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This is a bit slower than the QListBoxItem * version.
.SH "void QListBox::setFont ( const QFont & font ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QListBox::setMultiSelection ( bool enable )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Consider using setSelectionMode() instead of this method.
.PP
Sets the list box to multi-selection mode if \fIenable\fR is TRUE, and to single-selection mode if \fIenable\fR is FALSE. We recommend using setSelectionMode() instead; that function also offers two other modes.
.PP
See also setSelectionMode() and selectionMode().
.SH "void QListBox::setRowMode ( LayoutMode mode )"
Sets the row layout mode to \fImode,\fR and the number of displayed rows accordingly.
.PP
The column layout mode implicitly becomes \fCVariable.\fR
.PP
If \fImode\fR is \fCVariable,\fR this function returns without doing anything.
.PP
See also setColumnMode() and rowMode().
.SH "void QListBox::setRowMode ( int rows ) \fC[virtual]\fR"
Sets the row layout mode for this list box to \fCFixedNumber\fR and sets the number of displayed rows accordingly.
.PP
See also setColumnMode(), rowMode() and numRows().
.SH "void QListBox::setSelected ( QListBoxItem * item, bool select ) \fC[virtual]\fR"
Selects \fIitem\fR if \fIselect\fR is TRUE, or unselects it if \fIselect\fR is FALSE, and repaints the item appropriately.
.PP
If the listbox is a single-selection listbox and and \fIselect\fR is TRUE, setCurrentItem() is called.
.PP
If the listbox is a single-selection listbox and and \fIselect\fR is FALSE, clearSelection() is called if \fIindex\fR is the currently selected item.
.PP
Note that for this function, no-selection means multi-selection. The user cannot select items in a no-selection list box, but the application programmer can.
.PP
See also setMultiSelection(), setCurrentItem(), clearSelection() and currentItem().
.SH "void QListBox::setSelected ( int index, bool select )"
Selects the item at position \fIindex\fR if \fIselect\fR is TRUE, or unselects it if \fIselect\fR is FALSE, and repaints the item appropriately.
.PP
If the listbox is a single-selection listbox and and \fIselect\fR is TRUE, setCurrentItem() will be called.
.PP
If the listbox is a single-selection listbox and and \fIselect\fR is FALSE, clearSelection() will be called if \fIindex\fR is the currently selected item.
.PP
See also setMultiSelection(), setCurrentItem(), clearSelection() and currentItem().
.SH "void QListBox::setSelectionMode ( SelectionMode mode )"
Sets the list box to selection mode \fImode,\fR which may be one of \fCSingle\fR (the default), \fCExtended, Multi\fR or \fCNoSelection.\fR
.PP
See also selectionMode().
.SH "void QListBox::setTopItem ( int index ) \fC[virtual]\fR"
Scrolls the list box so the item at position \fIindex\fR in the list is displayed in the top row of the list box.
.PP
See also topItem() and ensureCurrentVisible().
.SH "void QListBox::setVariableHeight ( bool enable ) \fC[virtual]\fR"
Sets this list box to have variable-height rows if \fIenable\fR is TRUE, and equal-height rows if \fIenable\fR is FALSE.
.PP
When the list box has variable-height rows, each row is as high as the highest item in that row. When it has same-sized rows, all rows are as high as the highest item in the list box.
.PP
The default is TRUE.
.PP
See also setVariableWidth() and variableHeight().
.SH "void QListBox::setVariableWidth ( bool enable ) \fC[virtual]\fR"
Sets this list box to have variable-width columns if \fIenable\fR is TRUE, and equal-width columns if \fIenable\fR is FALSE.
.PP
When the list box has variable-width columns, each column is as wide as the widest item in that column. When it has same-sized columns, all columns are as wide as the widest item in the list box.
.PP
The default is FALSE.
.PP
See also setVariableHeight() and variableWidth().
.SH "void QListBox::showEvent ( QShowEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QSize QListBox::sizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListBox::sort ( bool ascending = TRUE )"
Sorts the item in ascending order, if \fIascending\fR is TRUE, or descending otherwise.
.PP
To compare the items, the text (QListBoxItem::text()) of the items is used. The sorting is done using the Quick-Sort Alogorithm.
.SH "void QListBox::takeItem ( const QListBoxItem * item )"
Removes \fIitem\fR from the listbox and causes an update of the screen display. The item is not deleted. You should normally not need to call this function, as QListBoxItem::~QListBoxItem() calls it. The normal way to delete an item is \fCdelete.\fR
.PP
See also QListBox::insertItem().
.SH "QString QListBox::text ( int index ) const"
Returns the text at position \fIindex,\fR or a null string if there is no text at that position.
.PP
See also pixmap().
.SH "void QListBox::toggleCurrentItem () \fC[protected]\fR"
Toggles the selection status of currentItem() and repaints, if the listbox is a multi-selection listbox.
.PP
See also setMultiSelection().
.SH "int QListBox::topItem () const"
Returns the index of an item at the top of the screen. If there are more than one of them, an arbitrary item is selected and returned.
.SH "void QListBox::triggerUpdate ( bool doLayout )"
Ensures that a single paint event will occur at the end of the current event loop iteration. If \fIdoLayout\fR is TRUE, the layout is also redone.
.SH "void QListBox::updateItem ( QListBoxItem * i ) \fC[protected]\fR"
Repaints \fIi.\fR
.SH "void QListBox::updateItem ( int index ) \fC[protected]\fR"
Repaints the item at position \fIindex\fR in the list.
.SH "bool QListBox::variableHeight () const"
Returns TRUE if this list box has variable-height rows, and FALSE if all the rows have the same height.
.PP
See also setVariableHeight() and setVariableWidth().
.SH "bool QListBox::variableWidth () const"
Returns TRUE if this list box has variable-width columns, and FALSE if all the columns have the same width.
.PP
See also setVariableHeight() and setVariableWidth().
.SH "void QListBox::viewportMouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QScrollView.
.SH "void QListBox::viewportMouseMoveEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QScrollView.
.SH "void QListBox::viewportMousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QScrollView.
.SH "void QListBox::viewportMouseReleaseEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QScrollView.
.SH "void QListBox::viewportPaintEvent ( QPaintEvent * e ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QScrollView.
.SH "void QListBox::clearInputString () \fC[protected slot]\fR"
For internal use only.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qlistbox.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qlistbox.3qt) and the Qt
version (2.3.2).
