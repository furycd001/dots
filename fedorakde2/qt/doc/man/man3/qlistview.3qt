'\" t
.TH QListView 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QListView \- Implements a list/tree view
.br
.PP
\fC#include <qlistview.h>\fR
.PP
Inherits QScrollView.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQListView\fR ( QWidget * " "parent" ", const char * " "name" ", WFlags f ) "
.br
.ti -1c
.BI "\fBQListView\fR ( QWidget * " "parent" " = 0, const char * " "name" " = 0 ) "
.br
.ti -1c
.BI "\fB~QListView\fR () "
.br
.ti -1c
.BI "int \fBtreeStepSize\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetTreeStepSize\fR ( int ) "
.br
.ti -1c
.BI "virtual void \fBinsertItem\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "virtual void \fBtakeItem\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "virtual void removeItem ( QListViewItem * ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void \fBclear\fR () "
.br
.ti -1c
.BI "QHeader* \fBheader\fR () const"
.br
.ti -1c
.BI "virtual int \fBaddColumn\fR ( const QString & " "label" ", int " "size" " = -1 ) "
.br
.ti -1c
.BI "virtual int \fBaddColumn\fR ( const QIconSet & " "iconset" ", const QString & " "label" ", int " "size" " = -1 ) "
.br
.ti -1c
.BI "void \fBremoveColumn\fR ( int index ) "
.br
.ti -1c
.BI "virtual void \fBsetColumnText\fR ( int " "column" ", const QString & label ) "
.br
.ti -1c
.BI "virtual void \fBsetColumnText\fR ( int " "column" ", const QIconSet & " "iconset" ", const QString & label ) "
.br
.ti -1c
.BI "QString \fBcolumnText\fR ( int column ) const"
.br
.ti -1c
.BI "virtual void \fBsetColumnWidth\fR ( int " "column" ", int width ) "
.br
.ti -1c
.BI "int \fBcolumnWidth\fR ( int column ) const"
.br
.ti -1c
.BI "enum \fBWidthMode\fR { Manual, Maximum }"
.br
.ti -1c
.BI "virtual void \fBsetColumnWidthMode\fR ( int " "column" ", WidthMode ) "
.br
.ti -1c
.BI "WidthMode \fBcolumnWidthMode\fR ( int column ) const"
.br
.ti -1c
.BI "int \fBcolumns\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetColumnAlignment\fR ( int, int ) "
.br
.ti -1c
.BI "int \fBcolumnAlignment\fR ( int ) const"
.br
.ti -1c
.BI "QListViewItem* \fBitemAt\fR ( const QPoint & screenPos ) const"
.br
.ti -1c
.BI "QRect \fBitemRect\fR ( const QListViewItem * ) const"
.br
.ti -1c
.BI "int \fBitemPos\fR ( const QListViewItem * ) "
.br
.ti -1c
.BI "void \fBensureItemVisible\fR ( const QListViewItem * ) "
.br
.ti -1c
.BI "void \fBrepaintItem\fR ( const QListViewItem * ) const"
.br
.ti -1c
.BI "virtual void \fBsetMultiSelection\fR ( bool enable ) "
.br
.ti -1c
.BI "bool \fBisMultiSelection\fR () const"
.br
.ti -1c
.BI "enum \fBSelectionMode\fR { Single, Multi, Extended, NoSelection }"
.br
.ti -1c
.BI "void \fBsetSelectionMode\fR ( SelectionMode mode ) "
.br
.ti -1c
.BI "SelectionMode \fBselectionMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBclearSelection\fR () "
.br
.ti -1c
.BI "virtual void \fBsetSelected\fR ( QListViewItem *, bool ) "
.br
.ti -1c
.BI "bool \fBisSelected\fR ( const QListViewItem * ) const"
.br
.ti -1c
.BI "QListViewItem* \fBselectedItem\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetOpen\fR ( QListViewItem *, bool ) "
.br
.ti -1c
.BI "bool \fBisOpen\fR ( const QListViewItem * ) const"
.br
.ti -1c
.BI "virtual void \fBsetCurrentItem\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "QListViewItem* \fBcurrentItem\fR () const"
.br
.ti -1c
.BI "QListViewItem* \fBfirstChild\fR () const"
.br
.ti -1c
.BI "int \fBchildCount\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetAllColumnsShowFocus\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBallColumnsShowFocus\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetItemMargin\fR ( int ) "
.br
.ti -1c
.BI "int \fBitemMargin\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetRootIsDecorated\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBrootIsDecorated\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetSorting\fR ( int " "column" ", bool " "increasing" " = TRUE ) "
.br
.ti -1c
.BI "void \fBsort\fR () "
.br
.ti -1c
.BI "virtual bool \fBeventFilter\fR ( QObject * " "o" ", QEvent * ) "
.br
.ti -1c
.BI "void \fBsetShowSortIndicator\fR ( bool show ) "
.br
.ti -1c
.BI "bool \fBshowSortIndicator\fR () const"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "void \fBinvertSelection\fR () "
.br
.ti -1c
.BI "void \fBselectAll\fR ( bool select ) "
.br
.ti -1c
.BI "void \fBtriggerUpdate\fR () "
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBselectionChanged\fR () "
.br
.ti -1c
.BI "void \fBselectionChanged\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "void \fBcurrentChanged\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "void \fBclicked\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "void \fBclicked\fR ( QListViewItem *, const QPoint &, int ) "
.br
.ti -1c
.BI "void \fBpressed\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "void \fBpressed\fR ( QListViewItem *, const QPoint &, int ) "
.br
.ti -1c
.BI "void \fBdoubleClicked\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "void \fBreturnPressed\fR ( QListViewItem * ) "
.br
.ti -1c
.BI "void \fBrightButtonClicked\fR ( QListViewItem *, const QPoint &, int ) "
.br
.ti -1c
.BI "void \fBrightButtonPressed\fR ( QListViewItem *, const QPoint &, int ) "
.br
.ti -1c
.BI "void \fBmouseButtonPressed\fR ( int, QListViewItem *, const QPoint &, int ) "
.br
.ti -1c
.BI "void \fBmouseButtonClicked\fR ( int, QListViewItem *, const QPoint &, int ) "
.br
.ti -1c
.BI "void \fBonItem\fR ( QListViewItem * item ) "
.br
.ti -1c
.BI "void \fBonViewport\fR () "
.br
.ti -1c
.BI "void \fBexpanded\fR ( QListViewItem * item ) "
.br
.ti -1c
.BI "void \fBcollapsed\fR ( QListViewItem * item ) "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual void \fBcontentsMousePressEvent\fR ( QMouseEvent * e ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMouseReleaseEvent\fR ( QMouseEvent * e ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMouseMoveEvent\fR ( QMouseEvent * e ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMouseDoubleClickEvent\fR ( QMouseEvent * e ) "
.br
.ti -1c
.BI "virtual void \fBresizeEvent\fR ( QResizeEvent * e ) "
.br
.ti -1c
.BI "virtual void \fBdrawContentsOffset\fR ( QPainter *, int " "ox" ", int " "oy" ", int " "cx" ", int " "cy" ", int " "cw" ", int ch ) "
.br
.ti -1c
.BI "virtual void \fBpaintEmptyArea\fR ( QPainter *, const QRect & ) "
.br
.in -1c
.SS "Protected Slots"
.in +1c
.ti -1c
.BI "void \fBupdateContents\fR () "
.br
.ti -1c
.BI "void \fBdoAutoScroll\fR () "
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
int	columns	columns
bool	multiSelection	isMultiSelection	setMultiSelection	DESIGNABLE false
SelectionMode	selectionMode	selectionMode	setSelectionMode
int	childCount	childCount
bool	allColumnsShowFocus	allColumnsShowFocus	setAllColumnsShowFocus
bool	showSortIndicator	showSortIndicator	setShowSortIndicator
int	itemMargin	itemMargin	setItemMargin
bool	rootIsDecorated	rootIsDecorated	setRootIsDecorated
.TE
.fi

.SH DESCRIPTION
The QListView class implements a list/tree view.
.PP
It can display and control a hierarchy of multi-column items, and provides the ability to add new items at any time, let the user select one or many items, sort the list in increasing or decreasing order by any column, and so on.
.PP
The simplest mode of usage is to create a QListView, add some column headers using addColumn(), create one or more QListViewItem objects with the QListView as parent, set up the list view's geometry(), and show() it.
.PP
The main setup functions are 
.TP
addColumn() - adds a column, with text and perhaps width.
.TP
setColumnWidthMode() - sets the column to be resized automatically or not.
.TP
setAllColumnsShowFocus() - decides whether items should show keyboard focus using all columns, or just column 0. The default is to show focus using just column 0.
.TP
setRootIsDecorated() - decides whether root items can be opened and closed by the user, and have open/close decoration to their left. The default is FALSE.
.TP
setTreeStepSize() - decides the how many pixels an item's children are indented relative to their parent. The default is 20. This is mostly a matter of taste.
.TP
setSorting() - decides whether the items should be sorted, whether it should be in ascending or descending order, and by what column it should be sorted.
.PP
To handle events such as mouse-presses on the listview, derived classes can reimplement the QScrollView functions contentsMousePressEvent, contentsMouseReleaseEvent, contentsMouseDoubleClickEvent, contentsMouseMoveEvent, contentsDragEnterEvent, contentsDragMoveEvent, contentsDragLeaveEvent, contentsDropEvent, and contentsWheelEvent.
.PP
There are also several functions for mapping between items and coordinates. itemAt() returns the item at a position on-screen, itemRect() returns the rectangle an item occupies on the screen and itemPos() returns the position of any item (not on-screen, in the list view). firstChild() returns the item at the top of the view (not necessarily on-screen) so you can iterate over the items using either QListViewItem::itemBelow() or a combination of QListViewItem::firstChild() and QListViewItem::nextSibling().
.PP
Naturally, QListView provides a clear() function, as well as an explicit insertItem() for when QListViewItem's default insertion won't do.
.PP
There is a variety of selection modes, described in the QListView::SelectionMode documentation. The default is single-selection, and you can change it using setSelectionMode(). For compatibility with previous Qt versions there is still the setMultiSelection() methode. Calling setMultiSelection( TRUE ) is equivalent to setSelectionMode( Multi ), and setMultiSelection( FALSE ) is equivalent to setSelectionMode( Single ). It's suggested not to use setMultiSelection() anymore, but to use setSelectionMode() instead.
.PP
Since QListView offers multiple selection it has to display keyboard focus and selection state separately. Therefore there are functions both to set the selection state of an item, setSelected(), and to select which item displays keyboard focus, setCurrentItem().
.PP
QListView emits two groups of signals: One group signals changes in selection/focus state and one signals selection. The first group consists of selectionChanged(), applicable to all list views, and selectionChanged( QListViewItem * ), applicable only to single-selection list view, and currentChanged( QListViewItem * ). The second group consists of doubleClicked( QListViewItem * ), returnPressed( QListViewItem * ) and rightButtonClicked( QListViewItem *, const QPoint&, int ), etc.
.PP
In Motif style, QListView deviates fairly strongly from the look and feel of the Motif hierarchical tree view. This is done mostly to provide a usable keyboard interface and to make the list view look better with a white background.
.PP
\fBWarning:\fR The list view assumes ownership of all list view items and will delete them when it does not need them any more.
.PP
.ce 1
.B "[Image Omitted]"
.PP

.ce 1
.B "[Image Omitted]"
.PP
Examples:
.(l
xml/tagreader
.)l-with-features/tagreader.cpp
.SS "Member Type Documentation"
.SH "QListView::SelectionMode"
This enumerated type is used by QListView to indicate how it reacts to selection by the user. It has four values: 
.TP
\fCSingle\fR - When the user selects an item, any already-selected item becomes unselected, and the user cannot unselect the selected item. This means that the user can never clear the selection, even though the selection may be cleared by the application programmer using QListView::clearSelection().
.TP
\fCMulti\fR - When the user selects an item in the most ordinary way, the selection status of that item is toggled and the other items are left alone.
.TP
\fCExtended\fR - When the user selects an item in the most ordinary way, the selection is cleared and the new item selected. However, if the user presses the CTRL key when clicking on an item, the clicked item gets toggled and all other items are left untouched. And if the user presses the SHIFT key while clicking on an item, all items between the current item and the clicked item get selected or unselected depending on the state of the clicked item. Also multiple items can be selected by dragging the mouse while the left mouse button stayes pressed.
.TP
\fCNoSelection\fR - Items cannot be selected.
.IP
.PP
In other words, \fCSingle\fR is a real single-selection listview, \fCMulti\fR a real multi-selection listview, and \fCExtended\fR listview where users can select multiple items but usually want to select either just one or a range of contiguous items, and \fCNoSelection\fR is for a listview where the user can look but not touch.
.SH "QListView::WidthMode"
This enum type describes how the width of a column in the view changes. The currently defined modes are: 
.TP
\fCManual\fR - the column width does not change automatically
.TP
\fCMaximum\fR - the column is automatically sized according to the widths of all items in the column. (Note: The column never shrinks in this case.) This means the column is always resized to the width of the item with the largest width in the column.
.IP
.PP
See also setColumnWidth(), setColumnWidthMode() and columnWidth().
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QListView::QListView ( QWidget * parent = 0, const char * name = 0 )"
Constructs a new empty list view, with \fIparent\fR as a parent and \fIname\fR as object name.
.PP
Performance is boosted by modifying the widget flags so that only part of the QListViewItem children is redrawn. This may be unsuitable for custom QListViewItem classes, in which case \fCWNorthWestGravity\fR and \fCWRepaintNoErase\fR should be cleared.
.PP
See also QWidget::clearWFlags() and Qt::WidgetFlags.
.SH "QListView::QListView ( QWidget * parent, const char * name, WFlags f )"
Constructs a new empty list view, with \fIparent\fR as a parent and \fIname\fR as object name.
.PP
Performance is boosted by modifying the widget flags \fIf\fR so that only part of the QListViewItem children is redrawn. This may be unsuitable for custom QListViewItem classes, in which case \fCWNorthWestGravity\fR and \fCWRepaintNoErase\fR should be cleared.
.PP
See also QWidget::clearWFlags() and Qt::WidgetFlags.
.SH "QListView::~QListView ()"
Destructs the listview, deleting all items in it, and frees up all allocated resources.
.SH "int QListView::addColumn ( const QIconSet & iconset, const QString & label, int width = -1 ) \fC[virtual]\fR"
Adds a new column at the right end of the widget, with the header \fIlabel\fR and \fIiconset,\fR and returns the index of the column.
.PP
If \fIwidth\fR is negative, the new column will have WidthMode Maximum, otherwise it will be Manual at \fIwidth\fR pixels wide.
.PP
See also setColumnText(), setColumnWidth() and setColumnWidthMode().
.SH "int QListView::addColumn ( const QString & label, int width = -1 ) \fC[virtual]\fR"
Adds a new column at the right end of the widget, with the header \fIlabel,\fR and returns the index of the column.
.PP
If \fIwidth\fR is negative, the new column will have WidthMode Maximum, otherwise it will be Manual at \fIwidth\fR pixels wide.
.PP
See also setColumnText(), setColumnWidth() and setColumnWidthMode().
.PP
Examples:
.(l
dirview/main.cpp
.)l
.SH "bool QListView::allColumnsShowFocus () const"
Returns TRUE if the items in this list view indicate focus and selection state using all of their columns, else FALSE.
.PP
See also setAllColumnsShowFocus().
.SH "int QListView::childCount () const"
Returns the current number of parentless QListViewItem objects in this QListView, like QListViewItem::childCount() returns the number of child items for a QListViewItem.
.PP
See also QListViewItem::childCount().
.SH "void QListView::clear () \fC[virtual]\fR"
Remove and delete all the items in this list view, and trigger an update.
.PP
See also triggerUpdate().
.SH "void QListView::clearSelection () \fC[virtual]\fR"
Sets all items to be not selected, updates the list view as necessary and emits the selectionChanged() signals. Note that for multi-selection list views, this function needs to iterate over \fIall\fR items.
.PP
See also setSelected() and setMultiSelection().
.SH "void QListView::clicked ( QListViewItem * item ) \fC[signal]\fR"
This signal is emitted whenever the user clicks (mouse pressed + mouse released) into the listview. \fIitem\fR is the pointer to the clicked listview item or NULL, if the user didn't click on an item.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.SH "void QListView::clicked ( QListViewItem * item, const QPoint & pnt, int c ) \fC[signal]\fR"
This signal is emitted whenever the user clicks (mouse pressed + mouse released) into the listview. \fIitem\fR is the pointer to the clicked listview item or NULL, if the user didn't click on an item. \fIpnt\fR is the position where the user has clicked, and \fIc\fR the column into which the user clicked.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.SH "void QListView::collapsed ( QListViewItem * item ) \fC[signal]\fR"
This signals is emitted when the \fIitem\fR has been collapsed. This means the children of the item are hidden because the user double-clicked the item or clicked on the root decoration, or setOpen() with FALSE as argument has been called.
.PP
See also expanded().
.SH "int QListView::columnAlignment ( int column ) const"
Returns the alignment of logical column \fIcolumn.\fR The default is \fCAlignLeft.\fR
.PP
See also Qt::AlignmentFlags.
.SH "QString QListView::columnText ( int c ) const"
Returns the text of column \fIc.\fR
.SH "int QListView::columnWidth ( int c ) const"
Returns the width of column \fIc.\fR
.SH "QListView::WidthMode QListView::columnWidthMode( int c ) const"
Returns the currently set WidthMode for column \fIc.\fR
.PP
See also setColumnWidthMode().
.SH "int QListView::columns () const"
Returns the number of columns of this list view.
.PP
See also addColumn() and removeColumn().
.SH "void QListView::contentsMouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Processes mouse double-click events on behalf of the viewed widget.
.PP
Reimplemented from QScrollView.
.SH "void QListView::contentsMouseMoveEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Processes mouse move events on behalf of the viewed widget.
.PP
Reimplemented from QScrollView.
.SH "void QListView::contentsMousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Processes mouse move events on behalf of the viewed widget.
.PP
Reimplemented from QScrollView.
.SH "void QListView::contentsMouseReleaseEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
Processes mouse move events on behalf of the viewed widget.
.PP
Reimplemented from QScrollView.
.SH "void QListView::currentChanged ( QListViewItem * ) \fC[signal]\fR"
This signal is emitted whenever the current item has changed (normally after the screen update). The current item is the item responsible for indicating keyboard focus.
.PP
The argument is the newly current item, or 0 if the change was to make no item current. This can happen e.g. if all items in the list view are deleted.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.PP
See also setCurrentItem() and currentItem().
.SH "QListViewItem * QListView::currentItem () const"
Returns a pointer to the currently highlighted item, or 0 if there isn't any.
.PP
See also setCurrentItem().
.SH "void QListView::doAutoScroll () \fC[protected slot]\fR"
This slot handles auto-scrolling when the mouse button is pressed and the mouse is outside the widget.
.SH "void QListView::doubleClicked ( QListViewItem * item ) \fC[signal]\fR"
This signal is emitted whenever an item is double-clicked. It's emitted on the second button press, not the second button release. \fIitem\fR is the listview item onto which the user did the double click.
.SH "void QListView::drawContentsOffset ( QPainter * p, int ox, int oy, int cx, int cy, int cw, int ch ) \fC[virtual protected]\fR"
Calls QListViewItem::paintCell() and/or QListViewItem::paintBranches() for all list view items that require repainting. See the documentation for those functions for details.
.PP
Reimplemented from QScrollView.
.SH "void QListView::enabledChange ( bool e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListView::ensureItemVisible ( const QListViewItem * i )"
Ensures that \fIi\fR is made visible, scrolling the list view vertically as required and opens (expands)also all parent items if they hide their children.
.PP
See also itemRect() and QScrollView::ensureVisible().
.SH "bool QListView::eventFilter ( QObject * o, QEvent * e ) \fC[virtual]\fR"
Redirects events for the viewport to mousePressEvent(), keyPressEvent() and friends.
.PP
Reimplemented from QObject.
.SH "void QListView::expanded ( QListViewItem * item ) \fC[signal]\fR"
This signals is emitted when the \fIitem\fR has been expanded. This means the children of the item are shown because the user double-clicked the item or clicked on the root decoration, or setOpen() with TRUE as argument has been called.
.PP
See also collapsed().
.SH "QListViewItem * QListView::firstChild () const"
Returns the first item in this QListView. You can use its firstChild() and nextSibling() functions to traverse the entire tree of items.
.PP
Returns 0 if there is no first item.
.PP
See also itemAt(), QListViewItem::itemBelow() and QListViewItem::itemAbove().
.SH "void QListView::focusInEvent ( QFocusEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListView::focusOutEvent ( QFocusEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QHeader * QListView::header () const"
Returns a pointer to the QHeader object that manages this list view's columns. Please don't modify the header behind the list view's back.
.PP
Acceptable methods to call are:
.TP
void QHeader::setClickEnabled( bool, int logIdx = -1 );
.TP
void QHeader::setResizeEnabled( bool, int logIdx = -1 );
.TP
void QHeader::setMovingEnabled( bool );
.SH "void QListView::insertItem ( QListViewItem * i ) \fC[virtual]\fR"
Inserts \fIi\fR into the list view as a top-level item. You do not need to call this unless you've called takeItem( \fIi\fR ) or QListViewItem::takeItem( i ) and need to reinsert \fIi\fR elsewhere.
.PP
See also QListViewItem::takeItem(), (important) and takeItem().
.SH "void QListView::invertSelection () \fC[slot]\fR"
Inverts the selection. Works only in Multi and Extended selection mode.
.SH "bool QListView::isMultiSelection () const"
Returns TRUE if this list view is in multi-selection mode and FALSE if it is in single-selection mode.
.PP
See also setMultiSelection().
.SH "bool QListView::isOpen ( const QListViewItem * item ) const"
Identical to \fIitem->isOpen().\fR Provided for completeness.
.PP
See also setOpen().
.SH "bool QListView::isSelected ( const QListViewItem * i ) const"
Returns i->isSelected().
.PP
Provided only because QListView provides setSelected() and trolls are neat creatures and like neat, orthogonal interfaces.
.SH "QListViewItem * QListView::itemAt ( const QPoint & viewPos ) const"
Returns a pointer to the QListViewItem at \fIviewPos.\fR Note that \fIviewPos\fR is in the coordinate system of viewport(), not in the listview's own, much larger, coordinate system.
.PP
itemAt() returns 0 if there is no such item.
.PP
Note, that you also get the pointer to the item if \fIviewPos\fR points onto the root decoration (see setRootIsDecorated()) of the item. To check if \fIviewPos\fR is on the root decoration of the item or not, you can do something like
.PP
.nf
.br
  QListViewItem *i = itemAt( p );
.br
  if ( i ) {
.br
      if ( p.x() > header()->cellPos( header()->mapToActual( 0 ) ) +
.br
             treeStepSize() * ( i->depth() + ( rootIsDecorated() ? 1 : 0) ) + itemMargin() ||
.br
             p.x() < header()->cellPos( header()->mapToActual( 0 ) ) ) {
.br
          ; // p is not not in root decoration
.br
      else
.br
          ; // p is in the root decoration
.br
  }
.fi
.PP
This might be interesting if you use this method to find out where the user clicked and if you e.g. want to start a drag (which you do not want to do if the user clicked onto the root decoration of an item)
.PP
See also itemPos() and itemRect().
.SH "int QListView::itemMargin () const"
Returns the advisory item margin which list items may use.
.PP
See also QListViewItem::paintCell() and setItemMargin().
.SH "int QListView::itemPos ( const QListViewItem * item )"
Returns the y coordinate of \fIitem\fR in the list view's coordinate system. This functions is normally much slower than itemAt(), but it works for all items, while itemAt() normally works only for items on the screen.
.PP
This is a thin wrapper around QListViewItem::itemPos().
.PP
See also itemAt() and itemRect().
.SH "QRect QListView::itemRect ( const QListViewItem * i ) const"
Returns the rectangle on the screen \fIi\fR occupies in viewport()'s coordinates, or an invalid rectangle if \fIi\fR is a null pointer or is not currently visible.
.PP
The rectangle returned does not include any children of the rectangle (ie. it uses QListViewItem::height() rather than QListViewItem::totalHeight()). If you want the rectangle including children, you can use something like this code:
.PP
.nf
.br
    QRect r( listView->itemRect( item ) );
.br
    r.setHeight( (QCOORD)(QMIN( item->totalHeight(),
.br
                                listView->viewport->height() - r.y() ) ) )
.fi
.PP
Note the way it avoids too-high rectangles. totalHeight() can be much larger than the window system's coordinate system allows.
.PP
itemRect() is comparatively slow. It's best to call it only for items that are probably on-screen.
.SH "void QListView::keyPressEvent ( QKeyEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QSize QListView::minimumSizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListView::mouseButtonClicked ( int button, QListViewItem * item, const QPoint & pos, int c ) \fC[signal]\fR"
This signal is emitted whenever the user clicks (mouse pressed + mouse released) into the listview. \fIbutton\fR is the mouse button which the user pressed, \fIitem\fR is the pointer to the clicked listview item or NULL, if the user didn't click on an item, and \fIc\fR the listview column into which the user pressed (this argument is only valid, if \fIitem\fR is not NULL!)
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.SH "void QListView::mouseButtonPressed ( int button, QListViewItem * item, const QPoint & pos, int c ) \fC[signal]\fR"
This signal is emitted whenever the user pressed the mouse button onto the listview. \fIbutton\fR is the mouse button which the user pressed, \fIitem\fR is the pointer to the pressed listview item or NULL, if the user didn't press on an item, and \fIc\fR the listview column into which the user pressed (this argument is only valid, if \fIitem\fR is not NULL!)
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.SH "void QListView::onItem ( QListViewItem * i ) \fC[signal]\fR"
This signal is emitted, when the user moves the mouse cursor onto an item. It´s only emitted once per item.
.SH "void QListView::onViewport () \fC[signal]\fR"
This signal is emitted, when the user moves the mouse cursor, which was on an item away from the item onto the viewport.
.SH "void QListView::paintEmptyArea ( QPainter * p, const QRect & rect ) \fC[virtual protected]\fR"
Paints \fIrect\fR so that it looks like empty background using painter p. \fIrect\fR is is widget coordinates, ready to be fed to \fIp.\fR
.PP
The default function fills \fIrect\fR with colorGroup().brush( QColorGroup::Base ).
.SH "void QListView::pressed ( QListViewItem * item ) \fC[signal]\fR"
This signal is emitted whenever the user presses the mouse button on a listview. \fIitem\fR is the pointer to the listview item onto which the user pressed the mouse button or NULL, if the user didn't press the mouse on an item.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.SH "void QListView::pressed ( QListViewItem * item, const QPoint & pnt, int c ) \fC[signal]\fR"
This signal is emitted whenever the user presses the mouse button on a listview. \fIitem\fR is the pointer to the listview item onto which the user pressed the mouse button or NULL, if the user didn't press the mouse on an item. \fIpnt\fR is the position of the mouse cursor, and \fIc\fR the column into which the mouse cursor was when the user pressed the mouse button.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.SH "void QListView::removeColumn ( int index )"
Removes the column at position \fIindex.\fR
.SH "void QListView::removeItem ( QListViewItem * i ) \fC[virtual]\fR"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
This function has been renamed takeItem().
.SH "void QListView::repaintItem ( const QListViewItem * item ) const"
Repaints \fIitem\fR on the screen, if \fIitem\fR is currently visible. Takes care to avoid multiple repaints.
.SH "void QListView::resizeEvent ( QResizeEvent * e ) \fC[virtual protected]\fR"
Ensures that the header is correctly sized and positioned.
.PP
Reimplemented from QWidget.
.SH "void QListView::returnPressed ( QListViewItem * ) \fC[signal]\fR"
This signal is emitted when enter or return is pressed. The argument is currentItem().
.SH "void QListView::rightButtonClicked ( QListViewItem *, const QPoint &, int ) \fC[signal]\fR"
This signal is emitted when the right button is clicked (ie. when it's released). The arguments are the relevant QListViewItem (may be 0), the point in global coordinates and the relevant column (or -1 if the click was outside the list).
.SH "void QListView::rightButtonPressed ( QListViewItem *, const QPoint &, int ) \fC[signal]\fR"
This signal is emitted when the right button is pressed. Then arguments are the relevant QListViewItem (may be 0), the point in global coordinates and the relevant column (or -1 if the click was outside the list).
.SH "bool QListView::rootIsDecorated () const"
Returns TRUE if root items can be opened and closed by the user, FALSE if not.
.SH "void QListView::selectAll ( bool select ) \fC[slot]\fR"
If \fIselect\fR is TRUE, all items get selected, else all get unselected. This works only in the selection modes Multi and Extended. In Single and NoSelection mode the selection of the current item is just set to \fIselect.\fR
.SH "QListViewItem * QListView::selectedItem () const"
Returns a pointer to the selected item, if the list view is in single-selection mode and an item is selected.
.PP
If no items are selected or the list view is in multi-selection mode this function returns 0.
.PP
See also setSelected() and setMultiSelection().
.SH "void QListView::selectionChanged () \fC[signal]\fR"
This signal is emitted whenever the set of selected items has changed (normally before the screen update). It is available both in single-selection and multi-selection mode, but is most meaningful in multi-selection mode.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.PP
See also setSelected() and QListViewItem::setSelected().
.SH "void QListView::selectionChanged ( QListViewItem * ) \fC[signal]\fR"
This signal is emitted whenever the selected item has changed in single-selection mode (normally after the screen update). The argument is the newly selected item.
.PP
There is another signal which is more useful in multi-selection mode.
.PP
Note that you may not delete any QListViewItem objects in slots connected to this signal.
.PP
See also setSelected(), QListViewItem::setSelected() and currentChanged().
.SH "QListView::SelectionMode QListView::selectionMode() const"
Returns the selection mode of the list view. The initial mode is \fCSingle.\fR
.PP
See also setSelectionMode(), isMultiSelection() and setMultiSelection().
.SH "void QListView::setAllColumnsShowFocus ( bool enable ) \fC[virtual]\fR"
Sets this list view to assume that the items show focus and selection state using all of their columns if \fIenable\fR is TRUE, or that they show it just using column 0 if \fIenable\fR is FALSE.
.PP
The default is FALSE.
.PP
Setting this to TRUE if it isn't necessary can cause noticeable flicker.
.PP
See also allColumnsShowFocus().
.PP
Examples:
.(l
dirview/main.cpp
.)l
.SH "void QListView::setColumnAlignment ( int column, int align ) \fC[virtual]\fR"
Configures the logical column \fIcolumn\fR to have alignment \fIalign.\fR The alignment is ultimately passed to QListViewItem::paintCell() for each item in the view.
.PP
See also Qt::AlignmentFlags.
.SH "void QListView::setColumnText ( int column, const QIconSet & iconset, const QString & label ) \fC[virtual]\fR"
Sets the heading text of column \fIcolumn\fR to \fIiconset\fR and \fIlabel.\fR The leftmost colum is number 0.
.SH "void QListView::setColumnText ( int column, const QString & label ) \fC[virtual]\fR"
Sets the heading text of column \fIcolumn\fR to \fIlabel.\fR The leftmost colum is number 0.
.SH "void QListView::setColumnWidth ( int column, int w ) \fC[virtual]\fR"
Sets the width of column \fIcolumn\fR to \fIw\fR pixels. Note that if the column has a WidthMode other than Manual, this width setting may be subsequently overridden. The leftmost colum is number 0.
.SH "void QListView::setColumnWidthMode ( int c, WidthMode mode )"
Sets column \fIc\fR to behave according to \fImode.\fR The default depends on whether the width argument to addColumn was positive or negative.
.PP
See also QListViewItem::width().
.SH "void QListView::setContentsPos ( int x, int y ) \fC[virtual slot]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QScrollView.
.SH "void QListView::setCurrentItem ( QListViewItem * i ) \fC[virtual]\fR"
Sets \fIi\fR to be the current highlighted item and repaints appropriately. This highlighted item is used for keyboard navigation and focus indication; it doesn't mean anything else.
.PP
See also currentItem().
.SH "void QListView::setFont ( const QFont & f ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QListView::setItemMargin ( int m ) \fC[virtual]\fR"
Sets the advisory item margin which list items may use to \fIm.\fR
.PP
The item margin defaults to one pixel and is the margin between the item's edges and the area where it draws its contents. QListViewItem::paintFocus() draws in the margin.
.PP
See also QListViewItem::paintCell().
.SH "void QListView::setMultiSelection ( bool enable ) \fC[virtual]\fR"
Sets the list view to multi-selection mode if \fIenable\fR is TRUE, and to single-selection mode if \fIenable\fR is FALSE.
.PP
If you enable multi-selection mode, it's possible to specify if this mode should be \fIextended\fR or not. Extended means, that the user can only select multiple items when pressing the Shift or Control button at the same time.
.PP
See also isMultiSelection().
.SH "void QListView::setOpen ( QListViewItem * item, bool open ) \fC[virtual]\fR"
Sets \fIitem\fR to be open if \fIopen\fR is TRUE and \fIitem\fR is expandable, and to be closed if \fIopen\fR is FALSE. Repaints accordingly.
.PP
Does nothing if \fIitem\fR is not expandable.
.PP
See also QListViewItem::setOpen() and QListViewItem::setExpandable().
.SH "void QListView::setPalette ( const QPalette & p ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QListView::setRootIsDecorated ( bool enable ) \fC[virtual]\fR"
Sets this list view to show open/close signs on root items if \fIenable\fR is TRUE, and to not show such signs if \fIenable\fR is FALSE.
.PP
Open/close signs is a little + or - in windows style, an arrow in Motif style.
.SH "void QListView::setSelected ( QListViewItem * item, bool selected ) \fC[virtual]\fR"
Sets \fIitem\fR to be selected if \fIselected\fR is TRUE, and to be not selected if \fIselected\fR is FALSE.
.PP
If the list view is in single-selection mode and \fIselected\fR is TRUE, the currently selected item is unselected and \fIitem\fR made current. Unlike QListViewItem::setSelected(), this function updates the list view as necessary and emits the selectionChanged() signals.
.PP
See also isSelected(), setMultiSelection(), isMultiSelection() and setCurrentItem().
.SH "void QListView::setSelectionMode ( SelectionMode mode )"
Sets the list view's selection mode, which may be one of \fCSingle\fR (the default), \fCExtended, Multi\fR or \fCNoSelection.\fR
.PP
See also selectionMode().
.SH "void QListView::setShowSortIndicator ( bool show )"
If \fIshow\fR is TRUE, draw an arrow in the header of the listview to indicate the sort order of the listview contents. The arrow will be drawn in the correct column and will point to the correct direction. Set \fIshow\fR to FALSE to disable this feature.
.PP
See also QHeader::setSortIndicator().
.SH "void QListView::setSorting ( int column, bool ascending = TRUE ) \fC[virtual]\fR"
Set the list view to be sorted by \fIcolumn\fR and to be sorted in ascending order if \fIascending\fR is TRUE or descending order if it is FALSE.
.PP
If \fIcolumn\fR is -1, sorting is disabled and the user cannot sort columns by clicking on the column headers.
.SH "void QListView::setTreeStepSize ( int l ) \fC[virtual]\fR"
Sets the the number of pixels a child is offset from its parent, in a tree view to \fIl.\fR The default is 20.
.PP
See also treeStepSize().
.PP
Examples:
.(l
dirview/main.cpp
.)l
.SH "void QListView::show () \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Examples:
.(l
dirview/main.cpp
.)l
.PP
Reimplemented from QWidget.
.SH "void QListView::showEvent ( QShowEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "bool QListView::showSortIndicator () const"
Returns TRUE, if the sort order and column are indicated in the header, else FALSE.
.PP
See also QListView::setSortIndicator().
.SH "QSize QListView::sizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListView::sort ()"
(Re)sorts the listview using the last sorting configuration (sort column and ascending/descending).
.SH "void QListView::styleChange ( QStyle & old ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QListView::takeItem ( QListViewItem * i ) \fC[virtual]\fR"
Removes \fIi\fR from the list view; \fIi\fR must be a top-level item. The warnings regarding QListViewItem::takeItem( i ) apply to this function too.
.PP
See also QListViewItem::takeItem(), (important) and insertItem().
.SH "int QListView::treeStepSize () const"
Returns the number of pixels a child is offset from its parent. This number has meaning only for tree views. The default is 20.
.PP
See also setTreeStepSize().
.SH "void QListView::triggerUpdate () \fC[slot]\fR"
Triggers a size, geometry and content update during the next iteration of the event loop. Cleverly makes sure that there'll be just one update, to avoid flicker.
.SH "void QListView::updateContents () \fC[protected slot]\fR"
Updates the sizes of the viewport, header, scrollbars and so on.
Don't call this directly; call triggerUpdate() instead.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qlistview.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qlistview.3qt) and the Qt
version (2.3.2).
