'\" t
.TH QObject 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QObject \- The base class of all Qt objects
.br
.PP
\fC#include <qobject.h>\fR
.PP
Inherits Qt.
.PP
Inherited by QAccel, QAction, QApplication, QAuServer, QCanvas, QClipboard, QCopChannel, QDataPump, QDns, QDnsSocket, QDragManager, QDragObject, QFileIconProvider, QGuardedPtrPrivate, QLayout, QNPInstance, QNetworkOperation, QNetworkProtocol, QSenderObject, QServerSocket, QSessionManager, QSignal, QSignalMapper, QSocket, QSocketNotifier, QSound, QStyle, QStyleSheet, QTimer, QToolTipGroup, QTranslator, QUrlOperator, QValidator, QWSClient, QWSServer and QWidget.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQObject\fR ( QObject * " "parent" "=0, const char * " "name" "=0 ) "
.br
.ti -1c
.BI "virtual \fB~QObject\fR () "
.br
.ti -1c
.BI "virtual bool \fBevent\fR ( QEvent * ) "
.br
.ti -1c
.BI "virtual bool \fBeventFilter\fR ( QObject *, QEvent * ) "
.br
.ti -1c
.BI "virtual QMetaObject* \fBmetaObject\fR () const"
.br
.ti -1c
.BI "virtual const char* \fBclassName\fR () const"
.br
.ti -1c
.BI "bool \fBisA\fR ( const char * ) const"
.br
.ti -1c
.BI "bool \fBinherits\fR ( const char * ) const"
.br
.ti -1c
.BI "const char* \fBname\fR () const"
.br
.ti -1c
.BI "const char* \fBname\fR ( const char * defaultName ) const"
.br
.ti -1c
.BI "virtual void \fBsetName\fR ( const char * name ) "
.br
.ti -1c
.BI "bool \fBisWidgetType\fR () const"
.br
.ti -1c
.BI "bool \fBhighPriority\fR () const"
.br
.ti -1c
.BI "bool \fBsignalsBlocked\fR () const"
.br
.ti -1c
.BI "void \fBblockSignals\fR ( bool b ) "
.br
.ti -1c
.BI "int \fBstartTimer\fR ( int interval ) "
.br
.ti -1c
.BI "void \fBkillTimer\fR ( int id ) "
.br
.ti -1c
.BI "void \fBkillTimers\fR () "
.br
.ti -1c
.BI "QObject* \fBchild\fR ( const char * " "name" ", const char * " "type" " = 0 ) "
.br
.ti -1c
.BI "const QObjectList* \fBchildren\fR () const"
.br
.ti -1c
.BI "QObjectList* \fBqueryList\fR ( const char * " "inheritsClass" " = 0, const char * " "objName" " = 0, bool " "regexpMatch" " = TRUE, bool " "recursiveSearch" " = TRUE ) "
.br
.ti -1c
.BI "virtual void \fBinsertChild\fR ( QObject * ) "
.br
.ti -1c
.BI "virtual void \fBremoveChild\fR ( QObject * ) "
.br
.ti -1c
.BI "void \fBinstallEventFilter\fR ( const QObject * ) "
.br
.ti -1c
.BI "void \fBremoveEventFilter\fR ( const QObject * ) "
.br
.ti -1c
.BI "bool \fBconnect\fR ( const QObject * " "sender" ", const char * " "signal" ", const char * member ) const"
.br
.ti -1c
.BI "bool \fBdisconnect\fR ( const char * " "signal" "=0, const QObject * " "receiver" "=0, const char * " "member" "=0 ) "
.br
.ti -1c
.BI "bool \fBdisconnect\fR ( const QObject * " "receiver" ", const char * " "member" "=0 ) "
.br
.ti -1c
.BI "void \fBdumpObjectTree\fR () "
.br
.ti -1c
.BI "void \fBdumpObjectInfo\fR () "
.br
.ti -1c
.BI "bool \fBsetProperty\fR ( const char * " "name" ", const QVariant & value ) "
.br
.ti -1c
.BI "QVariant \fBproperty\fR ( const char * name ) const"
.br
.ti -1c
.BI "QObject* \fBparent\fR () const"
.br
.ti -1c
.BI "QStringList superClasses ( bool " "includeThis" " = FALSE ) const \fI(obsolete)\fR"
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBdestroyed\fR () "
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "QString \fBtr\fR ( const char * ) "
.br
.ti -1c
.BI "QString \fBtr\fR ( const char *, const char * ) "
.br
.ti -1c
.BI "const QObjectList* \fBobjectTrees\fR () "
.br
.ti -1c
.BI "bool \fBconnect\fR ( const QObject * " "sender" ", const char * " "signal" ", const QObject * " "receiver" ", const char * member ) "
.br
.ti -1c
.BI "bool \fBdisconnect\fR ( const QObject * " "sender" ", const char * " "signal" ", const QObject * " "receiver" ", const char * member ) "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "bool \fBactivate_filters\fR ( QEvent * ) (internal)"
.br
.ti -1c
.BI "QConnectionList* \fBreceivers\fR ( const char * signal ) const"
.br
.ti -1c
.BI "void \fBactivate_signal\fR ( const char * signal ) (internal)"
.br
.ti -1c
.BI "void \fBactivate_signal\fR ( const char * " "signal" ", short ) "
.br
.ti -1c
.BI "void \fBactivate_signal\fR ( const char * " "signal" ", int ) "
.br
.ti -1c
.BI "void \fBactivate_signal\fR ( const char * " "signal" ", long ) "
.br
.ti -1c
.BI "void \fBactivate_signal\fR ( const char * " "signal" ", const char * ) "
.br
.ti -1c
.BI "void \fBactivate_signal_bool\fR ( const char * " "signal" ", bool ) "
.br
.ti -1c
.BI "void \fBactivate_signal_string\fR ( const char * " "signal" ", QString ) "
.br
.ti -1c
.BI "void \fBactivate_signal_strref\fR ( const char * " "signal" ", const QString & ) "
.br
.ti -1c
.BI "const QObject* \fBsender\fR () "
.br
.ti -1c
.BI "virtual void \fBinitMetaObject\fR () "
.br
.ti -1c
.BI "virtual void \fBtimerEvent\fR ( QTimerEvent * ) "
.br
.ti -1c
.BI "virtual void \fBchildEvent\fR ( QChildEvent * ) "
.br
.ti -1c
.BI "virtual void \fBconnectNotify\fR ( const char * signal ) "
.br
.ti -1c
.BI "virtual void \fBdisconnectNotify\fR ( const char * signal ) "
.br
.ti -1c
.BI "virtual bool \fBcheckConnectArgs\fR ( const char * " "signal" ", const QObject * " "receiver" ", const char * member ) "
.br
.in -1c
.SS "Static Protected Members"
.in +1c
.ti -1c
.BI "QMetaObject* \fBstaticMetaObject\fR () "
.br
.ti -1c
.BI "QCString \fBnormalizeSignalSlot\fR ( const char * signalSlot ) "
.br
.ti -1c
.BI "void \fBbadSuperclassWarning\fR ( const char * " "className" ", const char * superclassName ) "
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
(Note that these are not member functions.)
.in +1c
.ti -1c
.BI "void * \fBqt_find_obj_child\fR (QObject * " "parent" ", const char * " "type" ", const char * " "name" ")"
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
QCString	name	name	setName
.TE
.fi

.SH DESCRIPTION
The QObject class is the base class of all Qt objects.
.PP
QObject is the heart of the Qt object model. The central feature in this model is a very powerful mechanism for seamless object commuinication dubbed signals and slots. With connect(), you can connect a signal to a slot and destroy the connection again with disconnect(). To avoid never-ending notification loops, you can temporarily block signals with blockSignals(). The protected functions connectNotify() and disconnectNotify() make it possible to track connections.
.PP
QObjects organize themselves in object trees. When you create a QObject with another object as parent, it will automatically do an insertChild() on the parent and thus show up in the parent's children() list. The parent receives object ownership, i.e. it will automatically delete its children in its destructor. You can look for an object by name and optionally type using child() or queryList(), and get the list of tree roots using objectTrees().
.PP
Every object has an object name() and can report its className() and whether it inherits() another class in the QObject inheritance hierarchy.
.PP
When an object is deleted, it emits a destroyed() signal. You can catch this signal to avoid dangling references to QObjects. The QGuardedPtr class provides an elegant way to use this feature.
.PP
QObjects can receive events through event() and filter events of other objects. See installEventFilter() and eventFilter() for details. A convenience handler childEvent() can be reimplemented to catch child events.
.PP
Last but not least, QObject provides the basic timer support in Qt, see QTimer for high-level support for timers.
.PP
Notice that the \fCQ_OBJECT\fR macro is mandatory for any object that implement signals, slots or properties. You also need to run the moc program (Meta Object Compiler) on the source file. We strongly recommend to use the macro in \fIall\fR subclasses of QObject regardless whether they actually use signals, slots and properties or not. Otherwise certain functions can show undefined behaviour.
.PP
All Qt widgets inherit QObject. The convenience function isWidgetType() returns whether an object is actually a widget. It is much faster than inherits( "QWidget" ).
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QObject::QObject ( QObject * parent=0, const char * name=0 )"
Constructs an object with the parent object \fIparent\fR and a \fIname.\fR
.PP
The parent of an object may be viewed as the object's owner. For instance, a dialog box is the parent of the" ok" and "cancel" buttons inside it.
.PP
The destructor of a parent object destroys all child objects.
.PP
Setting \fIparent\fR to 0 constructs an object with no parent. If the object is a widget, it will become a top-level window.
.PP
The object name is a text that can be used to identify this QObject. It's particularly useful in conjunction with the Qt Designer. You can find an object by name (and type) using child(), and more than one using queryList().
.PP
See also parent(), name(), child() and queryList().
.SH "QObject::~QObject () \fC[virtual]\fR"
Destructs the object, deleting all its child objects.
.PP
All signals to and from the object are automatically disconnected.
.PP
\fBWarning:\fR \fIAll\fR child objects are deleted. If any of these objects are on the stack or global, your program will sooner or later crash. We do not recommend holding pointers to child objects from outside the parent. If you still do, the QObject::destroyed() signal gives you an opportunity to detect when an object is destroyed.
.SH "void QObject::activate_signal ( const char * signal, const char * ) \fC[protected]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QObject::activate_signal ( const char * signal, int ) \fC[protected]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QObject::activate_signal ( const char * signal, long ) \fC[protected]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QObject::activate_signal ( const char * signal, short ) \fC[protected]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QObject::activate_signal_bool ( const char * signal, bool ) \fC[protected]\fR"
For internal use only.
.SH "void QObject::activate_signal_string ( const char * signal, QString ) \fC[protected]\fR"
For internal use only.
.SH "void QObject::activate_signal_strref ( const char * signal, const QString & ) \fC[protected]\fR"
For internal use only.
.SH "void QObject::badSuperclassWarning ( const char * className, const char * superclassName ) \fC[static protected]\fR"
Internal function, called from initMetaObject(). Used to emit a warning when a class containing the macro Q_OBJECT inherits from a class that does not contain it.
.SH "void QObject::blockSignals ( bool block )"
Blocks signals if \fIblock\fR is TRUE, or unblocks signals if \fIblock\fR is FALSE.
.PP
Emitted signals disappear into hyperspace if signals are blocked.
.SH "bool QObject::checkConnectArgs ( const char * signal, const QObject * receiver, const char * member ) \fC[virtual protected]\fR"
Returns TRUE if the \fIsignal\fR and the \fImember\fR arguments are compatible, otherwise FALSE.
.PP
\fBWarning:\fR We recommend that you do not reimplement this function but use the default implementation.
.SH "QObject* QObject::child ( const char * name, const char * type = 0 )"
Searches through the children and grandchildren of this object for an object named \fIname\fR and with type \fItype\fR (or a subclass of that type), and returns a pointer to that object if it exists. If \fItype\fR is 0, any type matches.
.PP
If there isn't any such object, this function returns null.
.PP
If there is more than one, one of them is returned; use queryList() if you need all of them.
.SH "void QObject::childEvent ( QChildEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive child events.
.PP
Child events are sent to objects when children are inserted or removed.
.PP
Note that events with QEvent::type() \fCQEvent::ChildInserted\fR are \fIposted\fR (with QApplication::postEvent()), to make sure that the child's construction is completed before this function is called.
.PP
Note that if a child is removed immediately after it is inserted, the \fCChildInserted\fR event may be suppressed, but the \fCChildRemoved\fR event will always be sent. In this case there will be a \fCChildRemoved\fR event without a corresponding \fCChildInserted\fR event.
.PP
If you change state based on \fCChildInserted\fR events, call QWidget::constPolish(), or do \fCQApplication::sendPostedEvents( this, QEvent::ChildInserted );\fR in functions that depend on the state. One notable example is QWidget::sizeHint().
.PP
See also event() and QChildEvent.
.PP
Reimplemented in QWorkspace, QWidgetStack, QGroupBox, QMainWindow and QSplitter.
.SH "const QObjectList * QObject::children () const"
Returns a list of child objects, or 0 if this object has no children.
.PP
The QObjectList class is defined in the qobjectlist.h header file.
.PP
The latest child added is the first object in the list and the first child added is the last object in the list.
.PP
Note that the list order changes when QWidget children are raised or lowered. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.
.PP
See also child(), queryList(), parent(), insertChild() and removeChild().
.SH "const char * QObject::className () const \fC[virtual]\fR"
Returns the class name of this object.
.PP
This function is generated by the Meta Object Compiler.
.PP
\fBWarning:\fR This function will return an invalid name if the class definition lacks the \fCQ_OBJECT\fR macro.
.PP
See also name(), inherits(), isA() and isWidgetType().
.SH "bool QObject::connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member ) \fC[static]\fR"
Connects \fIsignal\fR from the \fIsender\fR object to \fImember\fR in object \fIreceiver.\fR
.PP
You must use the SIGNAL() and SLOT() macros when specifying the \fIsignal\fR and the \fImember.\fR
.PP
Example:
.PP
.nf
.br
    QLabel     *label  = new QLabel;
.br
    QScrollBar *scroll = new QScrollBar;
.br
    QObject::connect( scroll, SIGNAL(valueChanged(int)),
.br
                      label,  SLOT(setNum(int)) );
.fi
.PP
This example connects the scroll bar's valueChanged() signal to the label's setNum() slot. It makes the label always display the current scroll bar value.
.PP
A signal can even be connected to another signal, i.e. \fImember\fR is a SIGNAL().
.PP
.nf
.br
    class MyWidget : public QWidget
.br
    {
.br
    public:
.br
        MyWidget();
.br
    ...
.br
    signals:
.br
        void aSignal();
.br
    ...
.br
    private:
.br
    ...
.br
        QPushButton *aButton;
.br
    };
.br
.br
    MyWidget::MyWidget()
.br
    {
.br
        aButton = new QPushButton( this );
.br
        connect( aButton, SIGNAL(clicked()), SIGNAL(aSignal()) );
.br
    }
.fi
.PP
In its constructor, MyWidget creates a private button and connects the clicked() signal to relay clicked() to the outside world. You can achieve the same effect by connecting the clicked() signal to a private slot and emitting aSignal() in this slot, but that takes a few lines of extra code and is not quite as clear, of course.
.PP
A signal can be connected to many slots/signals. Many signals can be connected to one slot.
.PP
If a signal is connected to several slots, the slots are activated in arbitrary order when the signal is emitted.
.PP
The function returns TRUE if it successfully connects the signal to the slot. It will return FALSE when it cannot connect the signal to the slot.
.PP
See also disconnect().
.PP
Examples:
.(l
showimg/main.cpp action/main.cpp iconview/main.cpp grapher/grapher.cpp xform/xform.cpp application/main.cpp helpviewer/main.cpp i18n/main.cpp drawdemo/drawdemo.cpp popup/popup.cpp menu/menu.cpp qmag/qmag.cpp qwerty/main.cpp forever/forever.cpp rot13/rot13.cpp scrollview/scrollview.cpp addressbook/main.cpp movies/main.cpp hello/main.cpp customlayout/main.cpp mdi/main.cpp
.)l
.SH "bool QObject::connect ( const QObject * sender, const char * signal, const char * member ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Connects \fIsignal\fR from the \fIsender\fR object to \fImember\fR in this object.
.PP
Equivalent to: \fCQObject::connect(sender, signal, this, member)\fR.
.PP
See also disconnect().
.SH "void QObject::connectNotify ( const char * signal ) \fC[virtual protected]\fR"
This virtual function is called when something has been connected to \fIsignal\fR in this object.
.PP
\fBWarning:\fR This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.
.PP
See also connect() and disconnectNotify().
.PP
Reimplemented in QClipboard.
.SH "void QObject::destroyed () \fC[signal]\fR"
This signal is emitted immediately before the object is destroyed.
.PP
All the objects's children are destroyed immediately after this signal is emitted.
.SH "bool QObject::disconnect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member ) \fC[static]\fR"
Disconnects \fIsignal\fR in object \fIsender\fR from \fImember\fR in object \fIreceiver.\fR
.PP
A signal-slot connection is removed when either of the objects involved are destroyed.
.PP
disconnect() is typically used in three ways, as the following examples show.
.IP 1
Disconnect everything connected to an object's signals:
.IP
.nf
.br
    disconnect( myObject, 0, 0, 0 );
.fi
.IP
equivalent to the non-static overloaded function
.IP
.nf
.br
    myObject->disconnect();
.fi
.IP 2
Disconnect everything connected to a specific signal:
.IP
.nf
.br
    disconnect( myObject, SIGNAL(mySignal()), 0, 0 );
.fi
.IP
equivalent to the non-static overloaded function
.IP
.nf
.br
    myObject->disconnect( SIGNAL(mySignal()) );
.fi
.IP 3
Disconnect a specific receiver.
.IP
.nf
.br
    disconnect( myObject, 0, myReceiver, 0 );
.fi
.IP
equivalent to the non-static overloaded function
.IP
.nf
.br
    myObject->disconnect(  myReceiver );
.fi
.IP
.PP
0 may be used as a wildcard, meaning "any signal", "any receiving object" or "any slot in the receiving object" respectively.
.PP
The \fIsender\fR may never be 0. (You cannot disconnect signals from more than one object.)
.PP
If \fIsignal\fR is 0, it disconnects \fIreceiver\fR and \fImember\fR from any signal. If not, only the specified signal is disconnected.
.PP
If \fIreceiver\fR is 0, it disconnects anything connected to \fIsignal.\fR If not, slots in objects other than \fIreceiver\fR are not disconnected.
.PP
If \fImember\fR is 0, it disconnects anything that is connected to \fIreceiver.\fR If not, only slots named \fImember\fR will be disconnected, and all other slots are left alone. The \fImember\fR must be 0 if \fIreceiver\fR is left out, so you cannot disconnect a specifically-named slot on all objects.
.PP
See also connect().
.SH "bool QObject::disconnect ( const QObject * receiver, const char * member=0 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Disconnects all signals in this object from \fImember\fR of \fIreceiver.\fR
.PP
A signal-slot connection is removed when either of the objects involved are destroyed.
.SH "bool QObject::disconnect ( const char * signal=0, const QObject * receiver=0, const char * member=0 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Disconnects \fIsignal\fR from \fImember\fR of \fIreceiver.\fR
.PP
A signal-slot connection is removed when either of the objects involved are destroyed.
.SH "void QObject::disconnectNotify ( const char * signal ) \fC[virtual protected]\fR"
This virtual function is called when something has been disconnected from \fIsignal\fR in this object.
.PP
\fBWarning:\fR This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.
.PP
See also disconnect() and connectNotify().
.SH "void QObject::dumpObjectInfo ()"
Dumps information about signal connections etc. for this object to the debug output.
.PP
This function is useful for debugging. This function does nothing if the library has been compiled in release mode (i.e without debugging information).
.SH "void QObject::dumpObjectTree ()"
Dumps a tree of children to the debug output.
.PP
This function is useful for debugging. This function does nothing if the library has been compiled in release mode (i.e without debugging information).
.SH "bool QObject::event ( QEvent * e ) \fC[virtual]\fR"
This virtual function receives events to an object and should return TRUE if the event was recognized and processed.
.PP
The event() function can be reimplemented to customize the behavior of an object.
.PP
See also installEventFilter(), timerEvent(), QApplication::sendEvent(), QApplication::postEvent() and QWidget::event().
.PP
Reimplemented in QSocketNotifier, QLineEdit, QClipboard, QGroupBox, QWidget, QToolBar, QSplitter, QStatusBar, QMainWindow, QMultiLineEdit and QTimer.
.SH "bool QObject::eventFilter ( QObject *, QEvent * ) \fC[virtual]\fR"
Filters events if this object has been installed as an event filter for another object.
.PP
The reimplementation of this virtual function must return TRUE if the event should be stopped, or FALSE if the event should be dispatched normally.
.PP
\fBWarning:\fR If you delete the receiver object in this function, be sure to return TRUE. If you return FALSE, Qt sends the event to the deleted object and the program will crash.
.PP
See also installEventFilter().
.PP
Reimplemented in QMotifPlusStyle, QLayout, QSpinBox, QFileDialog, QIconView, QSGIStyle, QComboBox, QWorkspace, QAccel, QWizard, QToolBar, QTabWidget, QListView, QFontDialog, QMenuBar, QTable, QScrollView and QMainWindow.
.SH "bool QObject::highPriority () const"
Returns TRUE if the object is a high priority object, or FALSE if it is a standard priority object.
.PP
High priority objects are placed first in list of children, on the assumption that they will be referenced very often.
.SH "bool QObject::inherits ( const char * clname ) const"
Returns TRUE if this object is an instance of a class that inherits \fIclname,\fR and \fIclname\fR inherits QObject.
.PP
(A class is considered to inherit itself.)
.PP
Example:
.PP
.nf
.br
    QTimer *t = new QTimer;             // QTimer inherits QObject
.br
    t->inherits("QTimer");              // returns TRUE
.br
    t->inherits("QObject");             // returns TRUE
.br
    t->inherits("QButton");             // returns FALSE
.br
.br
    QScrollBar * s = new QScrollBar;    // inherits QWidget and QRangeControl
.br
    s->inherits( "QWidget" );           // returns TRUE
.br
    s->inherits( "QRangeControl" );     // returns FALSE
.fi
.PP
See also isA() and metaObject().
.SH "void QObject::initMetaObject () \fC[virtual protected]\fR"
Initializes the meta object of this object. This method is automatically executed on demand.
.PP
See also metaObject().
.SH "void QObject::insertChild ( QObject * obj ) \fC[virtual]\fR"
Inserts an object \fIobj\fR into the list of child objects.
.PP
\fBWarning:\fR This function cannot be used to make a widget a child widget of another. Child widgets can be created only by setting the parent widget in the constructor or by calling QWidget::reparent().
.PP
See also removeChild() and QWidget::reparent().
.SH "void QObject::installEventFilter ( const QObject * obj )"
Installs an event filter \fIobj\fR for this object.
.PP
An event filter is an object that receives all events that are sent to this object. The filter can either stop the event or forward it to this object. The event filter \fIobj\fR receives events via its eventFilter() function. The eventFilter() function must return TRUE if the event should be stopped, or FALSE if the event should be dispatched normally.
.PP
If multiple event filters are installed for a single object, the filter that was installed last is activated first.
.PP
Example:
.PP
.nf
.br
    #include <qwidget.h>
.br
.br
    class MyWidget : public QWidget
.br
    {
.br
    public:
.br
        MyWidget::MyWidget( QWidget *parent=0, const char *name=0 );
.br
    protected:
.br
        bool  eventFilter( QObject *, QEvent * );
.br
    };
.br
.br
    MyWidget::MyWidget( QWidget *parent, const char *name )
.br
        : QWidget( parent, name )
.br
    {
.br
        if ( parent )                           // has a parent widget
.br
            parent->installEventFilter( this ); // then install filter
.br
    }
.br
.br
    bool MyWidget::eventFilter( QObject *o, QEvent *e )
.br
    {
.br
        if ( e->type() == QEvent::KeyPress ) {  // key press
.br
            QKeyEvent *k = (QKeyEvent*)e;
.br
            qDebug( "Ate key press %d", k->key() );
.br
            return TRUE;                        // eat event
.br
        }
.br
        return QWidget::eventFilter( o, e );    // standard event processing
.br
    }
.fi
.PP
The QAccel class, for example, uses this technique.
.PP
\fBWarning:\fR If you delete the receiver object in your eventFilter() function, be sure to return TRUE. If you return FALSE, Qt sends the event to the deleted object and the program will crash.
.PP
See also removeEventFilter(), eventFilter() and event().
.SH "bool QObject::isA ( const char * clname ) const"
Returns TRUE if this object is an instance of a specified class, otherwise FALSE.
.PP
Example:
.PP
.nf
.br
    QTimer *t = new QTimer;             // QTimer inherits QObject
.br
    t->isA("QTimer");                   // returns TRUE
.br
    t->isA("QObject");                  // returns FALSE
.fi
.PP
See also inherits() and metaObject().
.SH "bool QObject::isWidgetType () const"
Returns TRUE if the object is a widget, or FALSE if not.
.PP
Calling this function is equivalent to calling inherits("QWidget"), except that it is much faster.
.SH "void QObject::killTimer ( int id )"
Kills the timer with the identifier \fIid.\fR
.PP
The timer identifier is returned by startTimer() when a timer event is started.
.PP
See also timerEvent(), startTimer() and killTimers().
.PP
Examples:
.(l
grapher/grapher.cpp
.)l
.SH "void QObject::killTimers ()"
Kills all timers that this object has started.
.PP
Note that using this function can cause hard-to-find bugs: It kills timers started by sub- and superclasses as well as those started by you, which is often not what you want. Therefore, we recommend using a QTimer, or perhaps killTimer().
.PP
See also timerEvent(), startTimer() and killTimer().
.PP
Examples:
.(l
xform/xform.cpp qmag/qmag.cpp
.)l
.SH "QMetaObject * QObject::metaObject () const \fC[virtual]\fR"
Returns a pointer to the meta object of this object.
.PP
A meta object contains information about a class that inherits QObject: class name, super class name, properties, signals and slots. Every class that contains the \fCQ_OBJECT\fR macro will also have a meta object.
.PP
The meta object information is required by the signal/slot connection mechanism and the property system. The functions isA() and inherits() also make use of the meta object.
.SH "const char * QObject::name () const"
Returns the name of this object. If the object does not have a name, it will return "unnamed", so that printf() (used in qDebug()) will not be asked to output a null pointer. If you want a null pointer to be returned for unnamed objects, you can call name( 0 ).
.PP
.nf
.br
    qDebug( "MyClass::setPrecision(): (%s) unable to set precision to %f",
.br
            name(), newPrecision );
.fi
.PP
The object name is set by the constructor or by the setName() function. The object name is not very useful in the current version of Qt, but will become increasingly important in the future.
.PP
You can find an object by name (and type) using child(), and more than one using queryList().
.PP
See also setName(), className(), child() and queryList().
.SH "const char * QObject::name ( const char * defaultName ) const"
Returns the name of this object, or \fIdefaultName\fR if the object does not have a name.
.SH "QCString QObject::normalizeSignalSlot ( const char * signalSlot ) \fC[static protected]\fR"
Normlizes the signal or slot definition \fIsignalSlot\fR by removing unnecessary whitespaces.
.SH "const QObjectList * QObject::objectTrees () \fC[static]\fR"
Returns a pointer to the list of all object trees (respectively their root objects), or 0 if there are no objects.
.PP
The QObjectList class is defined in the qobjectlist.h header file.
.PP
The latest root object created is the first object in the list and the first root object added is the last object in the list.
.PP
See also children(), parent(), insertChild() and removeChild().
.SH "QObject * QObject::parent () const"
Returns a pointer to the parent object.
.PP
See also children().
.SH "QVariant QObject::property ( const char * name ) const"
Returns the value of the object's \fIname\fR property.
.PP
If no such property exists, the returned variant is invalid.
.PP
Information about all available properties are provided through the metaObject().
.PP
See also setProperty(), QVariant::isValid(), metaObject(), QMetaObject::propertyNames() and QMetaObject::property().
.SH "QObjectList * QObject::queryList ( const char * inheritsClass = 0, const char * objName = 0, bool regexpMatch = TRUE, bool recursiveSearch = TRUE )"
Searches the children and optinally grandchildren of this object, and returns a list of those objects that are named or matches \fIobjName\fR and inherit \fIineritsClass.\fR If \fIinheritsClass\fR is 0 (the default), all classes match. IF \fIobjName\fR is 0 (the default), all object names match.
.PP
If \fIregexpMatch\fR is TRUE (the default), \fIobjName\fR is a regexp that the objects's names must match. If \fIregexpMatch\fR is FALSE, \fIobjName\fR is a string and object names must match it exactly.
.PP
Note that \fIineritsClass\fR uses single inheritance from QObject, the way inherits() does. According to inherits(), QMenuBar inherits QWidget but not QMenuData. This does not quite match reality, but is the best that can be done on the wide variety of compilers Qt supports.
.PP
Finally, if \fIrecursiveSearch\fR is TRUE (the default), queryList() searches nth-generation as well as first-generation children.
.PP
If all this seems a bit complex for your needs, the simpler function child() may be what you want.
.PP
This somewhat contrived example disables all the buttons in this window:
.PP
.nf
.br
    QObjectList * l = topLevelWidget()->queryList( "QButton" );
.br
    QObjectListIt it( *l );             // iterate over the buttons
.br
    QObject * obj;
.br
    while ( (obj=it.current()) != 0 ) { // for each found object...
.br
        ++it;
.br
        ((QButton*)obj)->setEnabled( FALSE );
.br
    }
.br
    delete l;                           // delete the list, not the objects
.fi
.PP
\fBWarning:\fR Delete the list away as soon you have finished using it. The list contains pointers that may become invalid at almost any time without notice - as soon as the user closes a window you may have dangling pointers, for example.
.PP
See also child(), children(), parent(), inherits(), name() and QRegExp.
.SH "QConnectionList * QObject::receivers ( const char * signal ) const \fC[protected]\fR"
Returns a list of objects/slot pairs that are connected to the signal, or 0 if nothing is connected to it.
.PP
This function is for internal use.
.SH "void QObject::removeChild ( QObject * obj ) \fC[virtual]\fR"
Removes the child object \fIobj\fR from the list of children.
.PP
\fBWarning:\fR This function will not remove a child widget from the screen. It will only remove it from the parent widget's list of children.
.PP
See also insertChild() and QWidget::reparent().
.PP
Reimplemented in QScrollView.
.SH "void QObject::removeEventFilter ( const QObject * obj )"
Removes an event filter object \fIobj\fR from this object. The request is ignored if such an event filter has not been installed.
.PP
All event filters for this object are automatically removed when this object is destroyed.
.PP
It is always safe to remove an event filter, even during event filter activation (i.e. from the eventFilter() function).
.PP
See also installEventFilter(), eventFilter() and event().
.SH "const QObject * QObject::sender () \fC[protected]\fR"
Returns a pointer to the object that sent the signal, if called in a slot before any function call or signal emission. Returns an undefined value in all other cases.
.PP
\fBWarning:\fR This function will return something apparently correct in other cases as well. However, its value may change during any function call, depending on what signal-slot connections are activated during that call. In Qt 3.0 the value will change more often than in 2.x.
.PP
\fBWarning:\fR This function violates the object-oriented principle of modularity, However, getting access to the sender might be practical when many signals are connected to a single slot. The sender is undefined if the slot is called as a normal C++ function.
.SH "void QObject::setName ( const char * name ) \fC[virtual]\fR"
Sets the name of this object to \fIname.\fR The default name is the one assigned by the constructor.
.PP
You can find an object by name (and type) using child(), and more than one using queryList().
.PP
See also name(), className(), queryList() and child().
.PP
Reimplemented in QWidget and QSignal.
.SH "bool QObject::setProperty ( const char * name, const QVariant & value )"
Sets the object's property \fIname\fR to \fIvalue.\fR
.PP
Returne TRUE is the operation was successful, FALSE otherwise.
.PP
Information about all available properties are provided through the metaObject().
.PP
See also property(), metaObject(), QMetaObject::propertyNames() and QMetaObject::property().
.SH "bool QObject::signalsBlocked () const"
Returns TRUE if signals are blocked, or FALSE if signals are not blocked.
.PP
Signals are not blocked by default.
.PP
See also blockSignals().
.SH "int QObject::startTimer ( int interval )"
Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.
.PP
A timer event will occur every \fIinterval\fR milliseconds until killTimer() or killTimers() is called. If \fIinterval\fR is 0, then the timer event occurs once every time there are no more window system events to process.
.PP
The virtual timerEvent() function is called with the QTimerEvent event parameter class when a timer event occurs. Reimplement this function to get timer events.
.PP
If multiple timers are running, the QTimerEvent::timerId() can be used to find out which timer was activated.
.PP
Example:
.PP
.nf
.br
    class MyObject : public QObject
.br
    {
.br
    public:
.br
        MyObject( QObject *parent=0, const char *name=0 );
.br
    protected:
.br
        void  timerEvent( QTimerEvent * );
.br
    };
.br
.br
    MyObject::MyObject( QObject *parent, const char *name )
.br
        : QObject( parent, name )
.br
    {
.br
        startTimer( 50 );                       // 50 millisecond timer
.br
        startTimer( 1000 );                     // 1 second timer
.br
        startTimer( 60000 );                    // 1 minute timer
.br
    }
.br
.br
    void MyObject::timerEvent( QTimerEvent *e )
.br
    {
.br
        qDebug( "timer event, id=%d", e->timerId() );
.br
    }
.fi
.PP
There is practically no upper limit for the interval value (more than one year). The accuracy depends on the underlying operating system. Windows 95 has 55 millisecond (18.2 times per second) accuracy; other systems that we have tested (UNIX X11, Windows NT and OS/2) can handle 1 millisecond intervals.
.PP
The QTimer class provides a high-level programming interface with one-shot timers and timer signals instead of events.
.PP
See also timerEvent(), killTimer() and killTimers().
.PP
Examples:
.(l
qmag/qmag.cpp forever/forever.cpp
.)l
.SH "QMetaObject* QObject::staticMetaObject () \fC[static protected]\fR"
The functionality of initMetaObject(), provided as a static function.
.SH "QStringList QObject::superClasses ( bool includeThis = FALSE ) const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
This function is misleadingly named, and cannot be implemented in a way that fulfills its name. someQWidget->superClasses() should have returned QPaintDevice and QObject, obviously. And it never can, so let us kill the function. \fBIt will be removed in Qt-3.0\fR
.PP
Oh, and the return type was wrong, too. QStringList not QStrList.
.SH "void QObject::timerEvent ( QTimerEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive timer events for the object.
.PP
QTimer provides a higher-level interface to the timer functionality, and also more general information about timers.
.PP
See also startTimer(), killTimer(), killTimers() and event().
.PP
Reimplemented in QPopupMenu and QMultiLineEdit.
.SH "QString QObject::tr ( const char * text, const char * comment ) \fC[static]\fR"
Returns a translated version of \fItext\fR in context QObject and and with \fIcomment,\fR or \fItext\fR if there is no appropriate translated version. All QObject subclasses which use the Q_OBJECT macro have a reimplementation of this function which uses the relevant class name as context.
.PP
See also QApplication::translate().
.SH "QString QObject::tr ( const char * text ) \fC[static]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Returns a translated version of \fItext\fR in context QObject and with no comment, or \fItext\fR if there is no appropriate translated version. All QObject subclasses which use the Q_OBJECT macro have a reimplementation of this function which uses the relevant class name as context.
.PP
See also QApplication::translate().
.SH "bool QObject::activate_filters ( QEvent * e ) \fC[protected]\fR"
For internal use only.
.SH "void QObject::activate_signal ( const char * signal ) \fC[protected]\fR"
For internal use only.
.SH RELATED FUNCTION DOCUMENTATION
.SH "void * qt_find_obj_child (QObject * parent, const char * type, const char * name)"
Returns a pointer to the child named \fIname\fR of QObject \fIparent\fR which inherits type \fItype.\fR
.PP
Returns 0 if there is no such child.
.PP
.nf
.br
    QListBox * c = (QListBox *)::qt_find_obj_child(myWidget,QListBox,
.br
                                                   "listboxname");
.br
    if ( c )
.br
        c->insertItem( "another string" );
.fi
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qobject.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qobject.3qt) and the Qt
version (2.3.2).
