'\" t
.TH QPainter 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QPainter \- Paints on paint devices
.br
.PP
\fC#include <qpainter.h>\fR
.PP
Inherits Qt.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQPainter\fR () "
.br
.ti -1c
.BI "\fBQPainter\fR ( const QPaintDevice * ) "
.br
.ti -1c
.BI "\fBQPainter\fR ( const QPaintDevice *, const QWidget * ) "
.br
.ti -1c
.BI "\fB~QPainter\fR () "
.br
.ti -1c
.BI "bool \fBbegin\fR ( const QPaintDevice * ) "
.br
.ti -1c
.BI "bool \fBbegin\fR ( const QPaintDevice *, const QWidget * ) "
.br
.ti -1c
.BI "bool \fBend\fR () "
.br
.ti -1c
.BI "QPaintDevice* \fBdevice\fR () const"
.br
.ti -1c
.BI "bool \fBisActive\fR () const"
.br
.ti -1c
.BI "void \fBflush\fR () "
.br
.ti -1c
.BI "void \fBsave\fR () "
.br
.ti -1c
.BI "void \fBrestore\fR () "
.br
.ti -1c
.BI "QFontMetrics \fBfontMetrics\fR () const"
.br
.ti -1c
.BI "QFontInfo \fBfontInfo\fR () const"
.br
.ti -1c
.BI "const QFont& \fBfont\fR () const"
.br
.ti -1c
.BI "void \fBsetFont\fR ( const QFont & ) "
.br
.ti -1c
.BI "const QPen& \fBpen\fR () const"
.br
.ti -1c
.BI "void \fBsetPen\fR ( const QPen & ) "
.br
.ti -1c
.BI "void \fBsetPen\fR ( PenStyle ) "
.br
.ti -1c
.BI "void \fBsetPen\fR ( const QColor & ) "
.br
.ti -1c
.BI "const QBrush& \fBbrush\fR () const"
.br
.ti -1c
.BI "void \fBsetBrush\fR ( const QBrush & ) "
.br
.ti -1c
.BI "void \fBsetBrush\fR ( BrushStyle ) "
.br
.ti -1c
.BI "void \fBsetBrush\fR ( const QColor & ) "
.br
.ti -1c
.BI "QPoint \fBpos\fR () const"
.br
.ti -1c
.BI "const QColor& \fBbackgroundColor\fR () const"
.br
.ti -1c
.BI "void \fBsetBackgroundColor\fR ( const QColor & ) "
.br
.ti -1c
.BI "BGMode \fBbackgroundMode\fR () const"
.br
.ti -1c
.BI "void \fBsetBackgroundMode\fR ( BGMode ) "
.br
.ti -1c
.BI "RasterOp \fBrasterOp\fR () const"
.br
.ti -1c
.BI "void \fBsetRasterOp\fR ( RasterOp ) "
.br
.ti -1c
.BI "const QPoint& \fBbrushOrigin\fR () const"
.br
.ti -1c
.BI "void \fBsetBrushOrigin\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBsetBrushOrigin\fR ( const QPoint & ) "
.br
.ti -1c
.BI "bool \fBhasViewXForm\fR () const"
.br
.ti -1c
.BI "bool \fBhasWorldXForm\fR () const"
.br
.ti -1c
.BI "void \fBsetViewXForm\fR ( bool ) "
.br
.ti -1c
.BI "QRect \fBwindow\fR () const"
.br
.ti -1c
.BI "void \fBsetWindow\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBsetWindow\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "QRect \fBviewport\fR () const"
.br
.ti -1c
.BI "void \fBsetViewport\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBsetViewport\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBsetWorldXForm\fR ( bool ) "
.br
.ti -1c
.BI "const QWMatrix& \fBworldMatrix\fR () const"
.br
.ti -1c
.BI "void \fBsetWorldMatrix\fR ( const QWMatrix &, bool " "combine" "=FALSE ) "
.br
.ti -1c
.BI "void saveWorldMatrix () \fI(obsolete)\fR"
.br
.ti -1c
.BI "void restoreWorldMatrix () \fI(obsolete)\fR"
.br
.ti -1c
.BI "void \fBscale\fR ( double " "sx" ", double sy ) "
.br
.ti -1c
.BI "void \fBshear\fR ( double " "sh" ", double sv ) "
.br
.ti -1c
.BI "void \fBrotate\fR ( double a ) "
.br
.ti -1c
.BI "void \fBtranslate\fR ( double " "dx" ", double dy ) "
.br
.ti -1c
.BI "void \fBresetXForm\fR () "
.br
.ti -1c
.BI "QPoint \fBxForm\fR ( const QPoint & ) const"
.br
.ti -1c
.BI "QRect \fBxForm\fR ( const QRect & ) const"
.br
.ti -1c
.BI "QPointArray \fBxForm\fR ( const QPointArray & ) const"
.br
.ti -1c
.BI "QPointArray \fBxForm\fR ( const QPointArray &, int " "index" ", int npoints ) const"
.br
.ti -1c
.BI "QPoint \fBxFormDev\fR ( const QPoint & ) const"
.br
.ti -1c
.BI "QRect \fBxFormDev\fR ( const QRect & ) const"
.br
.ti -1c
.BI "QPointArray \fBxFormDev\fR ( const QPointArray & ) const"
.br
.ti -1c
.BI "QPointArray \fBxFormDev\fR ( const QPointArray &, int " "index" ", int npoints ) const"
.br
.ti -1c
.BI "void \fBsetClipping\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBhasClipping\fR () const"
.br
.ti -1c
.BI "const QRegion& \fBclipRegion\fR () const"
.br
.ti -1c
.BI "void \fBsetClipRect\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBsetClipRect\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBsetClipRegion\fR ( const QRegion & ) "
.br
.ti -1c
.BI "void \fBdrawPoint\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBdrawPoint\fR ( const QPoint & ) "
.br
.ti -1c
.BI "void \fBdrawPoints\fR ( const QPointArray & " "a" ", int " "index" "=0, int " "npoints" "=-1 ) "
.br
.ti -1c
.BI "void \fBmoveTo\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBmoveTo\fR ( const QPoint & ) "
.br
.ti -1c
.BI "void \fBlineTo\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBlineTo\fR ( const QPoint & ) "
.br
.ti -1c
.BI "void \fBdrawLine\fR ( int " "x1" ", int " "y1" ", int " "x2" ", int y2 ) "
.br
.ti -1c
.BI "void \fBdrawLine\fR ( const QPoint &, const QPoint & ) "
.br
.ti -1c
.BI "void \fBdrawRect\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBdrawRect\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QColor & bgColor ) "
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBdrawWinFocusRect\fR ( const QRect &, const QColor & bgColor ) "
.br
.ti -1c
.BI "void \fBdrawRoundRect\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int, int ) "
.br
.ti -1c
.BI "void \fBdrawRoundRect\fR ( const QRect &, int, int ) "
.br
.ti -1c
.BI "void \fBdrawRoundRect\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBdrawRoundRect\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBdrawEllipse\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBdrawEllipse\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBdrawArc\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int " "a" ", int alen ) "
.br
.ti -1c
.BI "void \fBdrawArc\fR ( const QRect &, int " "a" ", int alen ) "
.br
.ti -1c
.BI "void \fBdrawPie\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int " "a" ", int alen ) "
.br
.ti -1c
.BI "void \fBdrawPie\fR ( const QRect &, int " "a" ", int alen ) "
.br
.ti -1c
.BI "void \fBdrawChord\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int " "a" ", int alen ) "
.br
.ti -1c
.BI "void \fBdrawChord\fR ( const QRect &, int " "a" ", int alen ) "
.br
.ti -1c
.BI "void \fBdrawLineSegments\fR ( const QPointArray &, int " "index" "=0, int " "nlines" "=-1 ) "
.br
.ti -1c
.BI "void \fBdrawPolyline\fR ( const QPointArray &, int " "index" "=0, int " "npoints" "=-1 ) "
.br
.ti -1c
.BI "void \fBdrawPolygon\fR ( const QPointArray &, bool " "winding" "=FALSE, int " "index" "=0, int " "npoints" "=-1 ) "
.br
.ti -1c
.BI "void \fBdrawQuadBezier\fR ( const QPointArray &, int " "index" "=0 ) "
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( int " "x" ", int " "y" ", const QPixmap &, int " "sx" "=0, int " "sy" "=0, int " "sw" "=-1, int " "sh" "=-1 ) "
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( const QPoint &, const QPixmap &, const QRect & sr ) "
.br
.ti -1c
.BI "void \fBdrawPixmap\fR ( const QPoint &, const QPixmap & ) "
.br
.ti -1c
.BI "void \fBdrawImage\fR ( int " "x" ", int " "y" ", const QImage &, int " "sx" "=0, int " "sy" "=0, int " "sw" "=-1, int " "sh" "=-1 ) "
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QPoint &, const QImage &, const QRect & sr ) "
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QPoint &, const QImage & ) "
.br
.ti -1c
.BI "void \fBdrawImage\fR ( int " "x" ", int " "y" ", const QImage &, int " "sx" ", int " "sy" ", int " "sw" ", int " "sh" ", int conversion_flags ) "
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QPoint &, const QImage &, const QRect & " "sr" ", int conversion_flags ) "
.br
.ti -1c
.BI "void \fBdrawImage\fR ( const QPoint &, const QImage &, int conversion_flags ) "
.br
.ti -1c
.BI "void \fBdrawTiledPixmap\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QPixmap &, int " "sx" "=0, int " "sy" "=0 ) "
.br
.ti -1c
.BI "void \fBdrawTiledPixmap\fR ( const QRect &, const QPixmap &, const QPoint & ) "
.br
.ti -1c
.BI "void \fBdrawTiledPixmap\fR ( const QRect &, const QPixmap & ) "
.br
.ti -1c
.BI "void \fBdrawPicture\fR ( const QPicture & ) "
.br
.ti -1c
.BI "void \fBfillRect\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QBrush & ) "
.br
.ti -1c
.BI "void \fBfillRect\fR ( const QRect &, const QBrush & ) "
.br
.ti -1c
.BI "void \fBeraseRect\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBeraseRect\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBdrawText\fR ( int " "x" ", int " "y" ", const QString &, int " "len" " = -1 ) "
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QPoint &, const QString &, int " "len" " = -1 ) "
.br
.ti -1c
.BI "void \fBdrawText\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int " "flags" ", const QString &, int " "len" " = -1, QRect * " "br" "=0, char ** " "internal" "=0 ) "
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QRect &, int " "flags" ", const QString &, int " "len" " = -1, QRect * " "br" "=0, char ** " "internal" "=0 ) "
.br
.ti -1c
.BI "QRect \fBboundingRect\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", int " "flags" ", const QString &, int " "len" " = -1, char ** " "intern" "=0 ) "
.br
.ti -1c
.BI "QRect \fBboundingRect\fR ( const QRect &, int " "flags" ", const QString &, int " "len" " = -1, char ** " "intern" "=0 ) "
.br
.ti -1c
.BI "int \fBtabStops\fR () const"
.br
.ti -1c
.BI "void \fBsetTabStops\fR ( int ) "
.br
.ti -1c
.BI "int* \fBtabArray\fR () const"
.br
.ti -1c
.BI "void \fBsetTabArray\fR ( int * ) "
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "void \fBredirect\fR ( QPaintDevice * " "pdev" ", QPaintDevice * replacement ) "
.br
.ti -1c
.BI "void \fBinitialize\fR () "
.br
.ti -1c
.BI "void \fBcleanup\fR () "
.br
.in -1c
.SH RELATED FUNCTION DOCUMENTATION
(Note that these are not member functions.)
.in +1c
.ti -1c
.BI "void \fBqDrawPlainRect\fR (QPainter * " "p" ", int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QColor & " "c" ", int " "lineWidth" ", const QBrush * " "fill" ")"
.br
.ti -1c
.BI "void \fBqDrawWinPanel\fR (QPainter * " "p" ", int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QColorGroup & " "g" ", bool " "sunken" ", const QBrush * " "fill" ")"
.br
.ti -1c
.BI "void \fBqDrawShadeLine\fR (QPainter * " "p" ", int " "x1" ", int " "y1" ", int " "x2" ", int " "y2" ", const QColorGroup & " "g" ", bool " "sunken" ", int " "lineWidth" ", int " "midLineWidth" ")"
.br
.ti -1c
.BI "void \fBqDrawShadeRect\fR (QPainter * " "p" ", int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QColorGroup & " "g" ", bool " "sunken" ", int " "lineWidth" ", int " "midLineWidth" ", const QBrush * " "fill" ")"
.br
.ti -1c
.BI "void \fBqDrawShadePanel\fR (QPainter * " "p" ", int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QColorGroup & " "g" ", bool " "sunken" ", int " "lineWidth" ", const QBrush * " "fill" ")"
.br
.ti -1c
.BI "void \fBqDrawWinButton\fR (QPainter * " "p" ", int " "x" ", int " "y" ", int " "w" ", int " "h" ", const QColorGroup & " "g" ", bool " "sunken" ", const QBrush * " "fill" ")"
.br
.in -1c
.SH DESCRIPTION
The QPainter class paints on paint devices.
.PP
The painter provides efficient graphics rendering on any QPaintDevice object. QPainter can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a "natural" coordinate system, but it can also do view and world transformation.
.PP
The typical use of a painter is:
.IP 1
Construct a painter.
.IP 2
Set a pen, a brush etc.
.IP 3
Draw.
.IP 4
Destroy the painter.
.PP
Mostly, all this is done inside a paint event. (In fact, 99% of all QPainter use is in a reimplementation of QWidget::paintEvent()). Here's one very simple example:
.PP
.nf
.br
    void SimpleExampleWidget::paintEvent()
.br
    {
.br
        QPainter paint( this );
.br
        paint.setPen( Qt::blue );
.br
        paint.drawText( rect(), AlignCenter, "The Text" );
.br
    }
.fi
.PP
Simple. However, there are many settings you may use: 
.TP
font() is the currently set font. If you set a font that isn't available, Qt finds a close match. In that case font() returns what you set using setFont() and fontInfo() returns the font actually being used.
.TP
brush() is the currently set brush; the color or pattern that's used for filling e.g. circles.
.TP
pen() is the currently set pen; the color or stipple that's used for drawing lines or boundaries.
.TP
backgroundMode() is \fCOpaque\fR or \fCTransparent,\fR ie. whether backgroundColor() is used or not.
.TP
backgroundColor() only applies when backgroundMode() is Opaque and pen() is a stipple. In that case, it describes the color of the background pixels in the stipple.
.TP
rasterOp() is how pixels drawn interact with the data already there.
.TP
brushOrigin() is the origin of the tiled brushes, normally the origin of the window.
.TP
viewport(), window(), worldMatrix() and many more make up the painter's coordinate transformation system. See The Coordinate System for an explanation of this, or a paragraph below for a quick overview of the functions.
.TP
clipping() is whether the painter clips at all. (The paint device clips, too.) If the painter clips, it clips to clipRegion().
.TP
pos() is the current position, set by moveTo() and used by lineTo().
.IP
.PP
Note that some of these settings mirror settings in some paint devices, e.g. QWidget::font(). QPainter::begin() (or the QPainter constructor) copies these attributes from the paint device, changing calling e.g. QWidget::setFont() doesn't take effect until the next time a painter begins painting on it.
.PP
save() saves all of these settings on an internal stack, restore() pops them back.
.PP
The core functionality of QPainter is drawing, and there are functions to draw most primitives: drawPoint(), drawPoints(), drawLine(), drawRect(), drawWinFocusRect(), drawRoundRect(), drawEllipse(), drawArc(), drawPie(), drawChord(), drawLineSegments(), drawPolyline(), drawPolygon(), and drawQuadBezier().
.PP
There are functions to draw pixmaps/images, namely drawPixmap(), drawImage() and drawTiledPixmap(). drawPixmap() and drawImage() produce the same result, except that drawPixmap() is faster on-screen and drawImage() faster and sometimes better on QPrinter and QPicture.
.PP
Text drawing is done using drawText(), and when you need fine-grained positioning, boundingRect() tells you where a given drawText() command would draw.
.PP
There is a drawPicture() that draws the contents of an entire QPicture using this painter. drawPicture() is the only function that disregards all the painter's settings: The QPicture has its own settings.
.PP
Normally, the QPainter operates on the device's own coordinate system (usually pixels), but QPainter has good support for coordinate transformation. See The Coordinate System for a more general overview and a walkthrough of a simple example.
.PP
The most common functions used are scale(), rotate(), translate() and shear(), all of which operate on the worldMatrix(). setWorldMatrix() can replace or add to the currently set matrix().
.PP
setViewport() sets the rectangle on which QPainter operates. The default is the entire device, which is usually fine, except on printers. setWindow() sets the coordinate system, that is, the rectangle that maps to viewport(). What's draws inside the window() ends up being inside the viewport(). The window's default is the same as the viewport, and if you don't use the transformations, they are optimized away, gaining a little speed.
.PP
After all the coordinate transformation is done, QPainter can clip the drawing to and arbitrary rectangle or region. hasClipping() is TRUE if QPainter clips, and clipRegion() returns the clip region. You can set it using either setClipRegion() or setClipRect(). Note that the clipping can be slow. It's all system-dependent, but as a rule of thumb, you can assume that drawing speed is inversely proportional to the number of rectangles in the clip region.
.PP
After QPainter's clipping, the paint device too will clip a bit. For example, most widgets clip away the pixels used by child widgets, and most printers clip away an area near the edges of the paper. This additional clipping is \fInot\fR reflected by the return value of clipRegion() or hasClipping().
.PP
Finally, QPainter includes some little-used functions that are very handy the few times you need them.
.PP
isActive() indicates whether the painter is active. begin() (and the most usual constructor) makes it active. end() (and the destructor) deactivates it. If the painter is active, device() returns the paint device on which the painter paints.
.PP
Sometimes it is desirable to make someone else paint on an unusual QPaintDevice. QPainter supports a static function to do this, redirect(). We recommend not using it, but for some hacks it's perfect.
.PP
setTabStops() and setTabArray() can change where the tab stops are, but these are very seldomly used.
.PP
\fBWarning:\fR Note that QPainter does not attempt to work around coordinate limitations in the underlying window system. Some platforms may behave incorrectly with coordinates as small as +/- 4000.
.PP
See also QPaintDevice, QWidget, QPixmap, QPrinter, QPicture, Application Walkthrough and Coordinate System Overview
.PP
Examples:
.(l
qtimage/qtimage.cpp grapher/grapher.cpp drawlines/connect.cpp xform/xform.cpp drawdemo/drawdemo.cpp menu/menu.cpp progress/progress.cpp qmag/qmag.cpp splitter/splitter.cpp forever/forever.cpp desktop/desktop.cpp scrollview/scrollview.cpp trivial/trivial.cpp movies/main.cpp picture/picture.cpp
.)l
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QPainter::QPainter ()"
Constructs a painter.
.PP
Notice that all painter settings (setPen,setBrush etc.) are reset to default values when begin() is called.
.PP
See also begin() and end().
.SH "QPainter::QPainter ( const QPaintDevice * pd )"
Constructs a painter that begins painting the paint device \fIpd\fR immediately.
.PP
This constructor is convenient for short-lived painters, e.g. in a paint event and should be used only once. The constructor calls begin() for you and the QPainter destructor automatically calls end().
.PP
Here's an example using begin() and end():
.PP
.nf
.br
    void MyWidget::paintEvent( QPaintEvent * )
.br
    {
.br
        QPainter p;
.br
        p.begin( this );
.br
        p.drawLine( ... );      // drawing code
.br
        p.end();
.br
    }
.fi
.PP
The same example using this constructor:
.PP
.nf
.br
    void MyWidget::paintEvent( QPaintEvent * )
.br
    {
.br
        QPainter p( this );
.br
        p.drawLine( ... );      // drawing code
.br
    }
.fi
.PP
See also begin() and end().
.SH "QPainter::QPainter ( const QPaintDevice * pd, const QWidget * copyAttributes )"
Constructs a painter that begins painting the paint device \fIpd\fR immediately, with the default arguments taken from \fIcopyAttributes.\fR
.PP
See also begin().
.SH "QPainter::~QPainter ()"
Destructs the painter.
.SH "const QColor & QPainter::backgroundColor () const"
Returns the current background color.
.PP
See also setBackgroundColor() and QColor.
.SH "BGMode QPainter::backgroundMode () const"
Returns the current background mode.
.PP
See also setBackgroundMode() and BGMode.
.SH "bool QPainter::begin ( const QPaintDevice * pd )"
Begins painting the paint device \fIpd\fR and returns TRUE if successful, or FALSE if an error occurs.
.PP
The errors that can occur are serious problems, such as these:
.PP
.nf
.br
    p->begin( 0 ); // impossible - paint device cannot be 0
.br
.br
    QPixmap pm( 0, 0 );
.br
    p->begin( pm ); // impossible - pm.isNull();
.br
.br
    p->begin( myWidget );
.br
    p2->begin( myWidget ); // impossible - only one painter at a time
.fi
.PP
Note that most of the time, you can use one of the constructors instead of begin(), and that end() is automatically done at destruction.
.PP
\fBWarning:\fR A paint device can only be painted by one painter at a time.
.PP
See also end() and flush().
.PP
Examples:
.(l
drawdemo/drawdemo.cpp desktop/desktop.cpp picture/picture.cpp
.)l
.SH "bool QPainter::begin ( const QPaintDevice * pd, const QWidget * copyAttributes )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version opens the painter on a paint device \fIpd\fR and sets the initial pen, background color and font from \fIcopyAttributes.\fR This is equivalent with:
.PP
.nf
.br
    QPainter p;
.br
    p.begin( pd );
.br
    p.setPen( copyAttributes->foregroundColor() );
.br
    p.setBackgroundColor( copyAttributes->backgroundColor() );
.br
    p.setFont( copyAttributes->font() );
.fi
.PP
This begin function is convenient for double buffering. When you draw in a pixmap instead of directly in a widget (to later bitBlt the pixmap into the widget) you will need to set the widgets's font etc. This function does exactly that.
.PP
Example:
.PP
.nf
.br
    void MyWidget::paintEvent( QPaintEvent * )
.br
    {
.br
        QPixmap pm(size());
.br
        QPainter p;
.br
        p.begin(&pm, this);
.br
        // ... potential flickering paint operation ...
.br
        p.end();
.br
        bitBlt(this, 0, 0, &pm);
.br
    }
.fi
.PP
See also end().
.SH "QRect QPainter::boundingRect ( int x, int y, int w, int h, int tf, const QString & str, int len = -1, char ** internal=0 )"
Returns the bounding rectangle of the aligned text that would be printed with the corresponding drawText() function (the first \fIlen\fR characters from \fIstr).\fR The drawing, and hence the bounding rectangle, is constrained to the rectangle \fI(x,y,w,h).\fR
.PP
If \fIlen\fR is negative (default value), the whole string is used.
.PP
The \fItf\fR argument is the bitwise OR of the following flags: 
.TP
\fCAlignLeft\fR aligns to the left border.
.TP
\fCAlignRight\fR aligns to the right border.
.TP
\fCAlignHCenter\fR aligns horizontally centered.
.TP
\fCAlignTop\fR aligns to the top border.
.TP
\fCAlignBottom\fR aligns to the bottom border.
.TP
\fCAlignVCenter\fR aligns vertically centered
.TP
\fCAlignCenter\fR (= \fCAlignHCenter\fR | AlignVCenter)
.TP
\fCSingleLine\fR ignores newline characters in the text.
.TP
\fCExpandTabs\fR expands tabulators.
.TP
\fCShowPrefix\fR interprets "&x" as "x" underlined.
.TP
\fCWordBreak\fR breaks the text to fit the rectangle.
.PP
Horizontal alignment defaults to AlignLeft and vertical alignment defaults to AlignTop.
.PP
If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.
.PP
These flags are defined in qnamespace.h.
.PP
See also drawText(), fontMetrics(), QFontMetrics::boundingRect() and Qt::AlignmentFlags.
.SH "QRect QPainter::boundingRect ( const QRect & r, int tf, const QString &, int len = -1, char ** i=0 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "const QBrush & QPainter::brush () const"
Returns the current painter brush.
.PP
See also QPainter::setBrush().
.SH "const QPoint & QPainter::brushOrigin () const"
Returns the brush origin currently set.
.PP
See also setBrushOrigin().
.SH "void QPainter::cleanup () \fC[static]\fR"
Internal function that cleans up the painter.
.SH "const QRegion & QPainter::clipRegion () const"
Returns the currently set clip region. Note that the clip region is given in physical device coordinates and \fInot\fR subject to any coordinate transformation.
.PP
See also setClipRegion(), setClipRect() and setClipping().
.SH "QPaintDevice * QPainter::device () const"
Returns the paint device on which this painter is currently painting, or null if the painter is not active.
.PP
See also QPaintDevice::paintingActive().
.SH "void QPainter::drawArc ( int x, int y, int w, int h, int a, int alen )"
Draws an arc defined by the rectangle \fI(x,y,w,h),\fR the start angle \fIa\fR and the arc length \fIalen.\fR
.PP
The angles \fIa\fR and \fIalen\fR are 1/16th of a degree, i.e. a full circle equals 5760 (16*360). Positive values of \fIa\fR and \fIalen\fR mean counter-clockwise while negative values mean clockwise direction. Zero degrees is at the 3'o clock position.
.PP
Example:
.PP
.nf
.br
    QPainter p( myWidget );
.br
    p.drawArc( 10,10, 70,100, 100*16, 160*16 ); // draws a "(" arc
.fi
.PP
See also drawPie() and drawChord().
.SH "void QPainter::drawArc ( const QRect & r, int a, int alen )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawChord ( int x, int y, int w, int h, int a, int alen )"
Draws a chord defined by the rectangle \fI(x,y,w,h),\fR the start angle \fIa\fR and the arc length \fIalen.\fR
.PP
The chord is filled with the current brush().
.PP
The angles \fIa\fR and \fIalen\fR are 1/16th of a degree, i.e. a full circle equals 5760 (16*360). Positive values of \fIa\fR and \fIalen\fR mean counter-clockwise while negative values mean clockwise direction. Zero degrees is at the 3'o clock position.
.PP
See also drawArc() and drawPie().
.SH "void QPainter::drawChord ( const QRect & r, int a, int alen )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawEllipse ( int x, int y, int w, int h )"
Draws an ellipse with center at \fI(x+w/2,y+h/2)\fR and size \fI(w,h).\fR
.PP
Examples:
.(l
drawdemo/drawdemo.cpp picture/picture.cpp
.)l
.SH "void QPainter::drawEllipse ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawImage ( int x, int y, const QImage & image, int sx, int sy, int sw, int sh, int conversion_flags )"
Draws at (\fIx, y)\fR the \fIsw\fR by \fIsh\fR area of pixels from (\fIsx, sy)\fR in \fIimage,\fR using \fIconversion_flags\fR if the image needs to be converted to a pixmap.
.PP
This function may convert \fIimage\fR to a pixmap and then draw it, if device() is a QPixmap or a QWidget, or else draw it directly, if device() is a QPrinter or QPicture.
.PP
See also drawPixmap() and QPixmap::convertFromImage().
.SH "void QPainter::drawImage ( const QPoint &, const QImage & )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawImage ( const QPoint &, const QImage &, const QRect & sr )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawImage ( const QPoint &, const QImage &, const QRect & sr, int conversion_flags )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawImage ( const QPoint &, const QImage &, int conversion_flags )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawImage ( int x, int y, const QImage & image, int sx=0, int sy=0, int sw=-1, int sh=-1 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawLine ( int x1, int y1, int x2, int y2 )"
Draws a line from \fI(x1,y2)\fR to \fI(x2,y2)\fR and sets \fI(x2,y2)\fR to be the new current pen position.
.PP
See also QPen.
.PP
Examples:
.(l
grapher/grapher.cpp drawlines/connect.cpp progress/progress.cpp splitter/splitter.cpp scrollview/scrollview.cpp
.)l
.SH "void QPainter::drawLine ( const QPoint & p1, const QPoint & p2 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawLineSegments ( const QPointArray & a, int index=0, int nlines=-1 )"
Draws \fInlines\fR separate lines from points defined in \fIa,\fR starting at a[\fIindex]\fR (\fIindex\fR defaults to 0). If \fInlines\fR is -1 (the defauls) all points until the end of the array are used (i.e. (a.size()-index)/2 lines are drawn).
.PP
Draws the 1st line from \fIa[index]\fR to \fIa[index+1].\fR Draws the 2nd line from \fIa[index+2]\fR to \fIa[index+3]\fR etc.
.PP
See also drawPolyline(), drawPolygon() and QPen.
.SH "void QPainter::drawPicture ( const QPicture & pic )"
Replays the picture \fIpic.\fR
.PP
This function does exactly the same as QPicture::play().
.PP
Examples:
.(l
picture/picture.cpp
.)l
.SH "void QPainter::drawPie ( int x, int y, int w, int h, int a, int alen )"
Draws a pie defined by the rectangle \fI(x,y,w,h),\fR the start angle \fIa\fR and the arc length \fIalen.\fR
.PP
The pie is filled with the current brush().
.PP
The angles \fIa\fR and \fIalen\fR are 1/16th of a degree, i.e. a full circle equals 5760 (16*360). Positive values of \fIa\fR and \fIalen\fR mean counter-clockwise while negative values mean clockwise direction. Zero degrees is at the 3'o clock position.
.PP
See also drawArc() and drawChord().
.PP
Examples:
.(l
grapher/grapher.cpp drawdemo/drawdemo.cpp
.)l
.SH "void QPainter::drawPie ( const QRect & r, int a, int alen )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawPixmap ( int x, int y, const QPixmap & pixmap, int sx=0, int sy=0, int sw=-1, int sh=-1 )"
Draws a pixmap at \fI(x,y)\fR by copying a part of \fIpixmap\fR into the paint device.
.PP
\fI(x,y)\fR specify the top-left point in the paint device that is to be drawn onto. \fI(sx,sy)\fR specify the top-left point in \fIpixmap\fR that is to be drawn (the default is (0,0). \fI(sw,sh)\fR specify the size of the pixmap that is to be drawn (the default, (-1,-1), means all the way to the right/bottom of the pixmap).
.PP
See also bitBlt() and QPixmap::setMask().
.PP
Examples:
.(l
qtimage/qtimage.cpp grapher/grapher.cpp qmag/qmag.cpp scrollview/scrollview.cpp movies/main.cpp picture/picture.cpp
.)l
.SH "void QPainter::drawPixmap ( const QPoint & p, const QPixmap & pm )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version of the call draws the entire pixmap.
.SH "void QPainter::drawPixmap ( const QPoint & p, const QPixmap & pm, const QRect & sr )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawPoint ( int x, int y )"
Draws/plots a single point at \fI(x,y)\fR using the current pen.
.PP
See also QPen.
.PP
Examples:
.(l
drawlines/connect.cpp desktop/desktop.cpp
.)l
.SH "void QPainter::drawPoint ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawPoints ( const QPointArray & a, int index=0, int npoints=-1 )"
Draws/plots an array of points using the current pen.
.PP
If \fIindex\fR is non-zero (the default is zero) only points from \fIindex\fR are drawn. If \fInpoints\fR is negative (the default) the rest of the points from \fIindex\fR are drawn. If is is zero or greater, \fInpoints\fR points are drawn.
.SH "void QPainter::drawPolygon ( const QPointArray & a, bool winding=FALSE, int index=0, int npoints=-1 )"
Draws the polygon defined by the \fInpoints\fR points in \fIa\fR starting at \fIa[index].\fR (\fIindex\fR defaults to 0.)
.PP
If \fInpoints\fR is -1 (the default) all points until the end of the array are used (i.e. a.size()-index line segments define the polygon).
.PP
The first point is always connected to the last point.
.PP
The polygon is filled with the current brush(). If \fIwinding\fR is TRUE, the polygon is filled using the winding fill algorithm. If \fIwinding\fR is FALSE, the polygon is filled using the even-odd (alternative) fill algorithm.
.PP
See also drawLineSegments(), drawPolyline() and QPen.
.PP
Examples:
.(l
desktop/desktop.cpp picture/picture.cpp
.)l
.SH "void QPainter::drawPolyline ( const QPointArray & a, int index=0, int npoints=-1 )"
Draws the polyline defined by the \fInpoints\fR points in \fIa\fR starting at \fIa[index].\fR (\fIindex\fR defaults to 0.)
.PP
If \fInpoints\fR is -1 (the default) all points until the end of the array are used (i.e. a.size()-index-1 line segments are drawn).
.PP
See also drawLineSegments(), drawPolygon() and QPen.
.SH "void QPainter::drawQuadBezier ( const QPointArray & a, int index=0 )"
Draws a cubic Bezier curve defined by the control points in \fIa,\fR starting at \fIa[index].\fR (\fIindex\fR defaults to 0.)
.PP
Control points after \fIa[index+3]\fR are ignored. Nothing happens if there aren't enough control points.
.SH "void QPainter::drawRect ( int x, int y, int w, int h )"
Draws a rectangle with upper left corner at \fI(x,y)\fR and with width \fIw\fR and height \fIh.\fR
.PP
See also QPen and drawRoundRect().
.PP
Examples:
.(l
grapher/grapher.cpp drawdemo/drawdemo.cpp forever/forever.cpp trivial/trivial.cpp picture/picture.cpp
.)l
.SH "void QPainter::drawRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawRoundRect ( int x, int y, int w, int h, int xRnd, int yRnd )"
Draws a rectangle with round corners at \fI(x,y),\fR with width \fIw\fR and height \fIh.\fR
.PP
The \fIxRnd\fR and \fIyRnd\fR arguments specify how rounded the corners should be. 0 is angled corners, 99 is maximum roundedness.
.PP
The width and height include all of the drawn lines.
.PP
See also drawRect() and QPen.
.PP
Examples:
.(l
drawdemo/drawdemo.cpp
.)l
.SH "void QPainter::drawRoundRect ( const QRect & r, int xRnd, int yRnd )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawRoundRect ( const QRect & )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
As the main version of the function, but with the roundness arguments fixed at 25.
.SH "void QPainter::drawRoundRect ( int x, int y, int w, int h )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
As the main version of the function, but with the roundness arguments fixed at 25.
.SH "void QPainter::drawText ( int x, int y, const QString & str, int len = -1 )"
Draws at most \fIlen\fR characters from \fIstr\fR at position \fI(x,y).\fR
.PP
\fI(x,y)\fR is the base line position. Note that the meaning of \fIy\fR is not the same for the two drawText() varieties.
.PP
Examples:
.(l
grapher/grapher.cpp drawdemo/drawdemo.cpp menu/menu.cpp progress/progress.cpp desktop/desktop.cpp scrollview/scrollview.cpp trivial/trivial.cpp movies/main.cpp picture/picture.cpp
.)l
.SH "void QPainter::drawText ( int x, int y, int w, int h, int tf, const QString & str, int len = -1, QRect * brect=0, char ** internal=0 )"
Draws at most \fIlen\fR characters from \fIstr\fR in the rectangle \fI(x,y,w,h).\fR
.PP
Note that the meaning of \fIy\fR is not the same for the two drawText() varieties.
.PP
This function draws formatted text. The \fItf\fR text formatting is really of type Qt::AlignmentFlags.
.PP
Horizontal alignment defaults to AlignLeft and vertical alignment defaults to AlignTop.
.PP
\fIbrect\fR (if non-null) is set to the actual bounding rectangle of the output. \fIinternal\fR is, yes, internal.
.PP
See also boundingRect().
.SH "void QPainter::drawText ( const QPoint & p, const QString &, int len = -1 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawText ( const QRect & r, int tf, const QString &, int len = -1, QRect * br=0, char ** i=0 )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawTiledPixmap ( int x, int y, int w, int h, const QPixmap & pixmap, int sx=0, int sy=0 )"
Draws a tiled \fIpixmap\fR in the specified rectangle.
.PP
\fI(x,y)\fR specify the top-left point in the paint device that is to be drawn onto. \fI(sx,sy)\fR specify the top-left point in \fIpixmap\fR that is to be drawn (the default is (0,0).
.PP
Calling drawTiledPixmap() is similar to calling drawPixmap() several times to fill (tile) an area with a pixmap, but is potentially much more efficient depending on the underlying window system.
.PP
See also drawPixmap().
.SH "void QPainter::drawTiledPixmap ( const QRect & r, const QPixmap & pm )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawTiledPixmap ( const QRect & r, const QPixmap & pm, const QPoint & sp )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawWinFocusRect ( int x, int y, int w, int h )"
Draws a Windows focus rectangle with upper left corner at \fI(x,y)\fR and with width \fIw\fR and height \fIh.\fR
.PP
This function draws a stippled XOR rectangle that is used to indicate keyboard focus (when QApplication::style() is \fCWindowStyle).
.PP
\fBWarning:\fR\fR This function draws nothing if the coordinate system has been rotated or sheared.
.PP
See also drawRect() and QApplication::style().
.SH "void QPainter::drawWinFocusRect ( int x, int y, int w, int h, const QColor & bgColor )"
Draws a Windows focus rectangle with upper left corner at \fI(x,y)\fR and with width \fIw\fR and height \fIh\fR using a pen color that contrasts with \fIbgColor.\fR
.PP
This function draws a stippled rectangle (XOR is not used) that is used to indicate keyboard focus (when the QApplication::style() is \fCWindowStyle).\fR
.PP
The pen color used to draw the rectangle is either white or black depending on the color of \fIbgColor\fR (see QColor::gray()).
.PP
\fBWarning:\fR This function draws nothing if the coordinate system has been rotated or sheared.
.PP
See also drawRect() and QApplication::style().
.SH "void QPainter::drawWinFocusRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::drawWinFocusRect ( const QRect & r, const QColor & bgColor )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "bool QPainter::end ()"
Ends painting. Any resources used while painting are released.
.PP
Note that while you mostly don't need to call end(), the destructor will do it, there is at least one common case, namely double buffering.
.PP
.nf
.br
    QPainter p( myPixmap, this )
.br
    // ...
.br
    p.end(); // stops drawing on myPixmap
.br
    p.begin( this );
.br
    p.drawPixmap( myPixmap );
.fi
.PP
Since you can't draw a QPixmap while it is being painted, it is necessary to close the active painter.
.PP
See also begin() and isActive().
.PP
Examples:
.(l
desktop/desktop.cpp picture/picture.cpp
.)l
.SH "void QPainter::eraseRect ( int x, int y, int w, int h )"
Erases the area inside \fI(x,y,w,h).\fR Equivalent to \fCfillRect( x, y, w, h, backgroundColor() )\fR
.SH "void QPainter::eraseRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::fillRect ( int x, int y, int w, int h, const QBrush & brush )"
Fills the rectangle \fI(x,y,w,h)\fR with the \fIbrush.\fR
.PP
You can specify a QColor as \fIbrush,\fR since there is a QBrush constructor that takes a QColor argument and creates a solid pattern brush.
.PP
See also drawRect().
.PP
Examples:
.(l
progress/progress.cpp scrollview/scrollview.cpp
.)l
.SH "void QPainter::fillRect ( const QRect & r, const QBrush & brush )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::flush ()"
Flushes any buffered drawing operations.
.SH "const QFont & QPainter::font () const"
Returns the currently set painter font.
.PP
See also setFont() and QFont.
.SH "QFontInfo QPainter::fontInfo () const"
Returns the font info for the painter, if the painter is active. It is not possible to obtain font information for an inactive painter, so the return value is undefined if the painter is not active.
.PP
See also fontMetrics() and isActive().
.SH "QFontMetrics QPainter::fontMetrics () const"
Returns the font metrics for the painter, if the painter is active. It is not possible to obtain metrics for an inactive painter, so the return value is undefined if the painter is not active.
.PP
See also fontInfo() and isActive().
.PP
Examples:
.(l
drawdemo/drawdemo.cpp desktop/desktop.cpp scrollview/scrollview.cpp movies/main.cpp
.)l
.SH "bool QPainter::hasClipping () const"
Returns TRUE if clipping has been set, otherwise FALSE.
.PP
See also setClipping().
.SH "bool QPainter::hasViewXForm () const"
Returns TRUE if view transformation is enabled, otherwise FALSE.
.PP
See also setViewXForm() and xForm().
.SH "bool QPainter::hasWorldXForm () const"
Returns TRUE if world transformation is enabled, otherwise FALSE.
.PP
See also setWorldXForm().
.SH "void QPainter::initialize () \fC[static]\fR"
Internal function that initializes the painter.
.SH "bool QPainter::isActive () const"
Returns TRUE if the painter is active painting, i.e. begin() has been called and end() has not yet been called.
.PP
See also QPaintDevice::paintingActive().
.PP
Examples:
.(l
desktop/desktop.cpp
.)l
.SH "void QPainter::lineTo ( int x, int y )"
Draws a line from the current pen position to \fI(x,y)\fR and sets \fI(x,y)\fR to be the new current pen position.
.PP
See also QPen, moveTo(), drawLine() and pos().
.SH "void QPainter::lineTo ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::moveTo ( int x, int y )"
Sets the current pen position to \fI(x,y)\fR
.PP
See also lineTo() and pos().
.SH "void QPainter::moveTo ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "const QPen & QPainter::pen () const"
Returns the current pen for the painter.
.PP
See also setPen().
.PP
Examples:
.(l
progress/progress.cpp
.)l
.SH "QPoint QPainter::pos () const"
Returns the current position of the pen.
.PP
See also moveTo().
.SH "RasterOp QPainter::rasterOp () const"
Returns the current raster operation.
.PP
See also setRasterOp() and RasterOp.
.SH "void QPainter::redirect ( QPaintDevice * pdev, QPaintDevice * replacement ) \fC[static]\fR"
Redirects all paint command for a paint device \fIpdev\fR to another paint device \fIreplacement,\fR unless \fIreplacement\fR is 0. If \fIreplacement\fR is 0, the redirection for \fIpdev\fR is removed.
.PP
Mostly, you can get better results with less work by calling QPixmap::grabWidget() or QPixmap::grapWindow().
.SH "void QPainter::resetXForm ()"
Resets any transformations that were made using translate(), scale(), shear(), rotate(), setWorldMatrix(), setViewport() and setWindow()
.PP
See also worldMatrix(), viewport() and window().
.SH "void QPainter::restore ()"
Restores the current painter state (pops a saved state off the stack).
.PP
See also save().
.SH "void QPainter::restoreWorldMatrix ()"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
We recommend using save() instead.
.SH "void QPainter::rotate ( double a )"
Rotates the coordinate system \fIa\fR degrees.
.PP
See also translate(), scale(), shear(), resetXForm(), setWorldMatrix() and xForm().
.SH "void QPainter::save ()"
Saves the current painter state (pushes the state onto a stack). A save() must be followed by a corresponding restore(). end() unwinds the stack().
.PP
See also restore().
.SH "void QPainter::saveWorldMatrix ()"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
We recommend using save() instead.
.SH "void QPainter::scale ( double sx, double sy )"
Scales the coordinate system by \fI(sx,sy).\fR
.PP
See also translate(), shear(), rotate(), resetXForm(), setWorldMatrix() and xForm().
.SH "void QPainter::setBackgroundColor ( const QColor & c )"
Sets the background color of the painter to \fIc.\fR
.PP
The background color is the color that is filled in when drawing opaque text, stippled lines and bitmaps. The background color has no effect in transparent background mode (which is the default).
.PP
See also backgroundColor(), setBackgroundMode() and BackgroundMode.
.SH "void QPainter::setBackgroundMode ( BGMode m )"
Sets the background mode of the painter to \fIm,\fR which must be one of \fCTransparentMode\fR (the default) and \fCOpaqueMode.\fR
.PP
Transparent mode draws stippled lines and text without setting the background pixels. Opaque mode fills these space with the current background color.
.PP
Note that in order to draw a bitmap or pixmap transparently, you must use QPixmap::setMask().
.PP
See also backgroundMode() and setBackgroundColor().
.PP
Examples:
.(l
picture/picture.cpp
.)l
.SH "void QPainter::setBrush ( BrushStyle style )"
Sets a new painter brush with black color and the specified \fIstyle.\fR
.PP
See also brush() and QBrush.
.SH "void QPainter::setBrush ( const QBrush & brush )"
Sets a new painter brush.
.PP
The brush defines how to fill shapes.
.PP
See also brush().
.SH "void QPainter::setBrush ( const QColor & color )"
Sets a new painter brush with the style \fCSolidPattern\fR and the specified \fIcolor.\fR
.PP
See also brush() and QBrush.
.PP
Examples:
.(l
grapher/grapher.cpp drawdemo/drawdemo.cpp forever/forever.cpp desktop/desktop.cpp picture/picture.cpp
.)l
.SH "void QPainter::setBrushOrigin ( int x, int y )"
Sets the brush origin to \fI(x,y).\fR
.PP
The brush origin specifies the (0,0) coordinate of the painter's brush. This setting only applies to pattern brushes and pixmap brushes.
.PP
See also brushOrigin().
.SH "void QPainter::setBrushOrigin ( const QPoint & p )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::setClipRect ( int x, int y, int w, int h )"
Sets the clip region to the the rectangle \fI(x,y,w,h)\fR and enables clipping.
.PP
Note that the clip region is given in physical device coordinates and \fInot\fR subject to any coordinate transformation.
.PP
See also setClipRegion(), clipRegion() and setClipping().
.PP
Examples:
.(l
qtimage/qtimage.cpp grapher/grapher.cpp progress/progress.cpp splitter/splitter.cpp trivial/trivial.cpp
.)l
.SH "void QPainter::setClipRect ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
If the rectangle is invalid, the rectangle will be normalized() before the clipping region is set. This semantics will change in Qt-3 and an invalid rectangle will clip the painter to an empty rectangle.
.PP
See also QRect::isValid() and QRect::normalize().
.SH "void QPainter::setClipRegion ( const QRegion & rgn )"
Sets the clip region to \fIrgn\fR and enables clipping.
.PP
Note that the clip region is given in physical device coordinates and \fInot\fR subject to any coordinate transformation.
.PP
See also setClipRect(), clipRegion() and setClipping().
.SH "void QPainter::setClipping ( bool enable )"
Enables clipping if \fIenable\fR is TRUE, or disables clipping if \fIenable\fR is FALSE.
.PP
See also hasClipping(), setClipRect() and setClipRegion().
.SH "void QPainter::setFont ( const QFont & font )"
Sets a new painter font.
.PP
This font is used by subsequent drawText() functions. The text color is the same as the pen color.
.PP
See also font() and drawText().
.PP
Examples:
.(l
grapher/grapher.cpp drawdemo/drawdemo.cpp menu/menu.cpp scrollview/scrollview.cpp movies/main.cpp picture/picture.cpp
.)l
.SH "void QPainter::setPen ( PenStyle style )"
Sets a new painter pen with style \fCstyle,\fR width 0 and black color.
.PP
See also pen() and QPen.
.PP
Examples:
.(l
grapher/grapher.cpp drawlines/connect.cpp drawdemo/drawdemo.cpp progress/progress.cpp forever/forever.cpp desktop/desktop.cpp scrollview/scrollview.cpp movies/main.cpp
.)l
.SH "void QPainter::setPen ( const QColor & color )"
Sets a new painter pen with style \fCSolidLine,\fR width 0 and the specified \fIcolor.\fR
.PP
See also pen() and QPen.
.SH "void QPainter::setPen ( const QPen & pen )"
Sets a new painter pen.
.PP
The pen defines how to draw lines and outlines, and it also defines the text color.
.PP
See also pen().
.SH "void QPainter::setRasterOp ( RasterOp r )"
Sets the raster operation to \fIr.\fR The default is \fCCopyROP.\fR
.PP
See also rasterOp().
.SH "void QPainter::setTabArray ( int * ta )"
Sets the tab stop array to \fIta.\fR This puts tab stops at \fIta[0],\fR ta[1] and so on. The array is null-terminated.
.PP
If both a tab array and a tab top size is set, the tab array wins.
.PP
See also tabArray(), setTabStops(), drawText() and fontMetrics().
.SH "void QPainter::setTabStops ( int ts )"
Set the tab stop width to \fIts,\fR ie. locates tab stops at ts, 2*ts, 3*ts and so on.
.PP
Tab stops are used when drawing formatted text with \fCExpandTabs\fR set. This fixed tab stop value is used only if no tab array is set (which is the default case).
.PP
See also tabStops(), setTabArray(), drawText() and fontMetrics().
.SH "void QPainter::setViewXForm ( bool enable )"
Enables view transformations if \fIenable\fR is TRUE, or disables view transformations if \fIenable\fR is FALSE.
.PP
See also hasViewXForm(), setWindow(), setViewport(), setWorldMatrix(), setWorldXForm() and xForm().
.SH "void QPainter::setViewport ( int x, int y, int w, int h )"
Sets the viewport rectangle view transformation for the painter and enables view transformation.
.PP
The viewport rectangle is part of the view transformation. The viewport specifies the device coordinate system. Its sister, the window(), specifies the logical coordinate system.
.PP
The default viewport rectangle is the same as the device's rectangle. See the Coordinate System Overview for an overview of coordinate transformation.
.PP
See also viewport(), setWindow(), setViewXForm(), setWorldMatrix(), setWorldXForm() and xForm().
.SH "void QPainter::setViewport ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::setWindow ( int x, int y, int w, int h )"
Sets the window rectangle view transformation for the painter and enables view transformation.
.PP
The window rectangle is part of the view transformation. The window specifies the logical coordinate system. Its sister, the viewport(), specifies the device coordinate system.
.PP
The default window rectangle is the same as the device's rectangle. See the Coordinate System Overview for an overview of coordinate transformation.
.PP
See also window(), setViewport(), setViewXForm(), setWorldMatrix() and setWorldXForm().
.PP
Examples:
.(l
drawdemo/drawdemo.cpp
.)l
.SH "void QPainter::setWindow ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QPainter::setWorldMatrix ( const QWMatrix & m, bool combine=FALSE )"
Sets the world transformation matrix to \fIm\fR and enables world transformation.
.PP
If \fIcombine\fR is TRUE, then \fIm\fR is combined with the current transformation matrix, otherwise \fIm\fR replaces the current transformation matrix.
.PP
If \fIm\fR the identity matrix and \fIcombine\fR is FALSE, this function calls setWorldXForm(FALSE). (The identity matrix is the matrix where QWMatrix::m11() and QWMatrix::m22() are 1.0 and the rest are 0.0.)
.PP
World transformations are applied after the view transformations (i.e. window and viewport).
.PP
The following functions can transform the coordinate system without using a QWMatrix:
.TP
translate()
.TP
scale()
.TP
shear()
.TP
rotate()
.PP
They operate on the painter's worldMatrix() and are implemented like this:
.PP
.nf
.br
    void QPainter::rotate( double a )
.br
    {
.br
        QWMatrix m;
.br
        m.rotate( a );
.br
        setWorldMatrix( m, TRUE );
.br
    }
.fi
.PP
Note that you should always use \fIcombine\fR when you are drawing into a QPicture. Otherwise it may not be possible to replay the picture with additional transformations. Using translate(), scale(), etc. is safe.
.PP
For a brief overview of coordinate transformation, see the Coordinate System Overview.
.PP
See also worldMatrix(), setWorldXForm(), setWindow(), setViewport(), setViewXForm(), xForm() and QWMatrix.
.PP
Examples:
.(l
drawdemo/drawdemo.cpp
.)l
.SH "void QPainter::setWorldXForm ( bool enable )"
Enables world transformations if \fIenable\fR is TRUE, or disables world transformations if \fIenable\fR is FALSE. The world transformation matrix is not changed.
.PP
See also setWorldMatrix(), setWindow(), setViewport(), setViewXForm() and xForm().
.SH "void QPainter::shear ( double sh, double sv )"
Shears the coordinate system \fI(sh,sv).\fR
.PP
See also translate(), scale(), rotate(), resetXForm(), setWorldMatrix() and xForm().
.SH "int * QPainter::tabArray () const"
Returns the currently set tab stop array.
.PP
See also setTabArray().
.SH "int QPainter::tabStops () const"
Returns the tab stop setting.
.PP
See also setTabStops().
.SH "void QPainter::translate ( double dx, double dy )"
Translates the coordinate system by \fI(dx,dy).\fR
.PP
For example, the following code draws a single vertical line 20 pixels high.
.PP
.nf
.br
    void MyWidget::paintEvent()
.br
    {
.br
        QPainter paint( this );
.br
        paint.drawLine(10,0,10,20);
.br
        paint.translate(100.0,100.0);
.br
        paint.drawLine(-90,-80,-90,-70);
.br
    }
.fi
.PP
See also scale(), shear(), rotate(), resetXForm(), setWorldMatrix() and xForm().
.SH "QRect QPainter::viewport () const"
Returns the viewport rectangle.
.PP
See also setViewport() and setViewXForm().
.SH "QRect QPainter::window () const"
Returns the window rectangle.
.PP
See also setWindow() and setViewXForm().
.SH "const QWMatrix & QPainter::worldMatrix () const"
Returns the world transformation matrix.
.PP
See also setWorldMatrix().
.SH "QPoint QPainter::xForm ( const QPoint & pv ) const"
Returns the point \fIpv\fR transformed from model coordinates to device coordinates.
.PP
See also xFormDev() and QWMatrix::map().
.SH "QPointArray QPainter::xForm ( const QPointArray & av ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Returns the point array \fIav\fR transformed from model coordinates to device coordinates.
.PP
See also xFormDev() and QWMatrix::map().
.SH "QPointArray QPainter::xForm ( const QPointArray & av, int index, int npoints ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Returns the point array \fIav\fR transformed from model coordinates to device coordinates. The \fIindex\fR is the first point in the array and \fInpoints\fR denotes the number of points to be transformed. If \fInpoints\fR is negative, all points from \fIav[index]\fR until the last point in the array are transformed.
.PP
The returned point array consists of the number of points that were transformed.
.PP
Example:
.PP
.nf
.br
    QPointArray a(10);
.br
    QPointArray b;
.br
    b = painter.xForm(a,2,4);   // b.size() == 4
.br
    b = painter.xForm(a,2,-1);  // b.size() == 8
.fi
.PP
See also xFormDev() and QWMatrix::map().
.SH "QRect QPainter::xForm ( const QRect & rv ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Returns the rectangle \fIrv\fR transformed from model coordinates to device coordinates.
.PP
If world transformation is enabled and rotation or shearing has been specified, then the bounding rectangle is returned.
.PP
See also xFormDev() and QWMatrix::map().
.SH "QPoint QPainter::xFormDev ( const QPoint & pd ) const"
Returns the point \fIpv\fR transformed from device coordinates to model coordinates.
.PP
See also xForm() and QWMatrix::map().
.SH "QPointArray QPainter::xFormDev ( const QPointArray & ad ) const"
Returns the point array \fIav\fR transformed from device coordinates to model coordinates.
.PP
See also xForm() and QWMatrix::map().
.SH "QRect QPainter::xFormDev ( const QRect & rd ) const"
Returns the rectangle \fIrv\fR transformed from device coordinates to model coordinates.
.PP
If world transformation is enabled and rotation or shearing is used, then the bounding rectangle is returned.
.PP
See also xForm() and QWMatrix::map().
.SH "QPointArray QPainter::xFormDev ( const QPointArray & ad, int index, int npoints ) const"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Returns the point array \fIad\fR transformed from device coordinates to model coordinates. The \fIindex\fR is the first point in the array and \fInpoints\fR denotes the number of points to be transformed. If \fInpoints\fR is negative, all points from \fIav[index]\fR until the last point in the array are transformed.
.PP
The returned point array consists of the number of points that were transformed.
.PP
Example:
.PP
.nf
.br
    QPointArray a(10);
.br
    QPointArray b;
.br
    b = painter.xFormDev(a,1,3);        // b.size() == 3
.br
    b = painter.xFormDev(a,1,-1);       // b.size() == 9
.fi
.PP
See also xForm() and QWMatrix::map().
.SH RELATED FUNCTION DOCUMENTATION
.SH "void qDrawPlainRect (QPainter * p, int x, int y, int w, int h, const QColor & c, int lineWidth, const QBrush * fill)"
\fC#include <qdrawutil.h>\fR
.PP
Draws a plain rectangle given by (\fIx, y, w, h)\fR using the painter \fIp.\fR
.PP
The color argument \fIc\fR specifies the line color.
.PP
The \fIlineWidth\fR argument specifies the line width.
.PP
The rectangle interior is filled with the \fIfill\fR brush unless \fIfill\fR is null.
.PP
If you want to use a QFrame widget instead, you can make it display a plain rectangle, for example \fCQFrame::setFrameStyle( QFrame::Box | QFrame::Plain )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadeRect() and QStyle::drawRect().
.SH "void qDrawWinPanel (QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, const QBrush * fill)"
\fC#include <qdrawutil.h>\fR
.PP
Draws a Windows-style panel given by (\fIx, y, w, h)\fR using the painter \fIp.\fR
.PP
The color group argument \fIg\fR specifies the shading colors.
.PP
The panel appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The line width is 2 pixels.
.PP
The button interior is filled with the \fIfill\fR brush unless \fIfill\fR is null.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded panel, for example \fCQFrame::setFrameStyle( QFrame::WinPanel | QFrame::Raised )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadePanel(), qDrawWinButton() and QStyle::drawPanel().
.SH "void qDrawShadeLine (QPainter * p, int x1, int y1, int x2, int y2, const QColorGroup & g, bool sunken, int lineWidth, int midLineWidth)"
\fC#include <qdrawutil.h>\fR
.PP
Draws a horizontal (\fIy1\fR == \fIy2)\fR or vertical (\fIx1\fR == \fIx2)\fR shaded line using the painter \fIp.\fR
.PP
Nothing is drawn if \fIy1\fR != \fIy2\fR and \fIx1\fR != \fIx2\fR (i.e. the line is neither horizontal nor vertical).
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The line appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The \fIlineWidth\fR argument specifies the line width for each of the lines. It is not the total line width.
.PP
The \fImidLineWidth\fR argument specifies the width of a middle line drawn in the QColorGroup::mid() color.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded line, for example \fCQFrame::setFrameStyle( QFrame::HLine | QFrame::Sunken )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadeRect(), qDrawShadePanel() and QStyle::drawSeparator().
.SH "void qDrawShadeRect (QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, int lineWidth, int midLineWidth, const QBrush * fill)"
\fC#include <qdrawutil.h>\fR
.PP
Draws a shaded rectangle/box given by (\fIx, y, w, h)\fR using the painter \fIp.\fR
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The rectangle appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The \fIlineWidth\fR argument specifies the line width for each of the lines. It is not the total line width.
.PP
The \fImidLineWidth\fR argument specifies the width of a middle line drawn in the QColorGroup::mid() color.
.PP
The rectangle interior is filled with the \fIfill\fR brush unless \fIfill\fR is null.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded rectangle, for example \fCQFrame::setFrameStyle( QFrame::Box | QFrame::Raised )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawShadeLine(), qDrawShadePanel(), qDrawPlainRect(), QStyle::drawRect() and QStyle::drawRectStrong().
.SH "void qDrawShadePanel (QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, int lineWidth, const QBrush * fill)"
\fC#include <qdrawutil.h>\fR
.PP
Draws a shaded panel given by (\fIx, y, w, h)\fR using the painter \fIp.\fR
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The panel appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The \fIlineWidth\fR argument specifies the line width.
.PP
The panel interior is filled with the \fIfill\fR brush unless \fIfill\fR is null.
.PP
If you want to use a QFrame widget instead, you can make it display a shaded panel, for example \fCQFrame::setFrameStyle( QFrame::Panel | QFrame::Sunken )\fR.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also qDrawWinPanel(), qDrawShadeLine(), qDrawShadeRect() and QStyle::drawPanel().
.SH "void qDrawWinButton (QPainter * p, int x, int y, int w, int h, const QColorGroup & g, bool sunken, const QBrush * fill)"
\fC#include <qdrawutil.h>\fR
.PP
Draws a Windows-style button given by (\fIx, y, w, h)\fR using the painter \fIp.\fR
.PP
The color group argument \fIg\fR specifies the shading colors (light, dark and middle colors).
.PP
The button appears sunken if \fIsunken\fR is TRUE, or raised if \fIsunken\fR is FALSE.
.PP
The line width is 2 pixels.
.PP
The button interior is filled with the \fI*fill\fR brush unless \fIfill\fR is null.
.PP
\fBWarning:\fR This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.
.PP
See also  qDrawWinPanel() and QStyle::drawButton().
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qpainter.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qpainter.3qt) and the Qt
version (2.3.2).
