'\" t
.TH QScrollView 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QScrollView \- Scrolling area with on-demand scrollbars
.br
.PP
\fC#include <qscrollview.h>\fR
.PP
Inherits QFrame.
.PP
Inherited by QCanvasView, QIconView, QListBox, QListView, QTable and QTextView.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQScrollView\fR ( QWidget * " "parent" "=0, const char * " "name" "=0, WFlags " "f" "=0 ) "
.br
.ti -1c
.BI "\fB~QScrollView\fR () "
.br
.ti -1c
.BI "enum \fBResizePolicy\fR { Default, Manual, AutoOne, AutoOneFit }"
.br
.ti -1c
.BI "virtual void \fBsetResizePolicy\fR ( ResizePolicy ) "
.br
.ti -1c
.BI "ResizePolicy \fBresizePolicy\fR () const"
.br
.ti -1c
.BI "void \fBremoveChild\fR ( QWidget * child ) "
.br
.ti -1c
.BI "virtual void \fBaddChild\fR ( QWidget * " "child" ", int " "x" "=0, int " "y" "=0 ) "
.br
.ti -1c
.BI "virtual void \fBmoveChild\fR ( QWidget * " "child" ", int " "x" ", int y ) "
.br
.ti -1c
.BI "int \fBchildX\fR ( QWidget * child ) "
.br
.ti -1c
.BI "int \fBchildY\fR ( QWidget * child ) "
.br
.ti -1c
.BI "bool childIsVisible ( QWidget * child ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "void showChild ( QWidget * " "child" ", bool " "yes" "=TRUE ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "enum \fBScrollBarMode\fR { Auto, AlwaysOff, AlwaysOn }"
.br
.ti -1c
.BI "ScrollBarMode \fBvScrollBarMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetVScrollBarMode\fR ( ScrollBarMode ) "
.br
.ti -1c
.BI "ScrollBarMode \fBhScrollBarMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetHScrollBarMode\fR ( ScrollBarMode ) "
.br
.ti -1c
.BI "QWidget* \fBcornerWidget\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCornerWidget\fR ( QWidget * ) "
.br
.ti -1c
.BI "QScrollBar* \fBhorizontalScrollBar\fR () const"
.br
.ti -1c
.BI "QScrollBar* \fBverticalScrollBar\fR () const"
.br
.ti -1c
.BI "QWidget* \fBviewport\fR () const"
.br
.ti -1c
.BI "QWidget* \fBclipper\fR () const"
.br
.ti -1c
.BI "int \fBvisibleWidth\fR () const"
.br
.ti -1c
.BI "int \fBvisibleHeight\fR () const"
.br
.ti -1c
.BI "int \fBcontentsWidth\fR () const"
.br
.ti -1c
.BI "int \fBcontentsHeight\fR () const"
.br
.ti -1c
.BI "int \fBcontentsX\fR () const"
.br
.ti -1c
.BI "int \fBcontentsY\fR () const"
.br
.ti -1c
.BI "void \fBupdateContents\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBupdateContents\fR ( const QRect & r ) "
.br
.ti -1c
.BI "void \fBrepaintContents\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "void \fBrepaintContents\fR ( const QRect & " "r" ", bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "void \fBcontentsToViewport\fR ( int " "x" ", int " "y" ", int & " "vx" ", int & vy ) "
.br
.ti -1c
.BI "void \fBviewportToContents\fR ( int " "vx" ", int " "vy" ", int & " "x" ", int & y ) "
.br
.ti -1c
.BI "QPoint \fBcontentsToViewport\fR ( const QPoint & ) "
.br
.ti -1c
.BI "QPoint \fBviewportToContents\fR ( const QPoint & ) "
.br
.ti -1c
.BI "void \fBenableClipper\fR ( bool y ) "
.br
.ti -1c
.BI "void \fBsetStaticBackground\fR ( bool y ) "
.br
.ti -1c
.BI "bool \fBhasStaticBackground\fR () const"
.br
.ti -1c
.BI "QSize \fBviewportSize\fR ( int, int ) const"
.br
.ti -1c
.BI "void \fBsetDragAutoScroll\fR ( bool b ) "
.br
.ti -1c
.BI "bool \fBdragAutoScroll\fR () const"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBresizeContents\fR ( int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBscrollBy\fR ( int " "dx" ", int dy ) "
.br
.ti -1c
.BI "virtual void \fBsetContentsPos\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBensureVisible\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBensureVisible\fR ( int " "x" ", int " "y" ", int " "xmargin" ", int ymargin ) "
.br
.ti -1c
.BI "void \fBcenter\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBcenter\fR ( int " "x" ", int " "y" ", float " "xmargin" ", float ymargin ) "
.br
.ti -1c
.BI "void \fBupdateScrollBars\fR () "
.br
.in -1c
.SS "Signals"
.in +1c
.ti -1c
.BI "void \fBcontentsMoving\fR ( int " "x" ", int y ) "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual bool \fBeventFilter\fR ( QObject *, QEvent * e ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMousePressEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMouseReleaseEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMouseDoubleClickEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsMouseMoveEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsDragEnterEvent\fR ( QDragEnterEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsDragMoveEvent\fR ( QDragMoveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsDragLeaveEvent\fR ( QDragLeaveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsDropEvent\fR ( QDropEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcontentsWheelEvent\fR ( QWheelEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportPaintEvent\fR ( QPaintEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportResizeEvent\fR ( QResizeEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportMousePressEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportMouseReleaseEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportMouseDoubleClickEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportMouseMoveEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportDragEnterEvent\fR ( QDragEnterEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportDragMoveEvent\fR ( QDragMoveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportDragLeaveEvent\fR ( QDragLeaveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportDropEvent\fR ( QDropEvent * ) "
.br
.ti -1c
.BI "virtual void \fBviewportWheelEvent\fR ( QWheelEvent * ) "
.br
.ti -1c
.BI "virtual void \fBdrawContentsOffset\fR ( QPainter *, int " "ox" ", int " "oy" ", int " "cx" ", int " "cy" ", int " "cw" ", int ch ) "
.br
.ti -1c
.BI "virtual void \fBdrawContents\fR ( QPainter *, int " "cx" ", int " "cy" ", int " "cw" ", int ch ) "
.br
.ti -1c
.BI "virtual void \fBsetMargins\fR ( int " "left" ", int " "top" ", int " "right" ", int bottom ) "
.br
.ti -1c
.BI "int \fBleftMargin\fR () const"
.br
.ti -1c
.BI "int \fBtopMargin\fR () const"
.br
.ti -1c
.BI "int \fBrightMargin\fR () const"
.br
.ti -1c
.BI "int \fBbottomMargin\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetHBarGeometry\fR ( QScrollBar & " "hbar" ", int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "virtual void \fBsetVBarGeometry\fR ( QScrollBar & " "vbar" ", int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
ResizePolicy	resizePolicy	resizePolicy	setResizePolicy
ScrollBarMode	vScrollBarMode	vScrollBarMode	setVScrollBarMode
ScrollBarMode	hScrollBarMode	hScrollBarMode	setHScrollBarMode
int	visibleWidth	visibleWidth
int	visibleHeight	visibleHeight
int	contentsWidth	contentsWidth
int	contentsHeight	contentsHeight
int	contentsX	contentsX
int	contentsY	contentsY
bool	dragAutoScroll	dragAutoScroll	setDragAutoScroll
.TE
.fi

.SH DESCRIPTION
The QScrollView widget provides a scrolling area with on-demand scrollbars.
.PP
The QScrollView is a large canvas - potentially larger than the coordinate system normally supported by the underlying window system. This is important, as is is quite easy to go beyond such limitations (eg. many web pages are more than 32000 pixels high). Additionally, the QScrollView can have QWidgets positioned on it that scroll around with the drawn content. These subwidgets can also have positions outside the normal coordinate range (but they are still limited in size).
.PP
To provide content for the widget, inherit from QScrollView and reimplement drawContents(), and use resizeContents() to set the size of the viewed area. Use addChild() / moveChild() to position widgets on the view.
.PP
To use QScrollView effectively, it is important to understand its widget structure in the three styles of usage: a single large child widget, a large panning area with some widgets, a large panning area with many widgets.
.IP "\fBOne Big Widget\fR" 1c
.PP
.ce 1
.B "[Image Omitted]"
.PP
The first, simplest usage of QScrollView depicted above is appropriate for scrolling areas which are \fInever\fR more than about 4000 pixels in either dimension (this is about the maximum reliable size on X11 servers). In this usage, you just make one large child in the QScrollView. The child should be a child of the viewport() of the scrollview, and be added with addChild():
.PP
.nf
.br
    QScrollView* sv = new QScrollView(...);
.br
    QVBox* big_box = new QVBox(sv->viewport());
.br
    sv->addChild(big_box);
.fi
.PP
You may go on to add arbitrary child widgets to the single child in the scrollview, as you would with any widget:
.PP
.nf
.br
    QLabel* child1 = new QLabel("CHILD", big_box);
.br
    QLabel* child2 = new QLabel("CHILD", big_box);
.br
    QLabel* child3 = new QLabel("CHILD", big_box);
.br
    ...
.fi
.PP
Here, the QScrollView has 4 children - the viewport(), the verticalScrollBar(), the horizontalScrollBar(), and a small cornerWidget(). The viewport() has 1 child, the big QVBox. The QVBox has the three labels as child widgets. When the view is scrolled, the QVBox is moved, and its children move with it as child widgets normally do.
.IP "\fBVery Big View, some Widgets\fR" 1c
.PP
.ce 1
.B "[Image Omitted]"
.PP
The second usage of QScrollView depicted above is appropriate when few, if any, widgets are on a very large scrolling area that is potentially larger than 4000 pixels in either dimension. In this usage, you call resizeContents() to set the size of the area, and reimplement drawContents() to paint the contents. You may also add some widgets, by making them children of the viewport() and adding them with addChild() (this is the same as the process for the single large widget in the previous example):
.PP
.nf
.br
    QScrollView* sv = new QScrollView(...);
.br
    QLabel* child1 = new QLabel("CHILD", sv->viewport());
.br
    sv->addChild(child1);
.br
    QLabel* child2 = new QLabel("CHILD", sv->viewport());
.br
    sv->addChild(child2);
.br
    QLabel* child3 = new QLabel("CHILD", sv->viewport());
.br
    sv->addChild(child3);
.fi
.PP
Here, the QScrollView has the same 4 children - the viewport(), the verticalScrollBar(), the horizontalScrollBar(), and a small cornerWidget(). The viewport() has the three labels as child widgets. When the view is scrolled, the scrollview moves the child widgets individually.
.IP "\fBVery Big View, many Widgets\fR" 1c
.PP
.ce 1
.B "[Image Omitted]"
.PP
The final usage of QScrollView depicted above is appropriate when many widgets are on a very large scrolling area that is potentially larger than 4000 pixels in either dimension. In this usage, you call resizeContents() to set the size of the area, and reimplement drawContents() to paint the contents. You then call enableClipper(TRUE) and add widgets, again by making them children of the viewport() and adding them with addChild():
.PP
.nf
.br
    QScrollView* sv = new QScrollView(...);
.br
    sv->enableClipper(TRUE);
.br
    QLabel* child1 = new QLabel("CHILD", sv->viewport());
.br
    sv->addChild(child1);
.br
    QLabel* child2 = new QLabel("CHILD", sv->viewport());
.br
    sv->addChild(child2);
.br
    QLabel* child3 = new QLabel("CHILD", sv->viewport());
.br
    sv->addChild(child3);
.fi
.PP
Here, the QScrollView has 4 children - the clipper() (\fInot\fR the viewport() this time), the verticalScrollBar(), the horizontalScrollBar(), and a small cornerWidget(). The clipper() has 1 child - the viewport(). The viewport() has the three labels as child widgets. When the view is scrolled, the viewport() is moved, and its children move with it as child widgets normally do.
.PP
Normally you will use the first or third method if you want any child widgets in the view.
.PP
Note that the widget you see in the scrolled area is the viewport() widget, not the QScrollView itself. So, to turn mouse tracking on for example, use viewport()->setMouseTracking(TRUE).
.PP
To enable drag-and-drop, you would setAcceptDrops(TRUE) on the QScrollView (since drag-and-drop events propagate to the parent), but to work out what logical position in the view, you would need to map the drop co-ordinate from being relative to the QScrollView to being relative to the contents - use the function viewportToContents() for this.
.PP
To handle mouse events on the scrolling area, subclass scrollview as you would subclass other widgets, but rather than overriding mousePressEvent(), reimplement viewportMousePressEvent() instead (if you reimplement mousePressEvent() you'll only get called when part of the QScrollView is clicked - and the only such part is the "corner" (if you don't set a cornerWidget()) and the frame, everything else being covered up by the viewport, clipper, or scrollbars.
.PP
When you construct a QScrollView, some of the widget flags apply to the viewport(), instead of being sent to the QWidget constructor for the QScrollView. This applies to \fCWResizeNoErase, WNorthWestGravity, WRepaintNoErase\fR and \fCWPaintClever.\fR See Qt::WidgetFlags for documentation about these flags. Here are some examples: 
.TP
An image manipulation widget would use \fCWResizeNoErase|WNorthWestGravity,\fR because the widget draws all pixels itself and when the size increases, it only needs a paint event for the new part, since the old part remains unchanged.
.TP
A word processing widget might use \fCWResizeNoErase\fR and repaint itself line by line to get a less flickery resizing. If the widget is in a mode where no text justification can take place, it might use \fCWNorthWestGravity\fR too, so that it would only get a repaint for the newly visible parts.
.TP
A scrolling game widget where the background scrolls as the characters move might use \fCWRepaintNoErase\fR (in addition to \fCWNorthWestGravity\fR and \fCWResizeNoErase)\fR so that the window system background does not flash in and out during scrolling.
.PP
\fBWarning:\fR WResizeNoErase is currently set by default, i.e. you always have to clear the background manually in scrollview subclasses. This will change in a future version of Qt, and we recommend specifying the flag explicitly.
.PP
.ce 1
.B "[Image Omitted]"
.PP

.ce 1
.B "[Image Omitted]"
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SS "Member Type Documentation"
.SH "QScrollView::ResizePolicy"
This enum type is used to control QScrollView's reaction to resize events. There are four possible settings:
.TP
\fCDefault\fR - QScrollView selects one of the other settings automatically when it has to. In this version of Qt, QScrollView changes to \fCManual\fR if you resize the contents with resizeContents(), and to \fCAutoOne\fR if a child is added.
.TP
\fCManual\fR - the view stays the size set by resizeContents().
.TP
\fCAutoOne\fR - if there is only child widget, the view stays the size of that widget. Otherwise, the behaviour is undefined.
.TP
\fCAutoOneFit\fR - if there is only one child widget the view stays the size of that widget's sizeHint(). If the scrollview is resized bigger than the child's sizeHint(), the child will be resized to fit. If there is more than one child, the behaviour is undefined.
.IP
.SH "QScrollView::ScrollBarMode"
This enum type describes the various modes of QScrollView's scroll bars. The defined modes are: 
.TP
\fCAuto\fR - QScrollView shows a scrollbar when the content is too tall to fit and not else. This is the default.
.TP
\fCAlwaysOff\fR - QScrollView never shows a scrollbar.
.TP
\fCAlwaysOn\fR - QScrollView always shows a scrollbar.
.IP
.PP
(The modes for the horizontal and vertical scroll bars are independent.).
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QScrollView::QScrollView ( QWidget * parent=0, const char * name=0, WFlags f=0 )"
Constructs a QScrollView with a \fIparent,\fR a \fIname\fR and widget flags \fIf.\fR
.PP
The widget flags \fCWNorthWestGravity, WRepaintNoErase\fR and \fCWPaintClever\fR are propagated to the viewport() widget. The other widget flags are propagated to the parent constructor as usual.
.SH "QScrollView::~QScrollView ()"
Destructs the QScrollView. Any children added with addChild() will be destructed.
.SH "void QScrollView::addChild ( QWidget * child, int x=0, int y=0 ) \fC[virtual]\fR"
Inserts \fIchild\fR into the scrolled area positioned at (\fIx, y).\fR The position defaults to (0,0). If the child is already in the view, it is just moved.
.PP
You may want to call enableClipper(TRUE) if you add a large number of widgets.
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "int QScrollView::bottomMargin () const \fC[protected]\fR"
Returns the current bottom margin.
.PP
See also setMargins().
.SH "void QScrollView::center ( int x, int y ) \fC[slot]\fR"
Scrolls the content so that the point (x,y) is in the center of visible area.
.SH "void QScrollView::center ( int x, int y, float xmargin, float ymargin ) \fC[slot]\fR"
Scrolls the content so that the point (x,y) is visible, with the given margins (as fractions of visible area).
.PP
eg.
.TP
Margin 0.0 allows (x,y) to be on edge of visible area.
.TP
Margin 0.5 ensures (x,y) is in middle 50% of visible area.
.TP
Margin 1.0 ensures (x,y) is in the center of the visible area.
.SH "bool QScrollView::childIsVisible ( QWidget * child )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Returns TRUE if \fIchild\fR is visible. This is equivalent to child->isVisible().
.SH "int QScrollView::childX ( QWidget * child )"
Returns the X position of the given child widget. Use this rather than QWidget::x() for widgets added to the view.
.SH "int QScrollView::childY ( QWidget * child )"
Returns the Y position of the given child widget. Use this rather than QWidget::y() for widgets added to the view.
.SH "QWidget* QScrollView::clipper () const"
Returns the clipper widget. Contents in the scrollview is ultimately clipped to be inside the clipper widget.
.PP
You should not need to access this.
.PP
See also visibleWidth() and visibleHeight().
.SH "void QScrollView::contentsDragEnterEvent ( QDragEnterEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dragEnterEvent() - the drag position is translated to be a point on the contents.
.SH "void QScrollView::contentsDragLeaveEvent ( QDragLeaveEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dragLeaveEvent() - the drag position is translated to be a point on the contents.
.SH "void QScrollView::contentsDragMoveEvent ( QDragMoveEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dragMoveEvent() - the drag position is translated to be a point on the contents.
.SH "void QScrollView::contentsDropEvent ( QDropEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a dropEvent() - the drop position is translated to be a point on the contents.
.SH "int QScrollView::contentsHeight () const"
Returns the height of the contents area.
.SH "void QScrollView::contentsMouseDoubleClickEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mouseDoubleClickEvent() - the click position is translated to be a point on the contents.
.PP
Reimplemented in QTable and QListView.
.SH "void QScrollView::contentsMouseMoveEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mouseMoveEvent() - the mouse position is translated to be a point on the contents.
.PP
Reimplemented in QTable and QListView.
.SH "void QScrollView::contentsMousePressEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mousePressEvent() - the press position is translated to be a point on the contents.
.PP
Reimplemented in QTable and QListView.
.SH "void QScrollView::contentsMouseReleaseEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a mouseReleaseEvent() - the release position is translated to be a point on the contents.
.PP
Reimplemented in QTable and QListView.
.SH "void QScrollView::contentsMoving ( int x, int y ) \fC[signal]\fR"
This signal is emitted just before the contents is moved to the given position.
.PP
See also contentsX() and contentsY().
.SH "QPoint QScrollView::contentsToViewport ( const QPoint & p )"
Returns the point \fIp\fR translated to a point on the viewport() widget.
.SH "void QScrollView::contentsToViewport ( int x, int y, int & vx, int & vy )"
Translates a point (\fIx, y)\fR in the contents to a point (\fIvx, vy)\fR on the viewport() widget.
.SH "void QScrollView::contentsWheelEvent ( QWheelEvent * e ) \fC[virtual protected]\fR"
This event handler is called whenever the QScrollView receives a wheelEvent() - the mouse position is translated to be a point on the contents.
.SH "int QScrollView::contentsWidth () const"
Returns the width of the contents area.
.SH "int QScrollView::contentsX () const"
Returns the X coordinate of the contents which is at the left edge of the viewport.
.SH "int QScrollView::contentsY () const"
Returns the Y coordinate of the contents which is at the top edge of the viewport.
.SH "QWidget* QScrollView::cornerWidget () const"
Returns the widget in the corner between the two scrollbars.
.PP
By default, no corner widget is present.
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "bool QScrollView::dragAutoScroll () const"
Returns TRUE if autoscrolling in drag move events is enabled, else FALSE.
.PP
See also setDragAutoScroll().
.SH "void QScrollView::drawContents ( QPainter * p, int clipx, int clipy, int clipw, int cliph ) \fC[virtual protected]\fR"
Reimplement this method if you are viewing a drawing area rather than a widget.
.PP
The function should draw the rectangle (\fIclipx, clipy, clipw, cliph\fR ) of the contents, using painter \fIp.\fR The clip rectangle is in the scroll views's coordinates.
.PP
For example:
.PP
.nf
.br
  {
.br
    // Fill a 40000 by 50000 rectangle at (100000,150000)
.br
.br
    // Calculate the coordinates...
.br
    int x1 = 100000, y1 = 150000;
.br
    int x2 = x1+40000-1, y2 = y1+50000-1;
.br
.br
    // Clip the coordinates so X/Windows will not have problems...
.br
    if (x1 < clipx) x1=clipx;
.br
    if (y1 < clipy) y1=clipy;
.br
    if (x2 > clipx+clipw-1) x2=clipx+clipw-1;
.br
    if (y2 > clipy+cliph-1) y2=clipy+cliph-1;
.br
.br
    // Paint using the small coordinates...
.br
    if ( x2 >= x1 && y2 >= y1 )
.br
        p->fillRect(x1, y1, x2-x1+1, y2-y1+1, red);
.br
  }
.fi
.PP
The clip rectangle and translation of the painter \fIp\fR is already set appropriately.
.PP
Reimplemented in QCanvasView and QTable.
.SH "void QScrollView::drawContentsOffset ( QPainter * p, int offsetx, int offsety, int clipx, int clipy, int clipw, int cliph ) \fC[virtual protected]\fR"
For backward compatibility only. It is easier to use drawContents(QPainter*,int,int,int,int).
.PP
The default implementation translates the painter appropriately and calls drawContents(QPainter*,int,int,int,int).
.PP
Reimplemented in QListView and QTextView.
.SH "void QScrollView::enableClipper ( bool y )"
When large numbers of child widgets are in a scrollview, especially if they are close together, the scrolling performance can suffer greatly. If you call enableClipper(TRUE), the scrollview will use an extra widget to group child widgets.
.PP
Note that you may only call enableClipper() prior to adding widgets.
.PP
For a full discussion, see the overview documentation of this class.
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "void QScrollView::ensureVisible ( int x, int y ) \fC[slot]\fR"
Scrolls the content so that the point (x, y) is visible with at least 50-pixel margins (if possible, otherwise centered).
.SH "void QScrollView::ensureVisible ( int x, int y, int xmargin, int ymargin ) \fC[slot]\fR"
Scrolls the content so that the point (x, y) is visible with at least the given pixel margins (if possible, otherwise centered).
.SH "bool QScrollView::eventFilter ( QObject * obj, QEvent * e ) \fC[virtual protected]\fR"
This event filter ensures the scrollbars are updated when a single contents widget is resized, shown, hidden, or destroyed, and passes mouse events to the QScrollView.
.PP
Reimplemented from QObject.
.SH "bool QScrollView::focusNextPrevChild ( bool next ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QScrollView::frameChanged () \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QFrame.
.SH "QScrollView::ScrollBarMode QScrollView::hScrollBarMode() const"
Returns the currently set mode for the horizontal scrollbar.
.PP
See also setHScrollBarMode().
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "bool QScrollView::hasStaticBackground () const"
Returns wether QScrollView uses a static background.
.PP
See also setStaticBackground().
.SH "QScrollBar* QScrollView::horizontalScrollBar () const"
Returns the component horizontal scrollbar. It is made available to allow accelerators, autoscrolling, etc., and to allow changing of arrow scroll rates: bar->setSteps( rate, bar->pageStep() ).
.PP
It should not be otherwise manipulated.
.PP
This function never returns 0.
.SH "int QScrollView::leftMargin () const \fC[protected]\fR"
Returns the current left margin.
.PP
See also setMargins().
.SH "QSize QScrollView::minimumSizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QScrollView::moveChild ( QWidget * child, int x, int y ) \fC[virtual]\fR"
Repositions \fIchild\fR to (\fIx, y).\fR This functions the same as addChild().
.SH "void QScrollView::removeChild ( QObject * child ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QObject.
.SH "void QScrollView::removeChild ( QWidget * child )"
Removes a child from the scrolled area. Note that this happens automatically if the child is deleted.
.SH "void QScrollView::repaintContents ( int x, int y, int w, int h, bool erase=TRUE )"
Calls repaint() on rectangle defined by \fIx, y, w, h,\fR translated appropriately. If the rectangle in not visible, nothing is repainted.
.PP
See also updateContents().
.SH "void QScrollView::repaintContents ( const QRect & r, bool erase=TRUE )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QScrollView::resize ( const QSize & s )"
Reimplemented for internal reasons; the API is not affected.
.PP
Examples:
.(l
iconview/main.cpp dirview/main.cpp
.)l
.SH "void QScrollView::resize ( int w, int h )"
Reimplemented for internal reasons; the API is not affected.
.SH "void QScrollView::resizeContents ( int w, int h ) \fC[virtual slot]\fR"
Set the size of the contents area to \fIw\fR pixels wide and \fIh\fR pixels high, and updates the viewport accordingly.
.SH "void QScrollView::resizeEvent ( QResizeEvent * event ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QScrollView::ResizePolicy QScrollView::resizePolicy() const"
Returns the currently set ResizePolicy.
.PP
See also setResizePolicy() and ResizePolicy.
.SH "int QScrollView::rightMargin () const \fC[protected]\fR"
Returns the current right margin.
.PP
See also setMargins().
.SH "void QScrollView::scrollBy ( int dx, int dy ) \fC[slot]\fR"
Scrolls the content by \fIx\fR to the left and \fIy\fR upwards.
.SH "void QScrollView::setContentsPos ( int x, int y ) \fC[virtual slot]\fR"
Scrolls the content so that the point (x, y) is in the top-left corner.
.PP
Reimplemented in QListView.
.SH "void QScrollView::setCornerWidget ( QWidget * corner ) \fC[virtual]\fR"
Sets the widget in the corner between the two scrollbars.
.PP
You will probably also want to set at least one of the scrollbar modes to AlwaysOn.
.PP
Passing 0 shows no widget in the corner.
.PP
Any previous corner widget is hidden.
.PP
You may call setCornerWidget() with the same widget at different times.
.PP
All widgets set here will be deleted by the QScrollView when it destructs unless you separately reparent the widget after setting some other corner widget (or 0).
.PP
Any \fInewly\fR set widget should have no current parent.
.PP
By default, no corner widget is present.
.PP
See also setVScrollBarMode() and setHScrollBarMode().
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "void QScrollView::setDragAutoScroll ( bool b )"
If \fIb\fR is set to TRUE, the QScrollView automatically scrolls the contents in drag move events if the user moves the cursor close to a border of the view. This of course only works id the viewport accepts drops! Specifying FALSE here disables this autoscroll feature.
.SH "void QScrollView::setEnabled ( bool enable ) \fC[virtual slot]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QScrollView::setHBarGeometry ( QScrollBar & hbar, int x, int y, int w, int h ) \fC[virtual protected]\fR"
Called when the horizontal scrollbar geometry changes. This is provided as a protected function so that subclasses can do interesting things like providing extra buttons in some of the space normally used by the scrollbars.
.PP
The default implementation simply gives all the space to \fIhbar.\fR
.PP
See also setVBarGeometry().
.SH "void QScrollView::setHScrollBarMode ( ScrollBarMode mode )"
Sets the mode for the horizontal scrollbar.
.TP
\fCAuto\fR (the default) shows a scrollbar when the content is too wide to fit.
.TP
\fCAlwaysOff\fR never shows a scrollbar.
.TP
\fCAlwaysOn\fR always shows a scrollbar.
.PP
See also hScrollBarMode() and setVScrollBarMode().
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "void QScrollView::setMargins ( int left, int top, int right, int bottom ) \fC[virtual protected]\fR"
Sets the margins around the scrolling area. This is useful for applications such as spreadsheets with `locked' rows and columns. The marginal space is \fIinside\fR the frameRect() and is left blank - reimplement drawContents() or put widgets in the unused area.
.PP
By default all margins are zero.
.PP
See also frameChanged().
.SH "void QScrollView::setResizePolicy ( ResizePolicy r )"
Sets the resize policy to \fIr.\fR
.PP
See also resizePolicy() and ResizePolicy.
.SH "void QScrollView::setStaticBackground ( bool y )"
Sets the scrollview to have a static background if \fIy\fR is TRUE, or a scrolling background otherwise. By default, the background is scrolling.
.PP
Beware that this mode is quite slow, as a full repaint of the visible area has to be triggered on every contents move.
.PP
See also hasStaticBackground().
.SH "void QScrollView::setVBarGeometry ( QScrollBar & vbar, int x, int y, int w, int h ) \fC[virtual protected]\fR"
Called when the vertical scrollbar geometry changes. This is provided as a protected function so that subclasses can do interesting things like providing extra buttons in some of the space normally used by the scrollbars.
.PP
The default implementation simply gives all the space to \fIvbar.\fR
.PP
See also setHBarGeometry().
.SH "void QScrollView::setVScrollBarMode ( ScrollBarMode mode )"
Sets the mode for the vertical scrollbar.
.PP
See also vScrollBarMode() and setHScrollBarMode().
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "void QScrollView::show () \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Examples:
.(l
iconview/main.cpp
.)l
.PP
Reimplemented from QWidget.
.SH "void QScrollView::showChild ( QWidget * child, bool y=TRUE )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Sets the visibility of \fIchild.\fR Equivalent to QWidget::show() or QWidget::hide().
.SH "QSize QScrollView::sizeHint () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "QSizePolicy QScrollView::sizePolicy () const \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "void QScrollView::styleChange ( QStyle & old ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "int QScrollView::topMargin () const \fC[protected]\fR"
Returns the current top margin.
.PP
See also setMargins().
.SH "void QScrollView::updateContents ( int x, int y, int w, int h )"
Calls update() on rectangle defined by \fIx, y, w, h,\fR translated appropriately. If the rectangle in not visible, nothing is repainted.
.PP
See also repaintContents().
.SH "void QScrollView::updateContents ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QScrollView::updateScrollBars () \fC[slot]\fR"
Updates scrollbars - all possibilities considered. You should never need to call this in your code.
.SH "QScrollView::ScrollBarMode QScrollView::vScrollBarMode() const"
Returns the currently set mode for the vertical scrollbar.
.PP
See also setVScrollBarMode().
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "QScrollBar* QScrollView::verticalScrollBar () const"
Returns the component vertical scrollbar. It is made available to allow accelerators, autoscrolling, etc., and to allow changing of arrow scroll rates: bar->setSteps( rate, bar->pageStep() ).
.PP
It should not be otherwise manipulated.
.PP
This function never returns 0.
.SH "QWidget* QScrollView::viewport () const"
Returns the viewport widget of the scrollview. This is the widget containing the contents widget or which is the drawing area.
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "void QScrollView::viewportDragEnterEvent ( QDragEnterEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all drag enter events sent to the viewport.
.PP
The default implementation translates the event and calls contentsDragEnterEvent().
.PP
See also QWidget::dragEnterEvent().
.SH "void QScrollView::viewportDragLeaveEvent ( QDragLeaveEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all drag leave events sent to the viewport.
.PP
The default implementation calls contentsDragLeaveEvent().
.PP
See also QWidget::dragLeaveEvent().
.SH "void QScrollView::viewportDragMoveEvent ( QDragMoveEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all drag move events sent to the viewport.
.PP
The default implementation translates the event and calls contentsDragMoveEvent().
.PP
See also QWidget::dragMoveEvent().
.SH "void QScrollView::viewportDropEvent ( QDropEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all drop events sent to the viewport.
.PP
The default implementation translates the event and calls contentsDropEvent().
.PP
See also QWidget::dropEvent().
.SH "void QScrollView::viewportMouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all mouse double click events sent to the viewport.
.PP
The default implementation translates the event and calls contentsMouseDoubleClickEvent().
.PP
See also QWidget::mouseDoubleClickEvent().
.PP
Reimplemented in QListBox.
.SH "void QScrollView::viewportMouseMoveEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all mouse move events sent to the viewport.
.PP
The default implementation translates the event and calls contentsMouseMoveEvent().
.PP
See also QWidget::mouseMoveEvent().
.PP
Reimplemented in QTextBrowser, QTextView and QListBox.
.SH "void QScrollView::viewportMousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all mouse press events sent to the viewport.
.PP
The default implementation translates the event and calls contentsMousePressEvent().
.PP
See also contentsMousePressEvent() and QWidget::mousePressEvent().
.PP
Reimplemented in QListBox, QTextView and QTextBrowser.
.SH "void QScrollView::viewportMouseReleaseEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all mouse release events sent to the viewport.
.PP
The default implementation translates the event and calls contentsMouseReleaseEvent().
.PP
See also QWidget::mouseReleaseEvent().
.PP
Reimplemented in QTextBrowser, QListBox and QTextView.
.SH "void QScrollView::viewportPaintEvent ( QPaintEvent * pe ) \fC[virtual protected]\fR"
This is a low-level painting routine that draws the viewport contents. Reimplement this if drawContents() is too high-level. (for example, if you don't want to open a QPainter on the viewport).
.PP
Reimplemented in QListBox.
.SH "void QScrollView::viewportResizeEvent ( QResizeEvent * ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all resize events sent to the viewport.
.PP
See also QWidget::resizeEvent().
.PP
Reimplemented in QTextView.
.SH "QSize QScrollView::viewportSize ( int x, int y ) const"
Returns the viewport size for size (\fIx, y).\fR
.PP
The viewport size depends on \fIx,y\fR (the size of the contents), the size of this widget, the modes of the horizontal and vertical scroll bars.
.PP
This function permits widgets that can trade vertical and horizontal space for each other to control scroll bar appearance better. For example, a word processor or web browser can control the width of the right margin accurately, whether there needs to be a vertical scroll bar or not.
.SH "QPoint QScrollView::viewportToContents ( const QPoint & vp )"
Returns the point on the viewport \fIvp\fR translated to a point in the contents.
.SH "void QScrollView::viewportToContents ( int vx, int vy, int & x, int & y )"
Translates a point (\fIvx, vy)\fR on the viewport() widget to a point (\fIx, y)\fR in the contents.
.SH "void QScrollView::viewportWheelEvent ( QWheelEvent * e ) \fC[virtual protected]\fR"
To provide simple processing of events on the contents, this method receives all wheel events sent to the viewport.
.PP
The default implementation translates the event and calls contentsWheelEvent().
.PP
See also QWidget::wheelEvent().
.SH "int QScrollView::visibleHeight () const"
Returns the vertical amount of the content that is visible.
.SH "int QScrollView::visibleWidth () const"
Returns the horizontal amount of the content that is visible.
.SH "void QScrollView::wheelEvent ( QWheelEvent * e ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qscrollview.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qscrollview.3qt) and the Qt
version (2.3.2).
