'\" t
.TH QTableView 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QTableView \- This is an abstract base class for implementing tables
.br
.PP
\fC#include <qtableview.h>\fR
.PP
Inherits QFrame.
.PP
Inherited by QMultiLineEdit.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "virtual void \fBsetBackgroundColor\fR ( const QColor & ) (internal)"
.br
.ti -1c
.BI "void \fBrepaint\fR ( bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "void \fBrepaint\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "void \fBrepaint\fR ( const QRect &, bool " "erase" "=TRUE ) "
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "\fBQTableView\fR ( QWidget * " "parent" "=0, const char * " "name" "=0, WFlags " "f" "=0 ) "
.br
.ti -1c
.BI "\fB~QTableView\fR () "
.br
.ti -1c
.BI "int \fBnumRows\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetNumRows\fR ( int ) "
.br
.ti -1c
.BI "int \fBnumCols\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetNumCols\fR ( int ) "
.br
.ti -1c
.BI "int \fBtopCell\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetTopCell\fR ( int row ) "
.br
.ti -1c
.BI "int \fBleftCell\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetLeftCell\fR ( int col ) "
.br
.ti -1c
.BI "virtual void \fBsetTopLeftCell\fR ( int " "row" ", int col ) "
.br
.ti -1c
.BI "int \fBxOffset\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetXOffset\fR ( int ) "
.br
.ti -1c
.BI "int \fByOffset\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetYOffset\fR ( int ) "
.br
.ti -1c
.BI "virtual void \fBsetOffset\fR ( int " "x" ", int " "y" ", bool " "updateScrBars" " = TRUE ) "
.br
.ti -1c
.BI "virtual int \fBcellWidth\fR ( int col ) "
.br
.ti -1c
.BI "virtual int \fBcellHeight\fR ( int row ) "
.br
.ti -1c
.BI "int \fBcellWidth\fR () const"
.br
.ti -1c
.BI "int \fBcellHeight\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCellWidth\fR ( int ) "
.br
.ti -1c
.BI "virtual void \fBsetCellHeight\fR ( int ) "
.br
.ti -1c
.BI "virtual int \fBtotalWidth\fR () "
.br
.ti -1c
.BI "virtual int \fBtotalHeight\fR () "
.br
.ti -1c
.BI "uint \fBtableFlags\fR () const"
.br
.ti -1c
.BI "bool \fBtestTableFlags\fR ( uint f ) const"
.br
.ti -1c
.BI "virtual void \fBsetTableFlags\fR ( uint f ) "
.br
.ti -1c
.BI "void \fBclearTableFlags\fR ( uint f = ~0 ) "
.br
.ti -1c
.BI "bool \fBautoUpdate\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetAutoUpdate\fR ( bool ) "
.br
.ti -1c
.BI "void \fBupdateCell\fR ( int " "row" ", int " "column" ", bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "QRect \fBcellUpdateRect\fR () const"
.br
.ti -1c
.BI "QRect \fBviewRect\fR () const"
.br
.ti -1c
.BI "int \fBlastRowVisible\fR () const"
.br
.ti -1c
.BI "int \fBlastColVisible\fR () const"
.br
.ti -1c
.BI "bool \fBrowIsVisible\fR ( int row ) const"
.br
.ti -1c
.BI "bool \fBcolIsVisible\fR ( int col ) const"
.br
.ti -1c
.BI "QScrollBar* \fBverticalScrollBar\fR () const"
.br
.ti -1c
.BI "QScrollBar* \fBhorizontalScrollBar\fR () const"
.br
.ti -1c
.BI "virtual void \fBpaintCell\fR ( QPainter *, int " "row" ", int col ) "
.br
.ti -1c
.BI "virtual void \fBsetupPainter\fR ( QPainter * ) "
.br
.ti -1c
.BI "virtual void \fBpaintEvent\fR ( QPaintEvent * ) "
.br
.ti -1c
.BI "int \fBfindRow\fR ( int yPos ) const"
.br
.ti -1c
.BI "int \fBfindCol\fR ( int xPos ) const"
.br
.ti -1c
.BI "bool \fBrowYPos\fR ( int " "row" ", int * yPos ) const"
.br
.ti -1c
.BI "bool \fBcolXPos\fR ( int " "col" ", int * xPos ) const"
.br
.ti -1c
.BI "int \fBmaxXOffset\fR () "
.br
.ti -1c
.BI "int \fBmaxYOffset\fR () "
.br
.ti -1c
.BI "int \fBmaxColOffset\fR () "
.br
.ti -1c
.BI "int \fBmaxRowOffset\fR () "
.br
.ti -1c
.BI "int \fBminViewX\fR () const"
.br
.ti -1c
.BI "int \fBminViewY\fR () const"
.br
.ti -1c
.BI "int \fBmaxViewX\fR () const"
.br
.ti -1c
.BI "int \fBmaxViewY\fR () const"
.br
.ti -1c
.BI "int \fBviewWidth\fR () const"
.br
.ti -1c
.BI "int \fBviewHeight\fR () const"
.br
.ti -1c
.BI "void \fBscroll\fR ( int " "xPixels" ", int yPixels ) "
.br
.ti -1c
.BI "void \fBupdateScrollBars\fR () "
.br
.ti -1c
.BI "void \fBupdateTableSize\fR () "
.br
.in -1c
.SH DESCRIPTION
This is an abstract base class for implementing tables
.PP
A table view consists of a number of abstract cells organized in rows and columns and a visible part called a view. The cells are identified with a row index and a column index. The top left cell is in row 0, column 0.
.PP
The behavior of the widget can be finely tuned using setTableFlags(); a typical subclass will consist of little more than a call to setTableFlags(), some table content manipulation, and an implementation of paintCell(). Subclasses that need cells with variable width or height must reimplement cellHeight() and/or cellWidth(). Use updateTableSize() to tell QTableView when the width or height has changed.
.PP
When you read this documentation, it is important to understand the distinctions between the four pixel coordinate systems involved.
.IP 1
The \fIcell\fR coordinates. (0,0) is the top left corner of a cell. This is used by functions such as paintCell().
.IP 2
The \fItable\fR coordinates. (0,0) is the top left corner of the cell at row 0 and column 0. These coordinates are absolute; that is, they are independent of what part of the table is visible at the moment. This is used by functions such as setXOffset() or maxYOffset().
.IP 3
The \fIwidget\fR coordinates. (0,0) is the top left corner of the widget, \fIincluding\fR the frame. This is used by functions such as repaint().
.IP 4
The \fIview\fR coordinates. (0,0) is the top left corner of the view, \fIexcluding\fR the frame. This is the least-used coordinate system, used by functions such as viewWidth(). 
.PP
It is rather unfortunate that we have to use four different coordinate systems, but if we were to provide a flexible and powerful base class, there wasn't any way around it.
.PP
Note: The row,column indices are always given in that order, i.e. first the vertical (row), then the horizontal (column). This is the opposite order of all pixel operations, which take first the horizontal (x), then the vertical (y).
.PP
.ce 1
.B "[Image Omitted]"
.PP

.ce 1
.B "[Image Omitted]"
.PP
\fBWarning:\fR the functions setNumRows(), setNumCols(), setCellHeight(), setCellWidth(), setTableFlags() and clearTableFlags() may cause virtual functions like cellWidth() and cellHeight() to be called, even if autoUpdate() is FALSE. This may cause errors if relevant state variables are not initialized.
.PP
\fBWarning:\fR Experience has shown that use of this widget tends to bring more bugs than expected, and our analysis indicates that widget's very flexibility is the problem. If QScrollView or QListBox can easily be made to do the job you need, we recommend subclassing those widgets rather than QTableView. In addition, QScrollView makes it easy to have child widgets inside tables, something QTableView doesn't support at all.
.PP
See also QScrollView and GUI Design Handbook: Table
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QTableView::QTableView ( QWidget * parent=0, const char * name=0, WFlags f=0 ) \fC[protected]\fR"
Constructs a table view. All the arguments are passed to the QFrame constructor.
.PP
The table flags are all cleared (set to zero). Set \fCTbl_autoVScrollBar\fR or \fCTbl_autoHScrollBar\fR to get automatic scroll bars and \fCTbl_clipCellPainting\fR to get safe clipping.
.PP
The cell height and cell width are set to 0.
.PP
Frame line shapes (QFrame::HLink and QFrame::VLine) are disallowed, see QFrame::setFrameStyle().
.PP
Note that the \fIf\fR argument is \fInot\fR table flags but rather widget flags.
.SH "QTableView::~QTableView () \fC[protected]\fR"
Destructs the table view.
.SH "bool QTableView::autoUpdate () const \fC[protected]\fR"
Returns TRUE if the view updates itself automatically whenever it is changed in some way.
.PP
See also setAutoUpdate().
.SH "int QTableView::cellHeight () const \fC[protected]\fR"
Returns the row height, in pixels. Returns 0 if the rows have variable heights.
.PP
See also setCellHeight() and cellWidth().
.SH "int QTableView::cellHeight ( int ) \fC[virtual protected]\fR"
Returns the height of row \fIrow,\fR in pixels.
.PP
This function is virtual and must be reimplemented by subclasses that have variable cell heights. Note that if the total table height changes, updateTableSize() must be called.
.PP
See also setCellHeight(), cellWidth() and totalHeight().
.SH "QRect QTableView::cellUpdateRect () const \fC[protected]\fR"
This function should only be called from the paintCell() function in subclasses. It returns the portion of a cell that actually needs to be updated, in \fIcell\fR coordinates. This is only useful for non-trivial paintCell().
.SH "int QTableView::cellWidth () const \fC[protected]\fR"
Returns the column width, in pixels. Returns 0 if the columns have variable widths.
.PP
See also setCellWidth() and cellHeight().
.SH "int QTableView::cellWidth ( int ) \fC[virtual protected]\fR"
Returns the width of column \fIcol,\fR in pixels.
.PP
This function is virtual and must be reimplemented by subclasses that have variable cell widths. Note that if the total table width changes, updateTableSize() must be called.
.PP
See also setCellWidth(), cellHeight(), totalWidth() and updateTableSize().
.SH "void QTableView::clearTableFlags ( uint f = ~0 ) \fC[protected]\fR"
Clears the table flags that are set in \fIf.\fR
.PP
Example (clears a single flag):
.PP
.nf
.br
    clearTableFlags( Tbl_snapToGrid );
.fi
.PP
The default argument clears all flags.
.PP
See also setTableFlags(), testTableFlags() and tableFlags().
.SH "bool QTableView::colIsVisible ( int col ) const \fC[protected]\fR"
Returns TRUE if \fIcol\fR is at least partially visible.
.PP
See also rowIsVisible().
.SH "bool QTableView::colXPos ( int col, int * xPos ) const \fC[protected]\fR"
Computes the position in the widget of column \fIcolumn.\fR
.PP
Returns TRUE and stores the result in \fI*xPos\fR (in \fIwidget\fR coordinates) if the column is visible. Returns FALSE and does not modify \fI*xPos\fR if \fIcol\fR is invisible or invalid.
.PP
See also rowYPos() and findCol().
.SH "int QTableView::findCol ( int xPos ) const \fC[protected]\fR"
Returns the index of the column at position \fIxPos,\fR where \fIxPos\fR is in \fIwidget\fR coordinates. Returns -1 if \fIxPos\fR is outside the valid range.
.PP
See also findRow() and colXPos().
.SH "int QTableView::findRow ( int yPos ) const \fC[protected]\fR"
Returns the index of the row at position \fIyPos,\fR where \fIyPos\fR is in \fIwidget\fR coordinates. Returns -1 if \fIyPos\fR is outside the valid range.
.PP
See also findCol() and rowYPos().
.SH "QScrollBar * QTableView::horizontalScrollBar () const \fC[protected]\fR"
Returns a pointer to the horizontal scroll bar, mainly so you can connect() to its signals. Note that the scroll bar works in pixel values, use findCol() to translate to cell numbers.
.SH "int QTableView::lastColVisible () const \fC[protected]\fR"
Returns the index of the last (right) column in the view. The index of the first column is 0.
.PP
If no columns are visible it returns -1. This can happen if the view is too narrow for the first column and Tbl_cutCellsH is set.
.PP
See also lastRowVisible().
.SH "int QTableView::lastRowVisible () const \fC[protected]\fR"
Returns the index of the last (bottom) row in the view. The index of the first row is 0.
.PP
If no rows are visible it returns -1. This can happen if the view is too small for the first row and Tbl_cutCellsV is set.
.PP
See also lastColVisible().
.SH "int QTableView::leftCell () const \fC[protected]\fR"
Returns the index of the first column in the table that is visible in the view. The index of the very leftmost column is 0.
.PP
See also topCell() and setLeftCell().
.SH "int QTableView::maxColOffset () \fC[protected]\fR"
Returns the index of the last column which may be at the left edge of the view.
.PP
Depending on the Tbl_scrollLastHCell flag, this may or may not be the last column.
.PP
See also maxXOffset() and maxRowOffset().
.SH "int QTableView::maxRowOffset () \fC[protected]\fR"
Returns the index of the last row which may be at the top edge of the view.
.PP
Depending on the Tbl_scrollLastVCell flag, this may or may not be the last row.
.PP
See also maxYOffset() and maxColOffset().
.SH "int QTableView::maxViewX () const \fC[protected]\fR"
Returns the rightmost pixel of the table view in \fIview\fR coordinates. This excludes the frame and any scroll bar, but includes blank pixels to the right of the visible table data.
.PP
See also maxViewY(), viewWidth() and contentsRect().
.SH "int QTableView::maxViewY () const \fC[protected]\fR"
Returns the bottom pixel of the table view in \fIview\fR coordinates. This excludes the frame and any scroll bar, but includes blank pixels below the visible table data.
.PP
See also maxViewX(), viewHeight() and contentsRect().
.SH "int QTableView::maxXOffset () \fC[protected]\fR"
Returns the maximum horizontal offset within the table of the view's left edge, in \fItable\fR coordinates.
.PP
This is used mainly to set the horizontal scroll bar's range.
.PP
See also maxColOffset(), maxYOffset() and totalWidth().
.SH "int QTableView::maxYOffset () \fC[protected]\fR"
Returns the maximum vertical offset within the table of the view's top edge, in \fItable\fR coordinates.
.PP
This is used mainly to set the vertical scroll bar's range.
.PP
See also maxRowOffset(), maxXOffset() and totalHeight().
.SH "int QTableView::minViewX () const \fC[protected]\fR"
Returns the leftmost pixel of the table view in \fIview\fR coordinates. This excludes the frame and any header.
.PP
See also maxViewY(), viewWidth() and contentsRect().
.SH "int QTableView::minViewY () const \fC[protected]\fR"
Returns the top pixel of the table view in \fIview\fR coordinates. This excludes the frame and any header.
.PP
See also maxViewX(), viewHeight() and contentsRect().
.SH "int QTableView::numCols () const \fC[protected]\fR"
Returns the number of columns in the table
.PP
See also numRows() and setNumCols().
.SH "int QTableView::numRows () const \fC[protected]\fR"
Returns the number of rows in the table.
.PP
See also numCols() and setNumRows().
.SH "void QTableView::paintCell ( QPainter * p, int row, int col ) \fC[virtual protected]\fR"
This pure virtual function is called to paint the single cell at \fI(row,col)\fR using \fIp,\fR which is open when paintCell() is called and must remain open.
.PP
The coordinate system is translated such that the origin is at the top left corner of the cell to be painted; i.e. \fIcell\fR coordinates. Do not scale or shear the coordinate system (or if you do, restore the transformation matrix before you return).
.PP
By default, the painter is not clipped, for maximum efficiency. For safety, call setTableFlags(Tbl_clipCellPainting) to enable clipping.
.PP
See also paintEvent(), QPainter() and setTableFlags().
.PP
Reimplemented in QMultiLineEdit.
.SH "void QTableView::paintEvent ( QPaintEvent * e ) \fC[virtual protected]\fR"
Handles paint events for the table view.
.PP
Calls paintCell() for the cells that needs to be repainted.
.PP
Reimplemented from QWidget.
.SH "void QTableView::repaint ( int x, int y, int w, int h, bool erase=TRUE )"
Repaints the table view directly by calling paintEvent() directly, unless updates are disabled.
.PP
Erases the view area \fI(x,y,w,h)\fR if \fIerase\fR is TRUE. Parameters \fI(x,y)\fR are in \fIwidget\fR coordinates.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR. If \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
Doing a repaint() usually is faster than doing an update(), but calling update() many times in a row will generate a single paint event.
.PP
At present, QTableView is the only widget that reimplements repaint(). It does this because by clearing and then repainting one cell at at time, it can make the screen flicker less than it would otherwise.
.SH "void QTableView::repaint ( bool erase=TRUE )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Repaints the entire view.
.SH "void QTableView::repaint ( const QRect & r, bool erase=TRUE )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QTableView::resizeEvent ( QResizeEvent * ) \fC[virtual protected]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "bool QTableView::rowIsVisible ( int row ) const \fC[protected]\fR"
Returns TRUE if \fIrow\fR is at least partially visible.
.PP
See also colIsVisible().
.SH "bool QTableView::rowYPos ( int row, int * yPos ) const \fC[protected]\fR"
Computes the position in the widget of row \fIrow.\fR
.PP
Returns TRUE and stores the result in \fI*yPos\fR (in \fIwidget\fR coordinates) if the row is visible. Returns FALSE and does not modify \fI*yPos\fR if \fIrow\fR is invisible or invalid.
.PP
See also colXPos() and findRow().
.SH "void QTableView::scroll ( int xPixels, int yPixels ) \fC[protected]\fR"
Moves the visible area of the table rightwards by \fIxPixels\fR and downwards by \fIyPixels\fR pixels. Both may be negative.
.PP
\fBWarning:\fR You might find that QScrollView offers a higher-level of functionality than using QTableView and this function.
.PP
This function is \fInot\fR the same as QWidget::scroll(), in particular, the signs of \fIxPixels\fR and \fIyPixels\fR have the reverse semantics.
.PP
See also setXOffset(), setYOffset(), setOffset(), setTopCell(), setLeftCell() and setTopLeftOffset().
.SH "void QTableView::setAutoUpdate ( bool enable ) \fC[virtual protected]\fR"
Sets the auto-update option of the table view to \fIenable.\fR
.PP
If \fIenable\fR is TRUE (this is the default) then the view updates itself automatically whenever it has changed in some way (for example when a flag is changed).
.PP
If \fIenable\fR is FALSE, the view does NOT repaint itself, or update its internal state variables itself when it is changed. This can be useful to avoid flicker during large changes, and is singularly useless otherwise: Disable auto-update, do the changes, re-enable auto-update, and call repaint().
.PP
\fBWarning:\fR Do not leave the view in this state for a long time (i.e. between events ). If, for example, the user interacts with the view when auto-update is off, strange things can happen.
.PP
Setting auto-update to TRUE does not repaint the view, you must call repaint() to do this.
.PP
See also autoUpdate() and repaint().
.SH "void QTableView::setCellHeight ( int cellHeight ) \fC[virtual protected]\fR"
Sets the height in pixels of the table cells to \fIcellHeight.\fR
.PP
Setting it to zero means that the row height is variable. When set to 0 (this is the default) QTableView calls the virtual function cellHeight() to get the height.
.PP
See also cellHeight(), setCellWidth(), totalHeight() and numRows().
.SH "void QTableView::setCellWidth ( int cellWidth ) \fC[virtual protected]\fR"
Sets the width in pixels of the table cells to \fIcellWidth.\fR
.PP
Setting it to zero means that the column width is variable. When set to 0 (this is the default) QTableView calls the virtual function cellWidth() to get the width.
.PP
See also cellWidth(), setCellHeight(), totalWidth() and numCols().
.SH "void QTableView::setLeftCell ( int col ) \fC[virtual protected]\fR"
Scrolls the table such that \fIcol\fR becomes the leftmost column. The index of the very leftmost column is 0.
.PP
See also setXOffset(), setTopLeftCell() and setTopCell().
.SH "void QTableView::setNumCols ( int cols ) \fC[virtual protected]\fR"
Sets the number of columns of the table to \fIcols\fR (must be non-negative). Does not change leftCell().
.PP
The table repaints itself automatically if autoUpdate() is set.
.PP
See also numCols(), numRows() and setNumRows().
.SH "void QTableView::setNumRows ( int rows ) \fC[virtual protected]\fR"
Sets the number of rows of the table to \fIrows\fR (must be non-negative). Does not change topCell().
.PP
The table repaints itself automatically if autoUpdate() is set.
.PP
See also numCols(), setNumCols() and numRows().
.SH "void QTableView::setOffset ( int x, int y, bool updateScrBars = TRUE ) \fC[virtual protected]\fR"
Scrolls the table such that \fI(x,y)\fR becomes the top left pixel in the view. Parameters \fI(x,y)\fR are in \fItable\fR coordinates.
.PP
The interaction with Tbl_snapTo*Grid is tricky. If \fIupdateScrBars\fR is TRUE, the scroll bars are updated.
.PP
See also xOffset(), yOffset(), setXOffset(), setYOffset() and setTopLeftCell().
.SH "void QTableView::setPalette ( const QPalette & p ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.SH "void QTableView::setTableFlags ( uint f ) \fC[virtual protected]\fR"
Sets the table flags to \fIf.\fR
.PP
If a flag setting changes the appearance of the table the table is repainted if and only if autoUpdate() is TRUE.
.PP
The table flags are mostly single bits, though there are some multibit flags for convenience. Here is a complete list:
.IP "Tbl_vScrollBar" 1c
The table has a vertical scroll bar.
.IP "Tbl_hScrollBar" 1c
The table has a horizontal scroll bar.
.IP "Tbl_autoVScrollBar" 1c
The table has a vertical scroll bar if and only if the table is taller than the view.
.IP "Tbl_autoHScrollBar" 1c
The table has a horizontal scroll bar if and only if the table is wider than the view.
.IP "Tbl_autoScrollBars" 1c
The union of the previous two flags.
.IP "Tbl_clipCellPainting" 1c
The table uses QPainter::setClipRect() to make sure that paintCell() will not draw outside the cell boundaries.
.IP "Tbl_cutCellsV" 1c
The table will never show part of a cell at the bottom of the table; if there is not space for all of a cell the space is left blank.
.IP "Tbl_cutCellsH" 1c
The table will never show part of a cell at the right side of the table; if there is not space for all of a cell the space is left blank.
.IP "Tbl_cutCells" 1c
The union of the previous two flags.
.IP "Tbl_scrollLastHCell" 1c
When the user scrolls horizontally, let him/her scroll the last cell leftward until it is at the left edge of the view. If this flag is not set, the user can only scroll to the point where last cell is completely visible.
.IP "Tbl_scrollLastVCell" 1c
When the user scrolls vertically, let him/her scroll the last cell upward until it is at the top edge of the view. If this flag is not set, the user can only scroll to the point where last cell is completely visible.
.IP "Tbl_scrollLastCell" 1c
The union of the previous two flags.
.IP "Tbl_smoothHScrolling" 1c
The table scrolls as smoothly as possible when the user scrolls horizontally. When this flag is not set scrolling is done one cell at a time.
.IP "Tbl_smoothVScrolling" 1c
The table scrolls as smoothly as possible when scrolling vertically. When this flag is not set scrolling is done one cell at a time.
.IP "Tbl_smoothScrolling" 1c
The union of of previous two flags.
.IP "Tbl_snapToHGrid" 1c
Except when the user is actually scrolling, the leftmost column shown snaps to the leftmost edge of the view.
.IP "Tbl_snapToVGrid" 1c
Except when the user is actually scrolling, the top row snaps to the top edge of the view.
.IP "Tbl_snapToGrid" 1c
The union of the previous two flags.
.PP
You can specify more than one flag at a time using bitwise OR.
.PP
Example:
.PP
.nf
.br
    setTableFlags( Tbl_smoothScrolling | Tbl_autoScrollBars );
.fi
.PP
\fBWarning:\fR The cutCells options (\fCTbl_cutCells, Tbl_cutCellsH\fR and Tbl_cutCellsV) may cause painting problems when scrollbars are enabled. Do not combine cutCells and scrollbars.
.PP
See also clearTableFlags(), testTableFlags() and tableFlags().
.SH "void QTableView::setTopCell ( int row ) \fC[virtual protected]\fR"
Scrolls the table such that \fIrow\fR becomes the top row. The index of the very first row is 0.
.PP
See also setYOffset(), setTopLeftCell() and setLeftCell().
.SH "void QTableView::setTopLeftCell ( int row, int col ) \fC[virtual protected]\fR"
Scrolls the table such that the cell at row \fIrow\fR and colum \fIcol\fR becomes the top left cell in the view. The cell at the extreme top left of the table is at position (0,0).
.PP
See also setLeftCell(), setTopCell() and setOffset().
.SH "void QTableView::setXOffset ( int x ) \fC[virtual protected]\fR"
Scrolls the table such that \fIx\fR becomes the leftmost pixel in the view. The \fIx\fR parameter is in \fItable\fR coordinates.
.PP
The interaction with Tbl_snapToHGrid is tricky.
.PP
See also xOffset(), setYOffset(), setOffset() and setLeftCell().
.SH "void QTableView::setYOffset ( int y ) \fC[virtual protected]\fR"
Scrolls the table such that \fIy\fR becomes the top pixel in the view. The \fIy\fR parameter is in \fItable\fR coordinates.
.PP
The interaction with Tbl_snapToVGrid is tricky.
.PP
See also yOffset(), setXOffset(), setOffset() and setTopCell().
.SH "void QTableView::setupPainter ( QPainter * ) \fC[virtual protected]\fR"
This virtual function is called before painting of table cells is started. It can be reimplemented by subclasses that want to to set up the painter in a special way and that do not want to do so for each cell.
.SH "void QTableView::show () \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QWidget.
.SH "uint QTableView::tableFlags () const \fC[protected]\fR"
Returns the union of the table flags that are currently set.
.PP
See also setTableFlags(), clearTableFlags() and testTableFlags().
.SH "bool QTableView::testTableFlags ( uint f ) const \fC[protected]\fR"
Returns TRUE if any of the table flags in \fIf\fR are currently set, otherwise FALSE.
.PP
See also setTableFlags(), clearTableFlags() and tableFlags().
.SH "int QTableView::topCell () const \fC[protected]\fR"
Returns the index of the first row in the table that is visible in the view. The index of the very first row is 0.
.PP
See also leftCell() and setTopCell().
.SH "int QTableView::totalHeight () \fC[virtual protected]\fR"
Returns the total height of the table in pixels.
.PP
This function is virtual and should be reimplemented by subclasses that have variable cell heights and a non-trivial cellHeight() function, or a large number of rows in the table.
.PP
The default implementation may be slow for very tall tables.
.PP
See also cellHeight() and totalWidth().
.SH "int QTableView::totalWidth () \fC[virtual protected]\fR"
Returns the total width of the table in pixels.
.PP
This function is virtual and should be reimplemented by subclasses that have variable cell widths and a non-trivial cellWidth() function, or a large number of columns in the table.
.PP
The default implementation may be slow for very wide tables.
.PP
See also cellWidth() and totalHeight().
.SH "void QTableView::updateCell ( int row, int col, bool erase=TRUE ) \fC[protected]\fR"
Repaints the cell at row \fIrow,\fR column \fIcol\fR if it is inside the view.
.PP
If \fIerase\fR is TRUE, the relevant part of the view is cleared to the background color/pixmap before the contents are repainted.
.PP
See also isVisible().
.SH "void QTableView::updateScrollBars () \fC[protected]\fR"
Updates the scroll bars' contents and presence to match the table's state. Generally you should not need to call this.
.PP
See also setTableFlags().
.SH "void QTableView::updateTableSize () \fC[protected]\fR"
Updates the scroll bars and internal state.
.PP
Call this function when the table view's total size is changed; typically because the result of cellHeight() or cellWidth() have changed.
.PP
This function does not repaint the widget.
.SH "QScrollBar * QTableView::verticalScrollBar () const \fC[protected]\fR"
Returns a pointer to the vertical scroll bar, mainly so you can connect() to its signals. Note that the scroll bar works in pixel values, use findRow() to translate to cell numbers.
.SH "int QTableView::viewHeight () const \fC[protected]\fR"
Returns the height of the table view, as such, in \fIview\fR coordinates. This does not include any header, scroll bar or frame, but does include background pixels below the table data.
.PP
See also minViewY(), maxViewY(), viewWidth(), contentsRect() and viewRect().
.SH "QRect QTableView::viewRect () const \fC[protected]\fR"
Returns the rectangle which is the actual table, excluding any frame, in \fIwidget\fR coordinates.
.SH "int QTableView::viewWidth () const \fC[protected]\fR"
Returns the width of the table view, as such, in \fIview\fR coordinates. This does not include any header, scroll bar or frame, but does include background pixels to the right of the table data.
.PP
See also minViewX(), maxViewX(), viewHeight(), contentsRect() and viewRect().
.SH "int QTableView::xOffset () const \fC[protected]\fR"
Returns the x coordinate in \fItable\fR coordinates of the pixel which is currently on the left edge of the view.
.PP
See also setXOffset(), yOffset() and leftCell().
.SH "int QTableView::yOffset () const \fC[protected]\fR"
Returns the y coordinate in \fItable\fR coordinates of the pixel which is currently on the top edge of the view.
.PP
See also setYOffset(), xOffset() and topCell().
.SH "void QTableView::setBackgroundColor ( const QColor & c ) \fC[virtual]\fR"
For internal use only.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qtableview.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qtableview.3qt) and the Qt
version (2.3.2).
