'\" t
.TH QVariant 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QVariant \- Acts like a union for the most common Qt data types
.br
.PP
\fC#include <qvariant.h>\fR
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "enum \fBType\fR { Invalid, Map, List, String, StringList, Font, Pixmap, Brush, Rect, Size, Color, Palette, ColorGroup, IconSet, Point, Image, Int, UInt, Bool, Double, CString, PointArray, Region, Bitmap, Cursor, SizePolicy }"
.br
.ti -1c
.BI "\fBQVariant\fR () "
.br
.ti -1c
.BI "\fB~QVariant\fR () "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QVariant & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( QDataStream & s ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QString & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QCString & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const char * ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QStringList & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QFont & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPixmap & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QImage & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QBrush & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPoint & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QRect & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QSize & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QColor & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPalette & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QColorGroup & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QIconSet & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QPointArray & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QRegion & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QBitmap & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QCursor & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QValueList<QVariant> & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( const QMap<QString, QVariant> & ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( int ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( uint ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( bool, int ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( double ) "
.br
.ti -1c
.BI "\fBQVariant\fR ( QSizePolicy ) "
.br
.ti -1c
.BI "QVariant& \fBoperator=\fR ( const QVariant & ) "
.br
.ti -1c
.BI "bool \fBoperator==\fR ( const QVariant & ) const"
.br
.ti -1c
.BI "bool \fBoperator!=\fR ( const QVariant & ) const"
.br
.ti -1c
.BI "Type \fBtype\fR () const"
.br
.ti -1c
.BI "const char* \fBtypeName\fR () const"
.br
.ti -1c
.BI "bool \fBcanCast\fR ( Type ) const"
.br
.ti -1c
.BI "bool \fBisValid\fR () const"
.br
.ti -1c
.BI "void \fBclear\fR () "
.br
.ti -1c
.BI "const QString \fBtoString\fR () const"
.br
.ti -1c
.BI "const QCString \fBtoCString\fR () const"
.br
.ti -1c
.BI "const QStringList \fBtoStringList\fR () const"
.br
.ti -1c
.BI "const QFont \fBtoFont\fR () const"
.br
.ti -1c
.BI "const QPixmap \fBtoPixmap\fR () const"
.br
.ti -1c
.BI "const QImage \fBtoImage\fR () const"
.br
.ti -1c
.BI "const QBrush \fBtoBrush\fR () const"
.br
.ti -1c
.BI "const QPoint \fBtoPoint\fR () const"
.br
.ti -1c
.BI "const QRect \fBtoRect\fR () const"
.br
.ti -1c
.BI "const QSize \fBtoSize\fR () const"
.br
.ti -1c
.BI "const QColor \fBtoColor\fR () const"
.br
.ti -1c
.BI "const QPalette \fBtoPalette\fR () const"
.br
.ti -1c
.BI "const QColorGroup \fBtoColorGroup\fR () const"
.br
.ti -1c
.BI "const QIconSet \fBtoIconSet\fR () const"
.br
.ti -1c
.BI "const QPointArray \fBtoPointArray\fR () const"
.br
.ti -1c
.BI "const QBitmap \fBtoBitmap\fR () const"
.br
.ti -1c
.BI "const QRegion \fBtoRegion\fR () const"
.br
.ti -1c
.BI "const QCursor \fBtoCursor\fR () const"
.br
.ti -1c
.BI "int \fBtoInt\fR () const"
.br
.ti -1c
.BI "uint \fBtoUInt\fR () const"
.br
.ti -1c
.BI "bool \fBtoBool\fR () const"
.br
.ti -1c
.BI "double \fBtoDouble\fR () const"
.br
.ti -1c
.BI "const QValueList<QVariant> \fBtoList\fR () const"
.br
.ti -1c
.BI "const QMap<QString, QVariant> \fBtoMap\fR () const"
.br
.ti -1c
.BI "QSizePolicy \fBtoSizePolicy\fR () const"
.br
.ti -1c
.BI "QValueListConstIterator<QVariant> \fBlistBegin\fR () const"
.br
.ti -1c
.BI "QValueListConstIterator<QVariant> \fBlistEnd\fR () const"
.br
.ti -1c
.BI "QValueListConstIterator<QString> \fBstringListBegin\fR () const"
.br
.ti -1c
.BI "QValueListConstIterator<QString> \fBstringListEnd\fR () const"
.br
.ti -1c
.BI "QMapConstIterator<QString, QVariant> \fBmapBegin\fR () const"
.br
.ti -1c
.BI "QMapConstIterator<QString, QVariant> \fBmapEnd\fR () const"
.br
.ti -1c
.BI "QMapConstIterator<QString, QVariant> \fBmapFind\fR ( const QString & ) const"
.br
.ti -1c
.BI "QString& \fBasString\fR () "
.br
.ti -1c
.BI "QCString& \fBasCString\fR () "
.br
.ti -1c
.BI "QStringList& \fBasStringList\fR () "
.br
.ti -1c
.BI "QFont& \fBasFont\fR () "
.br
.ti -1c
.BI "QPixmap& \fBasPixmap\fR () "
.br
.ti -1c
.BI "QImage& \fBasImage\fR () "
.br
.ti -1c
.BI "QBrush& \fBasBrush\fR () "
.br
.ti -1c
.BI "QPoint& \fBasPoint\fR () "
.br
.ti -1c
.BI "QRect& \fBasRect\fR () "
.br
.ti -1c
.BI "QSize& \fBasSize\fR () "
.br
.ti -1c
.BI "QColor& \fBasColor\fR () "
.br
.ti -1c
.BI "QPalette& \fBasPalette\fR () "
.br
.ti -1c
.BI "QColorGroup& \fBasColorGroup\fR () "
.br
.ti -1c
.BI "QIconSet& \fBasIconSet\fR () "
.br
.ti -1c
.BI "QPointArray& \fBasPointArray\fR () "
.br
.ti -1c
.BI "QBitmap& \fBasBitmap\fR () "
.br
.ti -1c
.BI "QRegion& \fBasRegion\fR () "
.br
.ti -1c
.BI "QCursor& \fBasCursor\fR () "
.br
.ti -1c
.BI "int& \fBasInt\fR () "
.br
.ti -1c
.BI "uint& \fBasUInt\fR () "
.br
.ti -1c
.BI "bool& \fBasBool\fR () "
.br
.ti -1c
.BI "double& \fBasDouble\fR () "
.br
.ti -1c
.BI "QValueList<QVariant>& \fBasList\fR () "
.br
.ti -1c
.BI "QMap<QString, QVariant>& \fBasMap\fR () "
.br
.ti -1c
.BI "QSizePolicy& \fBasSizePolicy\fR () "
.br
.ti -1c
.BI "void \fBload\fR ( QDataStream & ) "
.br
.ti -1c
.BI "void \fBsave\fR ( QDataStream & ) const"
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "const char* \fBtypeToName\fR ( Type typ ) "
.br
.ti -1c
.BI "Type \fBnameToType\fR ( const char * name ) "
.br
.in -1c
.SH DESCRIPTION
Acts like a union for the most common Qt data types.
.PP
Since C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. This is a problem when using QObject::property(), among other things.
.PP
This class provides union functionality for property() and most other needs that might be solved by a union including e.g. QWidget.
.PP
A QVariant object can hold any one type() at a time, and you can find out what type it holds, convert it to a different type using e.g. asSize(), get its value using e.g. toSize(), and check whether the type can be converted to e.g. QSize using canCast().
.PP
The methods named toT() (for any supported T, see the Type documentation for a list) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type which can be generated from the stored type, toT() copies and converts, and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type, see the function documentation for details.
.PP
Note that three data types supported by QVariant are explicitly shared, namely QImage, QPointArray, and QCString, and in these cases the toT() methods return a shallow copy. In almost all cases, you must make a deep copy of the returned values before modifying them.
.PP
The methods named asT() are not const. They do conversion like toT() methods, set the variant to hold the converted value, and return a reference to the new contents of the variant.
.PP
Here is some example code to demonstrate use of QVariant:
.PP
.nf
.br
    QDataStream out(...);
.br
    QVariant v(123);          // The variant now contains an int
.br
    int x = v.toInt();        // x = 123
.br
    out << v;                 // Writes a type tag and an int to out
.br
    v = QVariant("hello");    // The variant now contains a QCString
.br
    v = QVariant(tr("hello"));// The variant now contains a QString
.br
    int y = v.toInt();        // y = 0 since v cannot be converted to an int
.br
    QString s = v.toString(); // s = tr("hello")  (see QObject::tr())
.br
    out << v;                 // Writes a type tag and a QString to out
.br
    ...
.br
    QDataStream in(...);      // (opening the previously written stream)
.br
    in >> v;                  // Reads an Int variant
.br
    int z = v.toInt();        // z = 123
.br
    qDebug("Type is %s",      // prints "Type is int"
.br
      v.typeName());
.br
    v.asInt() += 100;         // The variant now hold the value 223.
.br
    v = QVariant( QStringList() );
.br
    v.asStringList().append( "Hallo" );
.fi
.PP
You can even have a QValueList<QVariant> stored in the variant - giving arbitrarily complex data values with lists of variants, some of which are strings while others are integers and other still are lists of lists of lists of variants. This is very powerful, and you can easily shoot yourself in the foot with all this power. Caveat programmor.
.SS "Member Type Documentation"
.SH "QVariant::Type"
This enum type defines the types of variable that a QVariant can contain. The supported enum values and the associated types are: 
.TP
\fCInvalid\fR - no type
.TP
\fCList\fR - a QValueList<QVariant>
.TP
\fCMap\fR - a QMap<QString,QVariant>
.TP
\fCString\fR - a QString
.TP
\fCStringList\fR - a QStringList
.TP
\fCFont\fR - a QFont
.TP
\fCPixmap\fR - a QPixmap
.TP
\fCBrush\fR - a QBrush
.TP
\fCRect\fR - a QRect
.TP
\fCSize\fR - a QSize
.TP
\fCColor\fR - a QColor
.TP
\fCPalette\fR - a QPalette
.TP
\fCColorGroup\fR - a QColorGroup
.TP
\fCIconSet\fR - a QIconSet
.TP
\fCPoint\fR - a QPoint
.TP
\fCImage\fR - a QImage
.TP
\fCInt\fR - an int
.TP
\fCUInt\fR - an unsigned int
.TP
\fCBool\fR - a bool
.TP
\fCDouble\fR - a doublea
.TP
\fCCString\fR - a QCString
.TP
\fCPointArray\fR - a QPointArray
.TP
\fCRegion\fR - a QRegion
.TP
\fCBitmap\fR - a QBitmap
.TP
\fCCursor\fR - a QCursor
.TP
\fCSizePolicy\fR - a QSizePolicy
.IP
.PP
Note that Qt's definition of bool depends on the compiler. qglobal.h has the system-dependent definition of bool.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QVariant::QVariant ()"
Constructs an invalid variant.
.SH "QVariant::QVariant ( QDataStream & s )"
Reads the variant from the data stream.
.SH "QVariant::QVariant ( QSizePolicy val )"
Constructs a new variant with a size policy value.
.SH "QVariant::QVariant ( bool val, int )"
Constructs a new variant with a boolean value. The integer argument is a dummy, necessary for compatibility with certain compiler that even its mother cannot love.
.SH "QVariant::QVariant ( const QBitmap & val )"
Constructs a new variant with a bitmap value.
.SH "QVariant::QVariant ( const QBrush & val )"
Constructs a new variant with a brush value.
.SH "QVariant::QVariant ( const QColor & val )"
Constructs a new variant with a color value.
.SH "QVariant::QVariant ( const QColorGroup & val )"
Constructs a new variant with a color group value.
.SH "QVariant::QVariant ( const QCString & val )"
Constructs a new variant with a c-string value.
.PP
If you want to modify the QCString you pass to this constructor after this call, we recommend passing a deep copy (see QCString::copy()).
.SH "QVariant::QVariant ( const QCursor & val )"
Constructs a new variant with a cursor value.
.SH "QVariant::QVariant ( const QFont & val )"
Constructs a new variant with a font value.
.SH "QVariant::QVariant ( const QIconSet & val )"
Constructs a new variant with an icon set value.
.SH "QVariant::QVariant ( const QImage & val )"
Constructs a new variant with an image value.
.PP
Since QImage is explicitly shared you may need to pass a deep copy to the variant using QImage::copy().
.SH "QVariant::QVariant ( const QMap<QString,QVariant> & val )"
Constructs a new variant with a map of QVariants.
.SH "QVariant::QVariant ( const QPalette & val )"
Constructs a new variant with a color palette value.
.SH "QVariant::QVariant ( const QPixmap & val )"
Constructs a new variant with a pixmap value.
.SH "QVariant::QVariant ( const QPoint & val )"
Constructs a new variant with a point value.
.SH "QVariant::QVariant ( const QPointArray & val )"
Constructs a new variant with an point array value.
.PP
Since QPointArray is explicitly shared you may need to pass a deep copy to the variant using QPointArray::copy().
.SH "QVariant::QVariant ( const QRect & val )"
Constructs a new variant with a rect value.
.SH "QVariant::QVariant ( const QRegion & val )"
Constructs a new variant with a region.
.SH "QVariant::QVariant ( const QSize & val )"
Constructs a new variant with a size value.
.SH "QVariant::QVariant ( const QString & val )"
Constructs a new variant with a string value.
.SH "QVariant::QVariant ( const QStringList & val )"
Constructs a new variant with a string list value.
.SH "QVariant::QVariant ( const QValueList<QVariant> & val )"
Constructs a new variant with a list value.
.SH "QVariant::QVariant ( const QVariant & p )"
Constructs a copy of the variant passed as argument to this constructor. Usually this is a deep copy, but if the stored data type is explicit shared then a shallow copy is made.
.SH "QVariant::QVariant ( const char * val )"
Constructs a new variant with a c-string value, if \fIval\fR is non-null. The variant creates a deep copy of \fIval.\fR
.PP
If \fIval\fR is null, the resulting variant has type Invalid.
.SH "QVariant::QVariant ( double val )"
Constructs a new variant with a floating point value.
.SH "QVariant::QVariant ( int val )"
Constructs a new variant with an integer value.
.SH "QVariant::QVariant ( uint val )"
Constructs a new variant with an unsigned integer value.
.SH "QVariant::~QVariant ()"
Destructs the QVariant and the contained object.
.PP
Note that subclasses that re-implement clear() should reimplement the destructor to call clear(). This destructor calls clear(), but since it is the destructor, QVariant::clear() is called rather than any subclass.
.SH "QBitmap& QVariant::asBitmap ()"
Tries to convert the variant to hold a bitmap value. If that is not possible then the variant is set to a null bitmap.
.PP
Returns a reference to the stored bitmap.
.PP
See also toBitmap().
.SH "bool& QVariant::asBool ()"
Returns the variant's value as bool reference.
.SH "QBrush& QVariant::asBrush ()"
Tries to convert the variant to hold a brush value. If that is not possible then the variant is set to a default black brush.
.PP
Returns a reference to the stored brush.
.PP
See also toBrush().
.SH "QCString& QVariant::asCString ()"
Tries to convert the variant to hold a string value. If that is not possible then the variant is set to an empty string.
.PP
Returns a reference to the stored string.
.PP
See also toCString().
.SH "QColor& QVariant::asColor ()"
Tries to convert the variant to hold a QColor value. If that is not possible then the variant is set to an invalid color.
.PP
Returns a reference to the stored color.
.PP
See also toColor() and QColor::isValid().
.SH "QColorGroup& QVariant::asColorGroup ()"
Tries to convert the variant to hold a QColorGroup value. If that is not possible then the variant is set to a color group with all colors set to black.
.PP
Returns a reference to the stored color group.
.PP
See also toColorGroup().
.SH "QCursor& QVariant::asCursor ()"
Tries to convert the variant to hold a QCursor value. If that is not possible then the variant is set to a default arrow cursor.
.PP
Returns a reference to the stored cursor.
.PP
See also toCursor().
.SH "double& QVariant::asDouble ()"
Returns the variant's value as double reference.
.SH "QFont& QVariant::asFont ()"
Tries to convert the variant to hold a QFont. If that is not possible then the variant is set to a default font.
.PP
Returns a reference to the stored font.
.PP
See also toFont().
.SH "QIconSet& QVariant::asIconSet ()"
Tries to convert the variant to hold a QIconSet value. If that is not possible then the variant is set to an empty iconset.
.PP
Returns a reference to the stored iconset.
.PP
See also toIconSet().
.SH "QImage& QVariant::asImage ()"
Tries to convert the variant to hold an image value. If that is not possible then the variant is set to a null image.
.PP
Returns a reference to the stored image.
.PP
See also toImage().
.SH "int& QVariant::asInt ()"
Returns the variant's value as int reference.
.SH "QValueList<QVariant>& QVariant::asList ()"
Returns the variant's value as variant list reference.
.SH "QMap<QString, QVariant>& QVariant::asMap ()"
Returns the variant's value as variant map reference.
.SH "QPalette& QVariant::asPalette ()"
Tries to convert the variant to hold a QPalette value. If that is not possible then the variant is set to a palette with black colors only.
.PP
Returns a reference to the stored palette.
.PP
See also toString().
.SH "QPixmap& QVariant::asPixmap ()"
Tries to convert the variant to hold a pixmap value. If that is not possible then the variant is set to a null pixmap.
.PP
Returns a reference to the stored pixmap.
.PP
See also toPixmap().
.SH "QPoint& QVariant::asPoint ()"
Tries to convert the variant to hold a point value. If that is not possible then the variant is set to a null point.
.PP
Returns a reference to the stored point.
.PP
See also toPoint().
.SH "QPointArray& QVariant::asPointArray ()"
Tries to convert the variant to hold a QPointArray value. If that is not possible then the variant is set to an empty point array.
.PP
Returns a reference to the stored point array.
.PP
See also toPointArray().
.SH "QRect& QVariant::asRect ()"
Tries to convert the variant to hold a rectangle value. If that is not possible then the variant is set to an empty rectangle.
.PP
Returns a reference to the stored rectangle.
.PP
See also toRect().
.SH "QRegion& QVariant::asRegion ()"
Tries to convert the variant to hold a QRegion value. If that is not possible then the variant is set to a null region.
.PP
Returns a reference to the stored region.
.PP
See also toRegion().
.SH "QSize& QVariant::asSize ()"
Tries to convert the variant to hold a QSize value. If that is not possible then the variant is set to an invalid size.
.PP
Returns a reference to the stored size.
.PP
See also toSize() and QSize::isValid().
.SH "QSizePolicy& QVariant::asSizePolicy ()"
Tries to convert the variant to hold a QSizePolicy value. If that fails, the variant is set to an arbitrary size policy.
.SH "QString& QVariant::asString ()"
Tries to convert the variant to hold a string value. If that is not possible then the variant is set to an empty string.
.PP
Returns a reference to the stored string.
.PP
See also toString().
.SH "QStringList& QVariant::asStringList ()"
Tries to convert the variant to hold a QStringList value. If that is not possible then the variant is set to an empty string list.
.PP
Returns a reference to the stored string list.
.PP
See also toStringList().
.SH "uint& QVariant::asUInt ()"
Returns the variant's value as unsigned int reference.
.SH "bool QVariant::canCast ( Type t ) const"
Returns TRUE if the current type of the variant can be cast to the requested type. Such casting is done automatically when calling the toInt(), toBool(), ... or asInt(), asBool(), ... methods.
.PP
The following casts are done automatically:
.TP
Bool -> Double, Int, UInt
.TP
Double -> Int, Bool, UInt
.TP
Int -> Double, Bool, UInt
.TP
UInt -> Double, Bool, Int
.TP
String -> CString
.TP
CString -> String
.TP
List -> StringList (if the list contains strings or something that can be cast to a string).
.TP
StringList -> List
.SH "void QVariant::clear ()"
Convert this variant to type Invalid and free up any resources used.
.SH "bool QVariant::isValid () const"
Returns TRUE if the storage type of this variant is not QVariant::Invalid.
.SH "QValueListConstIterator<QVariant> QVariant::listBegin () const"
Returns an iterator to the first item in the list, if the variant's type is appropriate, or else a null iterator.
.SH "QValueListConstIterator<QVariant> QVariant::listEnd () const"
Returns the end iterator for the list, if the variant's type is appropriate, or else a null iterator.
.SH "void QVariant::load ( QDataStream & s )"
Internal function for loading a variant. Use the stream operators instead.
.SH "QMapConstIterator<QString, QVariant> QVariant::mapBegin () const"
Returns an iterator to the first item in the map, if the variant's type is appropriate, or else a null iterator.
.SH "QMapConstIterator<QString, QVariant> QVariant::mapEnd () const"
Returns the end iterator for the map, if the variant's type is appropriate, or else a null iterator.
.SH "QMapConstIterator<QString, QVariant> QVariant::mapFind ( const QString & key ) const"
Returns an iterator to the item in the map with \fIkey\fR as key, if the variant's type is appropriate and \fIkey\fR is a valid key, or else a null iterator.
.SH "QVariant::Type QVariant::nameToType( const char * name ) \fC[static]\fR"
Converts the string representation of the storage type to its enum representation.
.PP
If the string representation cannot be converted to any enum representation, the variant is set to \fCInvalid.\fR
.SH "bool QVariant::operator!= ( const QVariant & v ) const"
Compares this QVariant with \fIv\fR and returns TRUE if they are not equal, FALSE otherwise.
.SH "QVariant& QVariant::operator= ( const QVariant & variant )"
Assigns the value of some \fIother\fR variant to this variant.
.PP
This is a deep copy of the variant, but note that if the variant holds an explicitly shared type such as QImage, it is a shallow copy of the (e.g.) QImage.
.SH "bool QVariant::operator== ( const QVariant & v ) const"
Compares this QVariant with \fIv\fR and returns TRUE if they are equal, FALSE otherwise.
.SH "void QVariant::save ( QDataStream & s ) const"
Internal function for saving a variant. Use the stream operators instead.
.SH "QValueListConstIterator<QString> QVariant::stringListBegin () const"
Returns an iterator to the first string in the list, if the variant's type is StringList, or else a null iterator.
.SH "QValueListConstIterator<QString> QVariant::stringListEnd () const"
Returns the end iterator for the list, if the variant's type is StringList, or else a null iterator.
.SH "const QBitmap QVariant::toBitmap () const"
Returns the variant as a QBitmap if the variant has type() Bitmap, or a null QBitmap otherwise.
.PP
See also asBitmap().
.SH "bool QVariant::toBool () const"
Returns the variant as a bool if the variant has type() Bool, or FALSE otherwise. The only exceptions to this rule are the types Int, UInt, Double. In this case TRUE is returned if the numerical value is not zero or FALSE otherwise.
.PP
See also asBool().
.SH "const QBrush QVariant::toBrush () const"
Returns the variant as a QBrush if the variant has type() Brush, or a default brush (with all black colors) otherwise.
.PP
See also asBrush().
.SH "const QCString QVariant::toCString () const"
Returns the variant as a QCString if the variant has type() CString, or a 0 otherwise.
.PP
See also asCString().
.SH "const QColor QVariant::toColor () const"
Returns the variant as a QColor if the variant has type() Color, or an invalid color otherwise.
.PP
See also asColor().
.SH "const QColorGroup QVariant::toColorGroup () const"
Returns the variant as a QColorGroup if the variant has type() ColorGroup, or a completely black color group otherwise.
.PP
See also asColorGroup().
.SH "const QCursor QVariant::toCursor () const"
Returns the variant as a QCursor if the variant has type() Cursor, or the default arrow cursor otherwise.
.PP
See also asCursor().
.SH "double QVariant::toDouble () const"
Returns the variant as a double if the variant has type() Double, Int, UInt or Bool, or 0.0 otherwise.
.PP
See also asDouble().
.SH "const QFont QVariant::toFont () const"
Returns the variant as a QFont if the variant has type() Font, or the default font otherwise.
.PP
See also asFont().
.SH "const QIconSet QVariant::toIconSet () const"
Returns the variant as a QIconSet if the variant has type() IconSet, or an icon set of null pixmaps otherwise.
.PP
See also asIconSet().
.SH "const QImage QVariant::toImage () const"
Returns the variant as a QImage if the variant has type() Image, or a null image otherwise.
.PP
See also asImage().
.SH "int QVariant::toInt () const"
Returns the variant as an int if the variant has type() Int, UInt, Double or Bool, or 0 otherwise.
.PP
See also asInt().
.SH "const QValueList<QVariant> QVariant::toList () const"
Returns the variant as a QValueList<QVariant> if the variant has type() List or StringList, or an empty list otherwise.
.PP
See also asList().
.SH "const QMap<QString, QVariant> QVariant::toMap () const"
Returns the variant as a QMap<QString,QVariant> if the variant has type() Map, or an empty map otherwise.
.PP
See also asMap().
.SH "const QPalette QVariant::toPalette () const"
Returns the variant as a QPalette if the variant has type() Palette, or a completely black palette otherwise.
.PP
See also asPalette().
.SH "const QPixmap QVariant::toPixmap () const"
Returns the variant as a QPixmap if the variant has type() Pixmap, or a null pixmap otherwise.
.PP
See also asPixmap().
.SH "const QPoint QVariant::toPoint () const"
Returns the variant as a QPoint if the variant has type() Point, or a the point (0,0) otherwise.
.PP
See also asPoint().
.SH "const QPointArray QVariant::toPointArray () const"
Returns the variant as a QPointArray if the variant has type() PointArray, or an empty QPointArray otherwise.
.PP
See also asPointArray().
.SH "const QRect QVariant::toRect () const"
Returns the variant as a QRect if the variant has type() Rect, or an empty rectangle otherwise.
.PP
See also asRect().
.SH "const QRegion QVariant::toRegion () const"
Returns the variant as a QRegion if the variant has type() Region, or an empty QRegion otherwise.
.PP
See also asRegion().
.SH "const QSize QVariant::toSize () const"
Returns the variant as a QSize if the variant has type() Size, or an invalid size otherwise.
.PP
See also asSize().
.SH "QSizePolicy QVariant::toSizePolicy () const"
Returns the variant as a QSizePolicy if the variant has type() SizePolicy, or an undefined but legal size policy else.
.SH "const QString QVariant::toString () const"
Returns the variant as a QString if the variant has type() String or CString, or QString::null otherwise.
.PP
See also asString().
.SH "const QStringList QVariant::toStringList () const"
Returns the variant as a QStringList if the variant has type() StringList or List of a type that can be converted to QString, or an empty list otherwise.
.PP
See also asStringList().
.SH "uint QVariant::toUInt () const"
Returns the variant as an unsigned int if the variant has type() UInt, Int, Double or Bool, or 0 otherwise.
.PP
See also asUInt().
.SH "Type QVariant::type () const"
Returns the storage type of the value stored in the variant. Usually it's best to test with canCast() wether the variant can deliver the data type you are interested in.
.SH "const char* QVariant::typeName () const"
Returns the name of the type stored in the variant. The returned strings describe the C++ datatype used to store the data, for example "QFont", "QString" or "QValueList<QVariant>". An Invalid variant returns 0.
.SH "const char* QVariant::typeToName ( Type typ ) \fC[static]\fR"
Converts the enum representation of the storage type to its
string representation.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qvariant.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qvariant.3qt) and the Qt
version (2.3.2).
