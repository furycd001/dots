'\" t
.TH QWidget 3qt "29 October 2001" "Trolltech AS" \" -*- nroff -*-
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.  See the
.\" license file included in the distribution for a complete license
.\" statement.
.\"
.ad l
.nh
.SH NAME
QWidget \- The base class of all user interface objects
.br
.PP
\fC#include <qwidget.h>\fR
.PP
Inherits QObject and QPaintDevice.
.PP
Inherited by QButton, QComboBox, QDial, QDialog, QFrame, QGLWidget, QHeader, QLineEdit, QMainWindow, QNPWidget, QScrollBar, QSemiModal, QSizeGrip, QSlider, QStatusBar, QTabBar, QTabWidget, QToolBar, QWorkspace and QXtWidget.
.PP
.SS "Public Members"
.in +1c
.ti -1c
.BI "\fBQWidget\fR ( QWidget * " "parent" "=0, const char * " "name" "=0, WFlags " "f" "=0 ) "
.br
.ti -1c
.BI "\fB~QWidget\fR () "
.br
.ti -1c
.BI "WId \fBwinId\fR () const"
.br
.ti -1c
.BI "QStyle& \fBstyle\fR () const"
.br
.ti -1c
.BI "void \fBsetStyle\fR ( QStyle * ) "
.br
.ti -1c
.BI "bool \fBisTopLevel\fR () const"
.br
.ti -1c
.BI "bool \fBisModal\fR () const"
.br
.ti -1c
.BI "bool \fBisPopup\fR () const"
.br
.ti -1c
.BI "bool \fBisDesktop\fR () const"
.br
.ti -1c
.BI "bool \fBisEnabled\fR () const"
.br
.ti -1c
.BI "bool \fBisEnabledTo\fR ( QWidget * ) const"
.br
.ti -1c
.BI "bool isEnabledToTLW () const \fI(obsolete)\fR"
.br
.ti -1c
.BI "QRect \fBframeGeometry\fR () const"
.br
.ti -1c
.BI "const QRect& \fBgeometry\fR () const"
.br
.ti -1c
.BI "int \fBx\fR () const"
.br
.ti -1c
.BI "int \fBy\fR () const"
.br
.ti -1c
.BI "QPoint \fBpos\fR () const"
.br
.ti -1c
.BI "QSize \fBframeSize\fR () const"
.br
.ti -1c
.BI "QSize \fBsize\fR () const"
.br
.ti -1c
.BI "int \fBwidth\fR () const"
.br
.ti -1c
.BI "int \fBheight\fR () const"
.br
.ti -1c
.BI "QRect \fBrect\fR () const"
.br
.ti -1c
.BI "QRect \fBchildrenRect\fR () const"
.br
.ti -1c
.BI "QRegion \fBchildrenRegion\fR () const"
.br
.ti -1c
.BI "QSize \fBminimumSize\fR () const"
.br
.ti -1c
.BI "QSize \fBmaximumSize\fR () const"
.br
.ti -1c
.BI "int \fBminimumWidth\fR () const"
.br
.ti -1c
.BI "int \fBminimumHeight\fR () const"
.br
.ti -1c
.BI "int \fBmaximumWidth\fR () const"
.br
.ti -1c
.BI "int \fBmaximumHeight\fR () const"
.br
.ti -1c
.BI "void \fBsetMinimumSize\fR ( const QSize & ) "
.br
.ti -1c
.BI "virtual void \fBsetMinimumSize\fR ( int " "minw" ", int minh ) "
.br
.ti -1c
.BI "void \fBsetMaximumSize\fR ( const QSize & ) "
.br
.ti -1c
.BI "virtual void \fBsetMaximumSize\fR ( int " "maxw" ", int maxh ) "
.br
.ti -1c
.BI "void \fBsetMinimumWidth\fR ( int minw ) "
.br
.ti -1c
.BI "void \fBsetMinimumHeight\fR ( int minh ) "
.br
.ti -1c
.BI "void \fBsetMaximumWidth\fR ( int maxw ) "
.br
.ti -1c
.BI "void \fBsetMaximumHeight\fR ( int maxh ) "
.br
.ti -1c
.BI "QSize \fBsizeIncrement\fR () const"
.br
.ti -1c
.BI "void \fBsetSizeIncrement\fR ( const QSize & ) "
.br
.ti -1c
.BI "virtual void \fBsetSizeIncrement\fR ( int " "w" ", int h ) "
.br
.ti -1c
.BI "QSize \fBbaseSize\fR () const"
.br
.ti -1c
.BI "void \fBsetBaseSize\fR ( const QSize & ) "
.br
.ti -1c
.BI "void \fBsetBaseSize\fR ( int " "basew" ", int baseh ) "
.br
.ti -1c
.BI "void \fBsetFixedSize\fR ( const QSize & ) "
.br
.ti -1c
.BI "void \fBsetFixedSize\fR ( int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBsetFixedWidth\fR ( int w ) "
.br
.ti -1c
.BI "void \fBsetFixedHeight\fR ( int h ) "
.br
.ti -1c
.BI "QPoint \fBmapToGlobal\fR ( const QPoint & ) const"
.br
.ti -1c
.BI "QPoint \fBmapFromGlobal\fR ( const QPoint & ) const"
.br
.ti -1c
.BI "QPoint \fBmapToParent\fR ( const QPoint & ) const"
.br
.ti -1c
.BI "QPoint \fBmapFromParent\fR ( const QPoint & ) const"
.br
.ti -1c
.BI "QPoint \fBmapTo\fR ( QWidget *, const QPoint & ) const"
.br
.ti -1c
.BI "QPoint \fBmapFrom\fR ( QWidget *, const QPoint & ) const"
.br
.ti -1c
.BI "QWidget* \fBtopLevelWidget\fR () const"
.br
.ti -1c
.BI "enum \fBBackgroundMode\fR { FixedColor, FixedPixmap, NoBackground, PaletteForeground, PaletteButton, PaletteLight, PaletteMidlight, PaletteDark, PaletteMid, PaletteText, PaletteBrightText, PaletteBase, PaletteBackground, PaletteShadow, PaletteHighlight, PaletteHighlightedText, PaletteButtonText, X11ParentRelative }"
.br
.ti -1c
.BI "BackgroundMode \fBbackgroundMode\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetBackgroundMode\fR ( BackgroundMode ) "
.br
.ti -1c
.BI "const QColor& \fBbackgroundColor\fR () const"
.br
.ti -1c
.BI "const QColor& \fBforegroundColor\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetBackgroundColor\fR ( const QColor & ) "
.br
.ti -1c
.BI "const QPixmap* \fBbackgroundPixmap\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetBackgroundPixmap\fR ( const QPixmap & ) "
.br
.ti -1c
.BI "const QColorGroup& \fBcolorGroup\fR () const"
.br
.ti -1c
.BI "const QPalette& \fBpalette\fR () const"
.br
.ti -1c
.BI "bool \fBownPalette\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetPalette\fR ( const QPalette & ) "
.br
.ti -1c
.BI "void \fBunsetPalette\fR () "
.br
.ti -1c
.BI "QFont \fBfont\fR () const"
.br
.ti -1c
.BI "bool \fBownFont\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFont\fR ( const QFont & ) "
.br
.ti -1c
.BI "void \fBunsetFont\fR () "
.br
.ti -1c
.BI "QFontMetrics \fBfontMetrics\fR () const"
.br
.ti -1c
.BI "QFontInfo \fBfontInfo\fR () const"
.br
.ti -1c
.BI "enum \fBPropagationMode\fR { NoChildren, AllChildren, SameFont, SamePalette = SameFont }"
.br
.ti -1c
.BI "PropagationMode fontPropagation () const \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void setFontPropagation ( PropagationMode ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "PropagationMode palettePropagation () const \fI(obsolete)\fR"
.br
.ti -1c
.BI "virtual void setPalettePropagation ( PropagationMode ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "const QCursor& \fBcursor\fR () const"
.br
.ti -1c
.BI "bool \fBownCursor\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetCursor\fR ( const QCursor & ) "
.br
.ti -1c
.BI "virtual void \fBunsetCursor\fR () "
.br
.ti -1c
.BI "QString \fBcaption\fR () const"
.br
.ti -1c
.BI "const QPixmap* \fBicon\fR () const"
.br
.ti -1c
.BI "QString \fBiconText\fR () const"
.br
.ti -1c
.BI "bool \fBhasMouseTracking\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetMask\fR ( const QBitmap & ) "
.br
.ti -1c
.BI "virtual void \fBsetMask\fR ( const QRegion & ) "
.br
.ti -1c
.BI "void \fBclearMask\fR () "
.br
.ti -1c
.BI "enum \fBFocusPolicy\fR { NoFocus = 0, TabFocus = 0x1, ClickFocus = 0x2, StrongFocus = 0x3, WheelFocus = 0x7 }"
.br
.ti -1c
.BI "bool \fBisActiveWindow\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetActiveWindow\fR () "
.br
.ti -1c
.BI "bool \fBisFocusEnabled\fR () const"
.br
.ti -1c
.BI "FocusPolicy \fBfocusPolicy\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFocusPolicy\fR ( FocusPolicy ) "
.br
.ti -1c
.BI "bool \fBhasFocus\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetFocusProxy\fR ( QWidget * ) "
.br
.ti -1c
.BI "QWidget* \fBfocusProxy\fR () const"
.br
.ti -1c
.BI "void \fBgrabMouse\fR () "
.br
.ti -1c
.BI "void \fBgrabMouse\fR ( const QCursor & ) "
.br
.ti -1c
.BI "void \fBreleaseMouse\fR () "
.br
.ti -1c
.BI "void \fBgrabKeyboard\fR () "
.br
.ti -1c
.BI "void \fBreleaseKeyboard\fR () "
.br
.ti -1c
.BI "bool \fBisUpdatesEnabled\fR () const"
.br
.ti -1c
.BI "virtual bool \fBclose\fR ( bool alsoDelete ) "
.br
.ti -1c
.BI "bool \fBisVisible\fR () const"
.br
.ti -1c
.BI "bool \fBisVisibleTo\fR ( QWidget * ) const"
.br
.ti -1c
.BI "bool isVisibleToTLW () const \fI(obsolete)\fR"
.br
.ti -1c
.BI "QRect \fBvisibleRect\fR () const"
.br
.ti -1c
.BI "bool \fBisHidden\fR () const"
.br
.ti -1c
.BI "bool \fBisMinimized\fR () const"
.br
.ti -1c
.BI "bool \fBisMaximized\fR () const"
.br
.ti -1c
.BI "virtual QSize \fBsizeHint\fR () const"
.br
.ti -1c
.BI "virtual QSize \fBminimumSizeHint\fR () const"
.br
.ti -1c
.BI "virtual QSizePolicy \fBsizePolicy\fR () const"
.br
.ti -1c
.BI "void \fBsetSizePolicy\fR ( QSizePolicy ) "
.br
.ti -1c
.BI "virtual int \fBheightForWidth\fR ( int ) const"
.br
.ti -1c
.BI "virtual void \fBadjustSize\fR () "
.br
.ti -1c
.BI "QLayout* \fBlayout\fR () const"
.br
.ti -1c
.BI "void \fBupdateGeometry\fR () "
.br
.ti -1c
.BI "virtual void \fBreparent\fR ( QWidget * " "parent" ", WFlags, const QPoint &, bool " "showIt" "=FALSE ) "
.br
.ti -1c
.BI "void \fBreparent\fR ( QWidget * " "parent" ", const QPoint &, bool " "showIt" "=FALSE ) "
.br
.ti -1c
.BI "void \fBerase\fR () "
.br
.ti -1c
.BI "void \fBerase\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBerase\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBerase\fR ( const QRegion & ) "
.br
.ti -1c
.BI "void \fBscroll\fR ( int " "dx" ", int dy ) "
.br
.ti -1c
.BI "void \fBscroll\fR ( int " "dx" ", int " "dy" ", const QRect & ) "
.br
.ti -1c
.BI "void \fBdrawText\fR ( int " "x" ", int " "y" ", const QString & ) "
.br
.ti -1c
.BI "void \fBdrawText\fR ( const QPoint &, const QString & ) "
.br
.ti -1c
.BI "QWidget* \fBfocusWidget\fR () const"
.br
.ti -1c
.BI "QRect \fBmicroFocusHint\fR () const"
.br
.ti -1c
.BI "bool \fBacceptDrops\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetAcceptDrops\fR ( bool on ) "
.br
.ti -1c
.BI "virtual void \fBsetAutoMask\fR ( bool ) "
.br
.ti -1c
.BI "bool \fBautoMask\fR () const"
.br
.ti -1c
.BI "enum \fBBackgroundOrigin\fR { WidgetOrigin, ParentOrigin }"
.br
.ti -1c
.BI "void \fBsetBackgroundOrigin\fR ( BackgroundOrigin ) "
.br
.ti -1c
.BI "BackgroundOrigin \fBbackgroundOrigin\fR () const"
.br
.ti -1c
.BI "virtual bool \fBcustomWhatsThis\fR () const"
.br
.ti -1c
.BI "QWidget* \fBparentWidget\fR () const"
.br
.ti -1c
.BI "bool \fBtestWState\fR ( uint n ) const (internal)"
.br
.ti -1c
.BI "bool \fBtestWFlags\fR ( WFlags f ) const"
.br
.ti -1c
.BI "void setPalette ( const QPalette &, bool iReallyMeanIt ) \fI(obsolete)\fR"
.br
.ti -1c
.BI "void setFont ( const QFont &, bool iReallyMeanIt ) \fI(obsolete)\fR"
.br
.in -1c
.SS "Public Slots"
.in +1c
.ti -1c
.BI "virtual void \fBsetEnabled\fR ( bool ) "
.br
.ti -1c
.BI "void \fBsetDisabled\fR ( bool ) "
.br
.ti -1c
.BI "virtual void \fBsetCaption\fR ( const QString & ) "
.br
.ti -1c
.BI "virtual void \fBsetIcon\fR ( const QPixmap & ) "
.br
.ti -1c
.BI "virtual void \fBsetIconText\fR ( const QString & ) "
.br
.ti -1c
.BI "virtual void \fBsetMouseTracking\fR ( bool enable ) "
.br
.ti -1c
.BI "virtual void \fBsetFocus\fR () "
.br
.ti -1c
.BI "void \fBclearFocus\fR () "
.br
.ti -1c
.BI "virtual void \fBsetUpdatesEnabled\fR ( bool enable ) "
.br
.ti -1c
.BI "void \fBupdate\fR () "
.br
.ti -1c
.BI "void \fBupdate\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBupdate\fR ( const QRect & ) "
.br
.ti -1c
.BI "void \fBrepaint\fR () "
.br
.ti -1c
.BI "void \fBrepaint\fR ( bool erase ) "
.br
.ti -1c
.BI "void \fBrepaint\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "void \fBrepaint\fR ( const QRect &, bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "void \fBrepaint\fR ( const QRegion &, bool " "erase" "=TRUE ) "
.br
.ti -1c
.BI "virtual void \fBshow\fR () "
.br
.ti -1c
.BI "virtual void \fBhide\fR () "
.br
.ti -1c
.BI "virtual void \fBshowMinimized\fR () "
.br
.ti -1c
.BI "virtual void \fBshowMaximized\fR () "
.br
.ti -1c
.BI "void \fBshowFullScreen\fR () "
.br
.ti -1c
.BI "virtual void \fBshowNormal\fR () "
.br
.ti -1c
.BI "virtual void \fBpolish\fR () "
.br
.ti -1c
.BI "void \fBconstPolish\fR () const"
.br
.ti -1c
.BI "bool \fBclose\fR () "
.br
.ti -1c
.BI "void \fBraise\fR () "
.br
.ti -1c
.BI "void \fBlower\fR () "
.br
.ti -1c
.BI "void \fBstackUnder\fR ( QWidget * ) "
.br
.ti -1c
.BI "virtual void \fBmove\fR ( int " "x" ", int y ) "
.br
.ti -1c
.BI "void \fBmove\fR ( const QPoint & ) "
.br
.ti -1c
.BI "virtual void \fBresize\fR ( int " "w" ", int h ) "
.br
.ti -1c
.BI "void \fBresize\fR ( const QSize & ) "
.br
.ti -1c
.BI "virtual void \fBsetGeometry\fR ( int " "x" ", int " "y" ", int " "w" ", int h ) "
.br
.ti -1c
.BI "virtual void \fBsetGeometry\fR ( const QRect & ) "
.br
.in -1c
.SS "Static Public Members"
.in +1c
.ti -1c
.BI "void \fBsetTabOrder\fR ( QWidget *, QWidget * ) "
.br
.ti -1c
.BI "QWidget* \fBmouseGrabber\fR () "
.br
.ti -1c
.BI "QWidget* \fBkeyboardGrabber\fR () "
.br
.ti -1c
.BI "QWidget* \fBfind\fR ( WId ) "
.br
.ti -1c
.BI "QWidgetMapper* \fBwmapper\fR () (internal)"
.br
.in -1c
.SS "Protected Members"
.in +1c
.ti -1c
.BI "virtual bool \fBevent\fR ( QEvent * ) "
.br
.ti -1c
.BI "virtual void \fBmousePressEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBmouseReleaseEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBmouseDoubleClickEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBmouseMoveEvent\fR ( QMouseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBwheelEvent\fR ( QWheelEvent * ) "
.br
.ti -1c
.BI "virtual void \fBkeyPressEvent\fR ( QKeyEvent * ) "
.br
.ti -1c
.BI "virtual void \fBkeyReleaseEvent\fR ( QKeyEvent * ) "
.br
.ti -1c
.BI "virtual void \fBfocusInEvent\fR ( QFocusEvent * ) "
.br
.ti -1c
.BI "virtual void \fBfocusOutEvent\fR ( QFocusEvent * ) "
.br
.ti -1c
.BI "virtual void \fBenterEvent\fR ( QEvent * ) "
.br
.ti -1c
.BI "virtual void \fBleaveEvent\fR ( QEvent * ) "
.br
.ti -1c
.BI "virtual void \fBpaintEvent\fR ( QPaintEvent * ) "
.br
.ti -1c
.BI "virtual void \fBmoveEvent\fR ( QMoveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBresizeEvent\fR ( QResizeEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcloseEvent\fR ( QCloseEvent * ) "
.br
.ti -1c
.BI "virtual void \fBdragEnterEvent\fR ( QDragEnterEvent * ) "
.br
.ti -1c
.BI "virtual void \fBdragMoveEvent\fR ( QDragMoveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBdragLeaveEvent\fR ( QDragLeaveEvent * ) "
.br
.ti -1c
.BI "virtual void \fBdropEvent\fR ( QDropEvent * ) "
.br
.ti -1c
.BI "virtual void \fBshowEvent\fR ( QShowEvent * ) "
.br
.ti -1c
.BI "virtual void \fBhideEvent\fR ( QHideEvent * ) "
.br
.ti -1c
.BI "virtual void \fBcustomEvent\fR ( QCustomEvent * ) "
.br
.ti -1c
.BI "virtual void \fBupdateMask\fR () "
.br
.ti -1c
.BI "virtual void \fBstyleChange\fR ( QStyle & ) "
.br
.ti -1c
.BI "virtual void \fBenabledChange\fR ( bool ) "
.br
.ti -1c
.BI "virtual void \fBbackgroundColorChange\fR ( const QColor & ) "
.br
.ti -1c
.BI "virtual void \fBbackgroundPixmapChange\fR ( const QPixmap & ) "
.br
.ti -1c
.BI "virtual void \fBpaletteChange\fR ( const QPalette & ) "
.br
.ti -1c
.BI "virtual void \fBfontChange\fR ( const QFont & ) "
.br
.ti -1c
.BI "virtual int \fBmetric\fR ( int ) const"
.br
.ti -1c
.BI "virtual void \fBcreate\fR ( WId = 0, bool " "initializeWindow" " = TRUE, bool " "destroyOldWindow" " = TRUE ) "
.br
.ti -1c
.BI "virtual void \fBdestroy\fR ( bool " "destroyWindow" " = TRUE, bool " "destroySubWindows" " = TRUE ) "
.br
.ti -1c
.BI "uint \fBgetWState\fR () const (internal)"
.br
.ti -1c
.BI "virtual void \fBsetWState\fR ( uint ) (internal)"
.br
.ti -1c
.BI "void \fBclearWState\fR ( uint n ) (internal)"
.br
.ti -1c
.BI "WFlags \fBgetWFlags\fR () const"
.br
.ti -1c
.BI "virtual void \fBsetWFlags\fR ( WFlags ) "
.br
.ti -1c
.BI "void \fBclearWFlags\fR ( WFlags n ) "
.br
.ti -1c
.BI "virtual void \fBsetFRect\fR ( const QRect & ) (internal)"
.br
.ti -1c
.BI "virtual void \fBsetCRect\fR ( const QRect & ) (internal)"
.br
.ti -1c
.BI "virtual bool \fBfocusNextPrevChild\fR ( bool next ) "
.br
.ti -1c
.BI "QWExtra* \fBextraData\fR () (internal)"
.br
.ti -1c
.BI "QTLWExtra* \fBtopData\fR () (internal)"
.br
.ti -1c
.BI "QFocusData* \fBfocusData\fR () "
.br
.ti -1c
.BI "virtual void \fBsetKeyCompression\fR ( bool ) "
.br
.ti -1c
.BI "virtual void \fBsetMicroFocusHint\fR ( int " "x" ", int " "y" ", int " "w" ", int " "h" ", bool " "text" "=TRUE ) "
.br
.in -1c
.SS "Properties"
.nf
.TS
l l l l l
- - - - -
l l l l l.
Type	Name	READ	WRITE	Options
bool	isTopLevel	isTopLevel
bool	isModal	isModal
bool	isPopup	isPopup
bool	isDesktop	isDesktop
bool	enabled	isEnabled	setEnabled
QRect	geometry	geometry	setGeometry
QRect	frameGeometry	frameGeometry
int	x	x
int	y	y
QPoint	pos	pos
QSize	frameSize	frameSize
QSize	size	size	resize	DESIGNABLE false
int	width	width
int	height	height
QRect	rect	rect
QRect	childrenRect	childrenRect
QRegion	childrenRegion	childrenRegion
QSizePolicy	sizePolicy	sizePolicy	setSizePolicy
QSize	minimumSize	minimumSize	setMinimumSize
QSize	maximumSize	maximumSize	setMaximumSize
int	minimumWidth	minimumWidth	setMinimumWidth	STORED false
int	minimumHeight	minimumHeight	setMinimumHeight	STORED false
int	maximumWidth	maximumWidth	setMaximumWidth	STORED false
int	maximumHeight	maximumHeight	setMaximumHeight	STORED false
QSize	sizeIncrement	sizeIncrement	setSizeIncrement
QSize	baseSize	baseSize	setBaseSize
BackgroundMode	backgroundMode	backgroundMode	setBackgroundMode	DESIGNABLE false
QColor	backgroundColor	backgroundColor	setBackgroundColor	DESIGNABLE false
QColor	foregroundColor	foregroundColor
QPixmap	backgroundPixmap	backgroundPixmap	setBackgroundPixmap	DESIGNABLE false
QColorGroup	colorGroup	colorGroup
QPalette	palette	palette	setPalette	RESET unsetPalette
bool	ownPalette	ownPalette
QFont	font	font	setFont	RESET unsetFont
bool	ownFont	ownFont
QCursor	cursor	cursor	setCursor	RESET unsetCursor
bool	ownCursor	ownCursor
QString	caption	caption	setCaption
QPixmap	icon	icon	setIcon
QString	iconText	iconText	setIconText
bool	mouseTracking	hasMouseTracking	setMouseTracking
bool	isActiveWindow	isActiveWindow
bool	focusEnabled	isFocusEnabled
FocusPolicy	focusPolicy	focusPolicy	setFocusPolicy
bool	focus	hasFocus
bool	updatesEnabled	isUpdatesEnabled	setUpdatesEnabled	DESIGNABLE false
bool	visible	isVisible
QRect	visibleRect	visibleRect
bool	hidden	isHidden
bool	minimized	isMinimized
QSize	sizeHint	sizeHint
QSize	minimumSizeHint	minimumSizeHint
QRect	microFocusHint	microFocusHint
bool	acceptDrops	acceptDrops	setAcceptDrops
bool	autoMask	autoMask	setAutoMask
BackgroundOrigin	backgroundOrigin	backgroundOrigin	setBackgroundOrigin
bool	customWhatsThis	customWhatsThis
.TE
.fi

.SH DESCRIPTION
The QWidget class is the base class of all user interface objects.
.PP
The widget is the atom of the user interface: It receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.
.PP
A widget that isn't embedded in a parent widget is called a top-level widget. Usually, top-level widgets are windows with a frame and a title bar (though it is also possible to create top level widgets without such decoration by the use of widget flags). In Qt, QMainWindow and the various subclasses of QDialog are the most common top-level windows.
.PP
A widget without a parent widget is always a top-level widget.
.PP
The opposite of top-level widgets are child widgets. Those are child windows in their parent widgets. You usually cannot distinguish a child widget from its parent visually. Most other widgets in Qt are useful only as child widgets. (You \fIcan\fR make a e.g. button into a top-level widget, but most people prefer to put their buttons in e.g. dialogs.)
.PP
QWidget has many member functions, but some of them have little direct functionality - for example it has a font but never uses it itself. There are many subclasses which provide real functionality, as diverse as QPushButton, QListBox and QTabDialog.
.PP
\fBGroups of functions:\fR
.TP
Window functions: show(), hide(), raise(), lower(), close().
.TP
Top level windows: caption(), setCaption(), icon(), setIcon(), iconText(), setIconText(), isActiveWindow(), setActiveWindow(), showMinimized(). showMaximized(), showFullScreen(), showNormal().
.TP
Window contents: update(), repaint(), erase(), scroll(), updateMask().
.TP
Geometry: pos(), size(), rect(), x(), y(), width(), height(), sizePolicy(), setSizePolicy(), sizeHint(), updateGeometry(), layout(), move(), resize(), setGeometry(), frameGeometry(), geometry(), childrenRect(), adjustSize(), mapFromGlobal(), mapFromParent() mapToGlobal(), mapToParent(), maximumSize(), minimumSize(), sizeIncrement(), setMaximumSize(), setMinimumSize(), setSizeIncrement(), setBaseSize(), setFixedSize()
.TP
Mode: isVisible(), isVisibleTo(), visibleRect(), isMinimized(), isDesktop(), isEnabled(), isEnabledTo(), isModal(), isPopup(), isTopLevel(), setEnabled(), hasMouseTracking(), setMouseTracking(), isUpdatesEnabled(), setUpdatesEnabled(),
.TP
Look and feel: style(), setStyle(), cursor(), setCursor() font(), setFont(), palette(), setPalette(), backgroundMode(), setBackgroundMode(), backgroundPixmap(), setBackgroundPixmap(), setTranslateBackground(), backgroundColor(), colorGroup(), fontMetrics(), fontInfo().
.TP
Keyboard focus functions: isFocusEnabled(), setFocusPolicy(), focusPolicy(), hasFocus(), setFocus(), clearFocus(), setTabOrder(), setFocusProxy().
.TP
Mouse and keyboard grabbing: grabMouse(), releaseMouse(), grabKeyboard(), releaseKeyboard(), mouseGrabber(), keyboardGrabber().
.TP
Event handlers: event(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), keyPressEvent(), keyReleaseEvent(), focusInEvent(), focusOutEvent(), wheelEvent(), enterEvent(), leaveEvent(), paintEvent(), moveEvent(), resizeEvent(), closeEvent(), dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(), childEvent(), showEvent(), hideEvent(), customEvent().
.TP
Change handlers: backgroundColorChange(), backgroundPixmapChange(), enabledChange(), fontChange(), paletteChange(), styleChange().
.TP
System functions: parentWidget(), topLevelWidget(), reparent(), polish(), winId(), find(), metric().
.TP
Internal kernel functions: setFRect(), setCRect(), focusNextPrevChild(), wmapper(), clearWFlags(), getWFlags(), setWFlags(), testWFlags().
.TP
What's this help: customWhatsThis()
.PP
Every widget's constructor accepts two or three standard arguments:
.TP
\fCQWidget *parent = 0\fR is the parent of the new widget. If it is 0 (the default), the new widget will be a top-level window. If not, it will be a child of \fIparent,\fR and be constrained by \fIparent's\fR geometry (Unless you specify \fCWType_TopLevel\fR as widget flag).
.TP
\fCconst char *name = 0\fR is the widget name of the new widget. You can access it using name(). The widget name is little used by programmers but is quite useful with GUI builders such as the Qt Designer (you can name a widget in the builder, and connect() to it by name in your code). The dumpObjectTree() debugging function also uses it.
.TP
\fCWFlags f = 0\fR (where available) sets the widget flags; the default is good for almost all widgets, but to get e.g. top-level widgets without a window system frame you must use special flags.
.PP
The tictac/tictac.cpp example program is good example of a simple widget. It contains a few event handlers (as all widgets must), a few custom routines that are peculiar to it (as all useful widgets must), and has a few children and connections. Everything it does is done in response to an event: This is by far the most common way to design GUI applications.
.PP
You will need to supply the content for your widgets yourself, but here is a brief run-down of the events, starting with the most common ones: 
.TP
paintEvent() - called whenever the widget needs to be repainted. Every widget which displays output must implement it, and it is sensible to \fInever\fR paint on the screen outside paintEvent().
.TP
resizeEvent() - called when the widget has been resized.
.TP
mousePressEvent() - called when a mouse button is pressed. There are six mouse-related events, mouse press and mouse release events are by far the most important. A widget receives mouse press events when the widget is inside it, or when it has grabbed the mouse using grabMouse().
.TP
mouseReleaseEvent() - called when a mouse button is released. A widget receives mouse release events when it has received the corresponding mouse press event. This means that if the user presses the mouse inside \fIyour\fR widget, then drags the mouse to somewhere else, then releases, \fIyour\fR widget receives the release event. There is one exception, however: If a popup menu appears while the mouse button is held down, that popup steals the mouse events at once.
.TP
mouseDoubleClickEvent() - not quite as obvious as it might seem. If the user double-clicks, the widget receives a mouse press event (perhaps a mouse move event or two if he/she does not hold the mouse quite steady), a mouse release event and finally this event. It is \fInot possible\fR to distinguish a click from a double click until you've seen whether the second click arrives. (This is one reason why most GUI books recommend that double clicks be an extension of single clicks, rather than trigger a different action.)
.PP
If your widget only contains child widgets, you probably do not need to implement any event handlers.
.PP
Widgets that accept keyboard input need to reimplement a few more event handlers: 
.TP
keyPressEvent() - called whenever a key is pressed, and again when a key has been held down long enough for it to auto-repeat. Note that the Tab and shift-Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().
.TP
focusInEvent() - called when the widget gains keyboard focus (assuming you have called setFocusPolicy(), of course). Well written widgets indicate that they own the keyboard focus in a clear but discreet way.
.TP
focusOutEvent() - called when the widget loses keyboard focus.
.PP
Some widgets will need to reimplement some more obscure event handlers, too: 
.TP
mouseMoveEvent() - called whenever the mouse moves while a button is held down. This is useful for e.g. dragging. If you call setMouseTracking(TRUE), you get mouse move events even when no buttons are held down. (Note that applications which make use of mouse tracking are often not very useful on low-bandwidth X connections.)
.TP
keyReleaseEvent() - called whenever a key is released, and also while it is held down if the key is auto-repeating. In that case the widget receives a key release event and immediately a key press event for every repeat. Note that the Tab and shift-Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement QWidget::event().
.TP
wheelEvent() -- called whenever the user turns the mouse wheel while the widget has the focus.
.TP
enterEvent() - called when the mouse enters the widget's screen space. (This excludes screen space owned by any children of the widget.)
.TP
leaveEvent() - called when the mouse leaves the widget's screen space.
.TP
moveEvent() - called when the widget has been moved relative to its parent.
.TP
closeEvent() - called when the user closes the widget (or when close() is called).
.PP
There are also some \fIreally\fR obscure events. They are listed in qevent.h and you need to reimplement event() to handle them. The default implementation of event() handles Tab and shift-Tab (to move the keyboard focus), and passes on most other events to one of the more specialized handlers above.
.PP
When writing a widget, there are a few more things to look out for. 
.TP
In the constructor, be sure to set up your member variables early on, before there's any chance that you might receive an event.
.TP
It is almost always useful to reimplement sizeHint() and to set the correct size policy with setSizePolicy(), so users of your class can set up layout management more easily. A size policy lets you supply good defaults for the layout management handling, so that other widgets can contain and manage yours easily. sizeHint() indicates a "good" size for the widget.
.TP
If your widget is a top-level window, setCaption() and setIcon() set the title bar and icon respectively.
.IP
.PP
See also QEvent, QPainter, QGridLayout and QBoxLayout.
.PP
Examples:
.(l
iconview/main.cpp drawlines/connect.cpp mainlyQt/editor.cpp xform/xform.cpp layout/layout.cpp i18n/main.cpp popup/popup.cpp menu/menu.cpp progress/progress.cpp qmag/qmag.cpp splitter/splitter.cpp forever/forever.cpp desktop/desktop.cpp scrollview/scrollview.cpp customlayout/main.cpp
.)l
.SS "Member Type Documentation"
.SH "QWidget::BackgroundMode"
This enum describes how the background of a widget changes, as the widget's palette changes.
.PP
The background is what the widget contains when paintEvent() is called. To minimize flicker, this should be the most common color or pixmap in the widget. For \fCPaletteBackground,\fR use colorGroup().brush( \fCQColorGroup::Background\fR ), and so on. There are also three special values, listed at the end: 
.TP
\fCPaletteForeground\fR
.TP
\fCPaletteBackground\fR
.TP
\fCPaletteButton\fR
.TP
\fCPaletteLight\fR
.TP
\fCPaletteMidlight\fR
.TP
\fCPaletteDark\fR
.TP
\fCPaletteMid\fR
.TP
\fCPaletteText\fR
.TP
\fCPaletteBrightText\fR
.TP
\fCPaletteButtonText\fR
.TP
\fCPaletteBase\fR
.TP
\fCPaletteShadow\fR
.TP
\fCPaletteHighlight\fR
.TP
\fCPaletteHighlightedText\fR
.TP
\fCNoBackground\fR - the widget is not cleared before paintEvent(). If the widget's paint event always draws on all the pixels, using this mode can be both fast and flicker-free.
.TP
\fCFixedColor\fR - the widget is cleared to a fixed color, normally different from all the ones in the palette(). Set using setBackgroundColor().
.TP
\fCFixedPixmap\fR - the widget is cleared to a fixed pixmap, normally different from all the ones in the palette(). Set using setBackgroundPixmap().
.IP
.PP
\fCFixedColor\fR and \fCFixedPixmap\fR sometimes are just the right thing, but if you use them, make sure that your application looks right when the desktop color scheme has been changed. (On X11, a quick way to test is e.g. "./yourapp -bg paleblue". On Windows, you have to use the control panel.)
.PP
See also setBackgroundMode(), backgroundMode(), setBackgroundPixmap() and setBackgroundColor().
.SH "QWidget::BackgroundOrigin"
This enum defines the origin used to draw a widget's background pixmap.
.TP
\fCWidgetOrigin\fR - the pixmap is drawn in the widget's coordinate system.
.TP
\fCParentOrigin\fR - the pixmap is drawn in the parent's coordinate system.
.SH "QWidget::FocusPolicy"
This enum type defines the various policies a widget can have with respect to acquiring keyboard focus.
.PP
The \fIpolicy\fR can be:
.TP
\fCQWidget::TabFocus\fR - the widget accepts focus by tabbing.
.TP
\fCQWidget::ClickFocus\fR - the widget accepts focus by clicking.
.TP
\fCQWidget::StrongFocus\fR - the widget accepts focus by both tabbing and clicking.
.TP
\fCQWidget::WheelFocus\fR - like StrongFocus plus the widget accepts focus by using the mouse wheel.
.TP
\fCQWidget::NoFocus\fR - the widget does not accept focus.
.SH "QWidget::PropagationMode"
\fBThis member is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
This enum used to determine how fonts and palette changes are propagated to children of a widget.
.SH MEMBER FUNCTION DOCUMENTATION
.SH "QWidget::QWidget ( QWidget * parent=0, const char * name=0, WFlags f=0 )"
Constructs a widget which is a child of \fIparent,\fR with the name \fIname\fR and widget flags set to \fIf.\fR
.PP
If \fIparent\fR is 0, the new widget becomes a top-level window. If \fIparent\fR is another widget, this widget becomes a child window inside \fIparent.\fR The new widget is deleted when \fIparent\fR is.
.PP
The \fIname\fR is sent to the QObject constructor.
.PP
The widget flags argument \fIf\fR is normally 0, but it can be set to customize the window frame of a top-level widget (i.e. \fIparent\fR must be zero). To customize the frame, set the \fCWStyle_Customize\fR flag OR'ed with any of the Qt::WidgetFlags.
.PP
Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.
.PP
Example:
.PP
.nf
.br
    QLabel *spashScreen = new QLabel( 0, "mySplashScreen",
.br
                                  WStyle_Customize | WStyle_NoBorder |
.br
                                  WStyle_Tool );
.fi
.SH "QWidget::~QWidget ()"
Destructs the widget.
.PP
All children of this widget are deleted first. The application exits if this widget is (was) the main widget.
.SH "bool QWidget::acceptDrops () const"
Returns TRUE if drop events are enabled for this widget.
.PP
See also setAcceptDrops().
.SH "void QWidget::adjustSize () \fC[virtual]\fR"
Adjusts the size of the widget to fit the contents.
.PP
Uses sizeHint() if valid (i.e if the size hint's width and height are equal to or greater than 0), otherwise sets the size to the children rectangle (the union of all child widget geometries).
.PP
See also sizeHint() and childrenRect().
.PP
Examples:
.(l
xform/xform.cpp
.)l
.PP
Reimplemented in QMessageBox.
.SH "bool QWidget::autoMask () const"
Returns whether or not the widget has the auto mask feature enabled.
.PP
See also setAutoMask(), updateMask(), setMask() and clearMask().
.SH "const QColor & QWidget::backgroundColor () const"
Returns the background color of this widget, which is normally set implicitly by setBackgroundMode(), but can also be set explicitly by setBackgroundColor().
.PP
If there is a background pixmap (set using setBackgroundPixmap()), then the return value of this function is indeterminate.
.PP
See also setBackgroundColor(), foregroundColor(), colorGroup() and palette().
.PP
Examples:
.(l
grapher/grapher.cpp xform/xform.cpp
.)l
.SH "void QWidget::backgroundColorChange ( const QColor & oldBackgroundColor ) \fC[virtual protected]\fR"
This virtual function is called from setBackgroundColor(). \fIoldBackgroundColor\fR is the previous background color; you can get the new background color from backgroundColor().
.PP
Reimplement this function if your widget needs to know when its background color changes. You will almost certainly need to call this implementation of the function.
.PP
See also setBackgroundColor(), backgroundColor(), setPalette(), repaint() and update().
.SH "QWidget::BackgroundMode QWidget::backgroundMode() const"
Returns the mode most recently set by setBackgroundMode(). The default is PaletteBackground.
.PP
See also BackgroundMode and setBackgroundMode().
.SH "QWidget::BackgroundOrigin QWidget::backgroundOrigin() const"
Returns the current background origin.
.PP
See also setBackgroundOrigin().
.SH "const QPixmap * QWidget::backgroundPixmap () const"
Returns the background pixmap if one has been set. If the widget has backgroundMode() NoBackground, the return value is a pixmap for which QPixmao:isNull() is true. If the widget has no pixmap is the background, the return value is a null pointer.
.PP
See also setBackgroundPixmap() and setBackgroundMode().
.SH "void QWidget::backgroundPixmapChange ( const QPixmap & oldBackgroundPixmap ) \fC[virtual protected]\fR"
This virtual function is called from setBackgroundPixmap(). \fIoldBackgroundPixmap\fR is the previous background pixmap; you can get the new background pixmap from backgroundPixmap().
.PP
Reimplement this function if your widget needs to know when its background pixmap changes. You will almost certainly need to call this implementation of the function.
.PP
See also setBackgroundPixmap(), backgroundPixmap(), repaint() and update().
.SH "QSize QWidget::baseSize () const"
Returns the widget base size
.PP
The base size is used to calculate a proper widget size in case the widget defines sizeIncrement().
.PP
See also setBaseSize() and setSizeIncrement().
.SH "QString QWidget::caption () const"
Returns the widget caption. If no caption has been set (common for child widgets), this functions returns a null string.
.PP
See also setCaption(), icon(), iconText() and QString::isNull().
.PP
Examples:
.(l
i18n/main.cpp
.)l
.SH "QRect QWidget::childrenRect () const"
Returns the bounding rectangle of the widget's children.
.PP
Explicitely hidden children are excluded.
.PP
See also childrenRegion().
.SH "QRegion QWidget::childrenRegion () const"
Returns the combined region of the widget's children geometry().
.PP
Explicitely hidden children are excluded.
.PP
See also childrenRect().
.SH "void QWidget::clearFocus () \fC[slot]\fR"
Takes keyboard input focus from the widget.
.PP
If the widget has active focus, a focus out event is sent to this widget to tell it that it is about to lose the focus.
.PP
This widget must enable focus setting in order to get the keyboard input focus, i.e. it must call setFocusPolicy().
.PP
See also hasFocus(), setFocus(), focusInEvent(), focusOutEvent(), setFocusPolicy() and QApplication::focusWidget().
.SH "void QWidget::clearMask ()"
Removes any mask set by setMask().
.PP
See also setMask().
.SH "void QWidget::clearWFlags ( WFlags f ) \fC[protected]\fR"
Clears the widget flags \fIf.\fR
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also testWFlags(), getWFlags() and setWFlags().
.SH "bool QWidget::close () \fC[slot]\fR"
Closes this widget. Returns TRUE if the widget was closed, otherwise FALSE.
.PP
First it sends the widget a QCloseEvent. The widget is hidden if it accepts the close event. The default implementation of QWidget::closeEvent() accepts the close event.
.PP
The QApplication::lastWindowClosed() signal is emitted when the last visible top level widget is closed.
.PP
See also close(bool).
.PP
Examples:
.(l
popup/popup.cpp
.)l
.SH "bool QWidget::close ( bool alsoDelete ) \fC[virtual]\fR"
Closes this widget. Returns TRUE if the widget was closed, otherwise FALSE.
.PP
If \fIalsoDelete\fR is TRUE or the widget has the \fCWDestructiveClose\fR widget flag, the widget is also deleted. The widget can prevent itself from being closed by rejecting the QCloseEvent it gets.
.PP
The QApplication::lastWindowClosed() signal is emitted when the last visible top level widget is closed.
.PP
Note that closing the QApplication::mainWidget() terminates the application.
.PP
See also closeEvent(), QCloseEvent, hide(), QApplication::quit(), QApplication::setMainWidget() and QApplication::lastWindowClosed().
.SH "void QWidget::closeEvent ( QCloseEvent * e ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget close events.
.PP
The default implementation calls e->accept(), which hides this widget. See the QCloseEvent documentation for more details.
.PP
See also event(), hide(), close() and QCloseEvent.
.PP
Reimplemented in QDialog, QPopupMenu and QProgressDialog.
.SH "const QColorGroup & QWidget::colorGroup () const"
Returns the current color group of the widget palette.
.PP
The color group is determined by the state of the widget.
.PP
A disabled widget returns the QPalette::disabled() color group, a widget in the window with keyboard focus returns the QPalette::active() color group, and all inactive widgets return the QPalette::inactive() color group.
.PP
See also palette() and setPalette().
.SH "void QWidget::constPolish () const \fC[slot]\fR"
Ensures that the widget is properly initialized by calling polish().
.PP
Call constPolish() from functions like sizeHint() that depends on the widget being initialized, and that may be called before show().
.PP
\fBWarning:\fR Do not call constPolish() on a widget from inside that widget's constructor.
.PP
See also polish().
.SH "void QWidget::create ( WId window = 0, bool initializeWindow = TRUE, bool destroyOldWindow = TRUE ) \fC[virtual protected]\fR"
Creates a new widget window if \fIwindow\fR is null, otherwise sets the widget's window to \fIwindow.\fR
.PP
Initializes the window (sets the geometry etc.) if \fIinitializeWindow\fR is TRUE. If \fIinitializeWindow\fR is FALSE, no initialization is performed. This parameter makes only sense if \fIwindow\fR is a valid window.
.PP
Destroys the old window if \fIdestroyOldWindow\fR is TRUE. If \fIdestroyOldWindow\fR is FALSE, you are responsible for destroying the window yourself (using platform native code).
.PP
The QWidget constructor calls create(0,TRUE,TRUE) to create a window for this widget.
.SH "const QCursor & QWidget::cursor () const"
Returns the widget cursor. If no cursor has been set the parent widget's cursor is returned.
.PP
See also setCursor() and unsetCursor();.
.SH "void QWidget::customEvent ( QCustomEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the "User" item of the QEvent::Type enum, and is typically a QCustomEvent or QCustomEvent subclass.
.PP
See also event() and QCustomEvent.
.SH "bool QWidget::customWhatsThis () const \fC[virtual]\fR"
Returns whether the widget wants to handle What's This help manually. The default implementation returns FALSE, which means the widget will not receive any events in Whats This mode.
.PP
The widget may leave Whats This mode by calling QWhatsThis::leaveWhatsThisMode(), with or without actually displaying any help text.
.PP
You may also reimplement customWhatsThis() if your widget is a so-called "passive interactor" that is supposed to work under all circumstances. Simply don't call QWhatsThis::leaveWhatsThisMode() in that case.
.PP
See also QWhatsThis::inWhatsThisMode() and QWhatsThis::leaveWhatsThisMode().
.PP
Reimplemented in QPopupMenu and QMenuBar.
.SH "void QWidget::destroy ( bool destroyWindow = TRUE, bool destroySubWindows = TRUE ) \fC[virtual protected]\fR"
Frees up window system resources. Destroys the widget window if \fIdestroyWindow\fR is TRUE.
.PP
destroy() calls itself recursively for all the child widgets, passing \fIdestroySubWindows\fR for the \fIdestroyWindow\fR parameter. To have more control over destruction of subwidgets, destroy subwidgets selectively first.
.PP
This function is usually called from the QWidget destructor.
.SH "void QWidget::dragEnterEvent ( QDragEnterEvent * ) \fC[virtual protected]\fR"
This event handler is called when a drag is in progress and the mouse enters this widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag and QDragEnterEvent.
.PP
Reimplemented in QMultiLineEdit and QLineEdit.
.SH "void QWidget::dragLeaveEvent ( QDragLeaveEvent * ) \fC[virtual protected]\fR"
This event handler is called when a drag is in progress and the mouse leaves this widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag and QDragLeaveEvent.
.PP
Reimplemented in QMultiLineEdit.
.SH "void QWidget::dragMoveEvent ( QDragMoveEvent * ) \fC[virtual protected]\fR"
This event handler is called when a drag is in progress and the mouse enters this widget, and whenever it moves within the widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag and QDragMoveEvent.
.PP
Reimplemented in QMultiLineEdit.
.SH "void QWidget::drawText ( int x, int y, const QString & str )"
Writes \fIstr\fR at position \fIx,y.\fR
.PP
The \fIy\fR position is the base line position of the text. The text is drawn using the default font and the default foreground color.
.PP
This function is provided for convenience. You will generally get more flexible results and often higher speed by using a a painter instead.
.PP
See also setFont(), foregroundColor() and QPainter::drawText().
.SH "void QWidget::drawText ( const QPoint & pos, const QString & str )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::dropEvent ( QDropEvent * ) \fC[virtual protected]\fR"
This event handler is called when the drag is dropped on this widget.
.PP
See the Drag-and-drop documentation for an overview of how to provide drag-and-drop in your application.
.PP
See also QTextDrag, QImageDrag and QDropEvent.
.PP
Reimplemented in QMultiLineEdit and QLineEdit.
.SH "void QWidget::enabledChange ( bool oldEnabled ) \fC[virtual protected]\fR"
This virtual function is called from setEnabled(). \fIoldEnabled\fR is the previous setting; you can get the new setting from isEnabled().
.PP
Reimplement this function if your widget needs to know when it becomes enabled or disabled. You will almost certainly need to update the widget using update().
.PP
The default implementation repaints the visible part of the widget.
.PP
See also setEnabled(), isEnabled(), repaint(), update() and visibleRect().
.PP
Reimplemented in QListView and QButton.
.SH "void QWidget::enterEvent ( QEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget enter events.
.PP
An event is sent to the widget when the mouse cursor enters the widget.
.PP
See also leaveEvent(), mouseMoveEvent() and event().
.PP
Reimplemented in QToolButton.
.SH "void QWidget::erase ( const QRegion & reg )"
Erases the area defined by \fIreg,\fR without generating a paint event.
.PP
Child widgets are not affected.
.PP
Examples:
.(l
drawlines/connect.cpp
.)l
.SH "void QWidget::erase ( int x, int y, int w, int h )"
Erases the specified area \fI(x,y,w,h)\fR in the widget without generating a paint event.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR. If \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
Child widgets are not affected.
.PP
See also repaint().
.SH "void QWidget::erase ()"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version erases the entire widget.
.SH "void QWidget::erase ( const QRect & r )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "bool QWidget::event ( QEvent * e ) \fC[virtual protected]\fR"
This is the main event handler. You may reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.
.PP
The main event handler first passes an event through all event filters that have been installed. If none of the filters intercept the event, it calls one of the specialized event handlers.
.PP
Key press/release events are treated differently from other events. event() checks for Tab and shift-Tab and tries to move the focus appropriately. If there is no widget to move the focus to (or the key press is not Tab or shift-Tab), event() calls keyPressEvent().
.PP
This function returns TRUE if it is able to pass the event over to someone, or FALSE if nobody wanted the event.
.PP
See also closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(), keyPressEvent(), keyReleaseEvent(), leaveEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(), mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(), QObject::event() and QObject::timerEvent().
.PP
Reimplemented from QObject.
.SH "QWidget * QWidget::find ( WId id ) \fC[static]\fR"
Returns a pointer to the widget with window identifer/handle \fIid.\fR
.PP
The window identifier type depends by the underlying window system, see qwindowdefs.h for the actual definition. If there is no widget with this identifier, a null pointer is returned.
.PP
See also wmapper() and winId().
.SH "QFocusData * QWidget::focusData () \fC[protected]\fR"
Returns a pointer to the focus data for this widget's top-level widget.
.PP
Focus data always belongs to the top-level widget. The focus data list contains all the widgets in this top-level widget that can accept focus, in tab order. An iterator points to the current focus widget (focusWidget() returns a pointer to this widget).
.PP
This information is useful for implementing advanced versions of focusNextPrevChild().
.SH "void QWidget::focusInEvent ( QFocusEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive keyboard focus events (focus received) for the widget.
.PP
A widget normally must setFocusPolicy() to something other than NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)
.PP
The default implementation updates the widget if it accepts focus (see focusPolicy()). It also calls setMicroFocusHint(), hinting any system-specific input tools about the focus of the user's attention.
.PP
See also focusOutEvent(), setFocusPolicy(), keyPressEvent(), keyReleaseEvent(), event() and QFocusEvent.
.PP
Reimplemented in QLineEdit, QDial, QTable, QMenuBar, QRadioButton, QListBox, QTabBar, QListView, QPushButton, QButton, QGroupBox, QComboBox, QPopupMenu, QTextView, QSlider and QMultiLineEdit.
.SH "bool QWidget::focusNextPrevChild ( bool next ) \fC[virtual protected]\fR"
Finds a new widget to give the keyboard focus to, as appropriate for Tab/shift-Tab, and returns TRUE if is can find a new widget and FALSE if it can't,
.PP
If \fInext\fR is true, this function searches "forwards", if \fInext\fR is FALSE, "backwards".
.PP
Sometimes, you will want to reimplement this function. For example, a web browser might reimplement it to move its "current active link" forwards or backwards, and call QWidget::focusNextPrevChild() only when it reaches the last/first.
.PP
Child widgets call focusNextPrevChild() on their parent widgets, and only the top-level widget will thus make the choice of where to redirect focus. By overriding this method for an object, you thus gain control of focus traversal for all child widgets.
.PP
See also focusData().
.PP
Reimplemented in QMultiLineEdit, QScrollView, QPopupMenu and QButton.
.SH "void QWidget::focusOutEvent ( QFocusEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive keyboard focus events (focus lost) for the widget.
.PP
A widget normally must setFocusPolicy() to something other than NoFocus in order to receive focus events. (Note that the application programmer can call setFocus() on any widget, even those that do not normally accept focus.)
.PP
The default implementation calls repaint() since the widget's colorGroup() changes from active to normal, so the widget probably needs repainting. It also calls setMicroFocusHint(), hinting any system-specific input tools about the focus of the user's attention.
.PP
See also focusInEvent(), setFocusPolicy(), keyPressEvent(), keyReleaseEvent(), event() and QFocusEvent.
.PP
Reimplemented in QTable, QListBox, QTextView, QLineEdit, QListView, QButton, QSlider, QPushButton, QDial, QMultiLineEdit, QTabBar, QPopupMenu and QMenuBar.
.SH "QWidget::FocusPolicy QWidget::focusPolicy() const"
Returns \fCQWidget::TabFocus\fR if the widget accepts focus by tabbing, \fCQWidget::ClickFocus\fR if the widget accepts focus by clicking, \fCQWidget::StrongFocus\fR if it accepts both and \fCQWidget::NoFocus\fR if it does not accept focus at all.
.PP
See also isFocusEnabled(), setFocusPolicy(), focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent() and isEnabled().
.SH "QWidget * QWidget::focusProxy () const"
Returns a pointer to the focus proxy, or 0 if there is no focus proxy.
.PP
See also setFocusProxy().
.SH "QWidget * QWidget::focusWidget () const"
Returns the focus widget in this widget's window. This is not the same as QApplication::focusWidget(), which returns the focus widget in the currently active window.
.SH "QFont QWidget::font () const"
Returns the font currently set for the widget.
.PP
fontInfo() tells you what font is actually being used.
.PP
As long as no special font has been set, this is either a special font for the widget class, the parent's font or - if this widget is a toplevel widget - the default application font.
.PP
See also setFont(), fontInfo(), fontMetrics() and QApplication::font().
.PP
Examples:
.(l
grapher/grapher.cpp xform/xform.cpp menu/menu.cpp
.)l
.SH "void QWidget::fontChange ( const QFont & oldFont ) \fC[virtual protected]\fR"
This virtual function is called from setFont(). \fIoldFont\fR is the previous font; you can get the new font from font().
.PP
Reimplement this function if your widget needs to know when its font changes. You will almost certainly need to update the widget using update().
.PP
The default implementation updates the widget including its geometry.
.PP
See also setFont(), font(), update() and updateGeometry().
.PP
Reimplemented in QMenuBar, QGroupBox and QLabel.
.SH "QFontInfo QWidget::fontInfo () const"
Returns the font info for the widget's current font. Equivalent to QFontInto(widget->font()).
.PP
See also font(), fontMetrics() and setFont().
.SH "QFontMetrics QWidget::fontMetrics () const"
Returns the font metrics for the widget's current font. Equivalent to QFontMetrics(widget->font()).
.PP
See also font(), fontInfo() and setFont().
.PP
Examples:
.(l
xform/xform.cpp drawdemo/drawdemo.cpp qmag/qmag.cpp
.)l
.SH "QWidget::PropagationMode QWidget::fontPropagation() const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
The return value is meaningless
.PP
See also setFontPropagation().
.SH "const QColor & QWidget::foregroundColor () const"
Returns the foreground color of this widget.
.PP
The foreground color is also accessible as colorGroup().foreground().
.PP
See also backgroundColor() and colorGroup().
.SH "QRect QWidget::frameGeometry () const"
Returns the geometry of the widget, relative to its parent and including the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also geometry(), x(), y() and pos().
.SH "QSize QWidget::frameSize () const"
Returns the size of the window system frame (for top level widgets).
.SH "const QRect & QWidget::geometry () const"
Returns the geometry of the widget, relative to its parent widget and excluding the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also frameGeometry(), size() and rect().
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "WFlags QWidget::getWFlags () const \fC[protected]\fR"
Returns the widget flags for this this widget.
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also testWFlags(), setWFlags() and clearWFlags().
.SH "void QWidget::grabKeyboard ()"
Grabs all keyboard input.
.PP
This widget will receive all keyboard events, independent of the active window.
.PP
\fBWarning:\fR Grabbing the keyboard might lock the terminal.
.PP
See also releaseKeyboard(), grabMouse() and releaseMouse().
.SH "void QWidget::grabMouse ()"
Grabs the mouse input.
.PP
This widget will be the only one to receive mouse events until releaseMouse() is called.
.PP
\fBWarning:\fR Grabbing the mouse might lock the terminal.
.PP
It is almost never necessary to grab the mouse when using Qt since Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a button is pressed and keeps it until the last button is released.
.PP
Beware that only widgets actually shown on the screen may grab the mouse input.
.PP
See also releaseMouse(), grabKeyboard() and releaseKeyboard().
.SH "void QWidget::grabMouse ( const QCursor & cursor )"
Grabs the mouse input and changes the cursor shape.
.PP
The cursor will assume shape \fIcursor\fR (for as long as the mouse focus is grabbed) and this widget will be the only one to receive mouse events until releaseMouse() is called().
.PP
\fBWarning:\fR Grabbing the mouse might lock the terminal.
.PP
See also releaseMouse(), grabKeyboard(), releaseKeyboard() and setCursor().
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "bool QWidget::hasFocus () const"
Returns TRUE if this widget (or its focus proxy) has the keyboard input focus, otherwise FALSE.
.PP
Equivalent to \fCqApp->focusWidget() == this\fR.
.PP
See also setFocus(), clearFocus(), setFocusPolicy() and QApplication::focusWidget().
.SH "bool QWidget::hasMouseTracking () const"
Returns TRUE if mouse tracking is enabled for this widget, or FALSE if mouse tracking is disabled.
.PP
See also setMouseTracking().
.SH "int QWidget::height () const"
Returns the height of the widget, excluding the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also geometry(), width() and size().
.PP
Examples:
.(l
grapher/grapher.cpp xform/xform.cpp drawdemo/drawdemo.cpp qmag/qmag.cpp
.)l
.SH "int QWidget::heightForWidth ( int w ) const \fC[virtual]\fR"
Returns the preferred height for this widget, given the width \fIw.\fR The default implementation returns 0, indicating that the preferred height does not depend on the width.
.PP
\fBWarning:\fR Does not look at the widget's layout.
.PP
Reimplemented in QMenuBar, QTextView and QLabel.
.SH "void QWidget::hide () \fC[virtual slot]\fR"
Hides the widget.
.PP
You almost never have to reimplement this function. If you need to do something after a widget is hidden, use hideEvent() instead.
.PP
See also isHhideEvent(), isHidden(), show(), showMinimized(), isVisible() and close().
.PP
Examples:
.(l
xform/xform.cpp popup/popup.cpp progress/progress.cpp scrollview/scrollview.cpp
.)l
.PP
Reimplemented in QToolBar, QDialog, QPopupMenu and QMenuBar.
.SH "void QWidget::hideEvent ( QHideEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget hide events.
.PP
Hide events are sent to widgets right after they have been hidden.
.PP
See also event() and QHideEvent.
.SH "const QPixmap * QWidget::icon () const"
Returns the widget icon pixmap, or null if no icon has been set.
.PP
See also setIcon(), iconText() and caption().
.SH "QString QWidget::iconText () const"
Returns the widget icon text. If no icon text has been set (common for child widgets), this functions returns a null string.
.PP
See also setIconText(), icon(), caption() and QString::isNull().
.SH "bool QWidget::isActiveWindow () const"
Returns TRUE if this widget is in the active window, i.e. the window that has keyboard focus.
.PP
When popup windows are visible, this function returns TRUE for both the active window and the popup.
.PP
See also setActiveWindow() and QApplication::activeWindow().
.SH "bool QWidget::isDesktop () const"
Returns TRUE if the widget is a desktop widget, otherwise FALSE.
.PP
A desktop widget is also a top-level widget.
.PP
See also isTopLevel() and QApplication::desktop().
.SH "bool QWidget::isEnabled () const"
Returns TRUE if the widget is enabled, or FALSE if it is disabled.
.PP
See also setEnabled().
.SH "bool QWidget::isEnabledTo ( QWidget * ancestor ) const"
Returns TRUE if this widget would become enabled if \fIancestor\fR is enabled.
.PP
This is the case if neither the widget itself nor every parent up to but excluding \fIancestor\fR has been explicitly disabled.
.PP
isEnabledTo(0) is equivalent to isEnabled().
.PP
See also setEnabled() and isEnabled().
.SH "bool QWidget::isEnabledToTLW () const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
This function is deprecated. It is equivalent to isEnabled()
.PP
See also setEnabled() and isEnabled().
.SH "bool QWidget::isFocusEnabled () const"
Returns TRUE if the widget accepts keyboard focus, or FALSE if it does not.
.PP
Keyboard focus is initially disabled (i.e. focusPolicy() == \fCQWidget::NoFocus).\fR
.PP
You must enable keyboard focus for a widget if it processes keyboard events. This is normally done from the widget's constructor. For instance, the QLineEdit constructor calls setFocusPolicy(\fCQWidget::StrongFocus).\fR
.PP
See also setFocusPolicy(), focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent() and isEnabled().
.SH "bool QWidget::isHidden () const"
Returns TRUE if the widget is explicitly hidden, or FALSE if it is visible or would become visible if all its ancestors became visible.
.PP
See also hide(), show(), isVisible() and isVisibleTo().
.SH "bool QWidget::isMaximized () const"
Returns TRUE if this widget is a top-level widget that is maximized, or else FALSE.
.PP
Note that due to limitations in some window-systems, this does not always report expected results (eg. if the user on X11 maximizes the window via the window manager, Qt has no way of telling this from any other resize). This will improve as window manager protocols advance.
.PP
See also showMaximized().
.SH "bool QWidget::isMinimized () const"
Returns TRUE if this widget is a top-level widget that is minimized (iconified), or else FALSE.
.PP
See also showMinimized(), isVisible(), show(), hide() and showNormal().
.SH "bool QWidget::isModal () const"
Returns TRUE if the widget is a modal widget, otherwise FALSE.
.PP
A modal widget is also a top-level widget.
.PP
See also isTopLevel() and QDialog.
.SH "bool QWidget::isPopup () const"
Returns TRUE if the widget is a popup widget, otherwise FALSE.
.PP
A popup widget is created by specifying the widget flag \fCWType_Popup\fR to the widget constructor.
.PP
A popup widget is also a top-level widget.
.PP
See also isTopLevel().
.SH "bool QWidget::isTopLevel () const"
Returns TRUE if the widget is a top-level widget, otherwise FALSE.
.PP
A top-level widget is a widget which usually has a frame and a caption (title bar). Popup and desktop widgets are also top-level widgets.
.PP
A top-level widgets can have a parent widget. It will then be grouped with its parent: deleted when the parent is deleted, minimized when the parent is minimized etc. If supported by the window manager, it will also have a common taskbar entry with its parent.
.PP
QDialog and QMainWindow widgets are by default top-level, even if a parent widget is specified in the constructor. This behavior is specified by the \fCWType_TopLevel\fR widget flag.
.PP
Child widgets are the opposite of top-level widgets.
.PP
See also topLevelWidget(), isModal(), isPopup(), isDesktop() and parentWidget().
.SH "bool QWidget::isUpdatesEnabled () const"
Returns TRUE if updates are enabled, otherwise FALSE.
.PP
See also setUpdatesEnabled().
.SH "bool QWidget::isVisible () const"
Returns TRUE if the widget itself is visible, or else FALSE.
.PP
Calling show() sets the widget to visible status if all its parent widgets up to the toplevel widget are visible. If an ancestor is not visible, the widget won't become visible until all its ancestors are shown.
.PP
Calling hide() hides a widget explicitly. An explicitly hidden widget will never become visible, even if all its ancestors become visible.
.PP
Iconified top-level widgets also have hidden status, as well as having isMinimized() return TRUE. Windows that live on another virtual desktop (on platforms that support this concept) also have hidden status.
.PP
This function returns TRUE if the widget currently is obscured by other windows on the screen, but would be visible if moved.
.PP
A widget receives show- and hide events when its visibility status changes. Between a hide and a show event, there is no need in wasting any CPU on preparing or displaying information to the user. A video application, for example, might simply stop generating new frames.
.PP
See also show(), hide(), isHidden(), isVisibleTo(), isMinimized(), showEvent() and hideEvent().
.SH "bool QWidget::isVisibleTo ( QWidget * ancestor ) const"
Returns TRUE if this widget would become visible if \fIancestor\fR is shown.
.PP
This is the case if neither the widget itself nor every parent up to but excluding \fIancestor\fR has been explicitly hidden.
.PP
This function returns TRUE if the widget it is obscured by other windows on the screen, but would be visible if moved.
.PP
isVisibleTo(0) is very similar to isVisible(), with the exception that it does not cover the iconfied-case or the situation where the window lives on another virtual desktop.
.PP
See also show(), hide() and isVisible().
.SH "bool QWidget::isVisibleToTLW () const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
This function is deprecated. It is equivalent to isVisible()
.PP
See also show(), hide() and isVisible().
.SH "void QWidget::keyPressEvent ( QKeyEvent * e ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive key press events for the widget.
.PP
A widget must call setFocusPolicy() to accept focus initially and have focus in order to receive a key press event.
.PP
If you reimplement this handler, it is very important that you ignore() the event if you do not understand it, so that the widget's parent can interpret it.
.PP
The default implementation closes popup widgets if you hit escape. Otherwise the event is ignored.
.PP
See also keyReleaseEvent(), QKeyEvent::ignore(), setFocusPolicy(), focusInEvent(), focusOutEvent(), event() and QKeyEvent.
.PP
Reimplemented in QTabBar, QPopupMenu, QButton, QFileDialog, QTextBrowser, QLineEdit, QDialog, QTable, QTextView, QDial, QMessageBox, QListBox, QMenuBar, QSlider, QListView, QMultiLineEdit, QScrollBar and QComboBox.
.SH "void QWidget::keyReleaseEvent ( QKeyEvent * e ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive key release events for the widget.
.PP
A widget must accept focus initially and have focus in order to receive a key release event.
.PP
If you reimplement this handler, it is very important that you ignore() the release if you do not understand it, so that the widget's parent can interpret it.
.PP
The default implementation ignores the event.
.PP
See also keyPressEvent(), QKeyEvent::ignore(), setFocusPolicy(), focusInEvent(), focusOutEvent(), event() and QKeyEvent.
.PP
Reimplemented in QButton.
.SH "QWidget * QWidget::keyboardGrabber () \fC[static]\fR"
Returns a pointer to the widget that is currently grabbing the keyboard input.
.PP
If no widget in this application is currently grabbing the keyboard, 0 is returned.
.PP
See also grabMouse() and mouseGrabber().
.SH "QLayout* QWidget::layout () const"
Returns a pointer to the layout engine that manages the geometry of this widget's children.
.PP
If the widget does not have a layout, layout() returns a null pointer.
.PP
See also sizePolicy().
.SH "void QWidget::leaveEvent ( QEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget leave events.
.PP
A leave event is sent to the widget when the mouse cursor leaves the widget.
.PP
See also enterEvent(), mouseMoveEvent() and event().
.PP
Reimplemented in QLineEdit, QSpinBox, QMenuBar, QToolButton and QMultiLineEdit.
.SH "void QWidget::lower () \fC[slot]\fR"
Lowers the widget to the bottom of the parent widget's stack.
.PP
If there are siblings of this widget that overlap it on the screen, this widget will be obscured by its siblings afterwards.
.PP
See also raise() and stackUnder().
.SH "QPoint QWidget::mapFrom ( QWidget * parent, const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR from the coordinate system of \fIparent\fR to this widget's coordinate system, which must be non-null and be a parent widget of this.
.PP
See also mapTo(), mapFromParent() and mapFromGlobal().
.SH "QPoint QWidget::mapFromGlobal ( const QPoint & pos ) const"
Translates the global screen coordinate \fIpos\fR to widget coordinates.
.PP
See also mapToGlobal(), mapFrom() and mapFromParent().
.SH "QPoint QWidget::mapFromParent ( const QPoint & pos ) const"
Translates the parent widget coordinate \fIpos\fR to widget coordinates.
.PP
Same as mapFromGlobal() if the widget has no parent.
.PP
See also mapToParent(), mapFrom() and mapFromGlobal().
.SH "QPoint QWidget::mapTo ( QWidget * parent, const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR to the coordinate system of \fIparent,\fR which must be non-null and be a parent widget of this.
.PP
See also mapFrom(), mapToParent() and mapToGlobal().
.SH "QPoint QWidget::mapToGlobal ( const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR to global screen coordinates. For example,
.PP
.nf
.br
 mapToGlobal(QPoint(0,0))
.fi
would give the global coordinates of the top-left pixel of the widget.
.PP
See also mapFromGlobal(), mapTo() and mapToParent().
.PP
Examples:
.(l
popup/popup.cpp
.)l
.SH "QPoint QWidget::mapToParent ( const QPoint & pos ) const"
Translates the widget coordinate \fIpos\fR to a coordinate in the parent widget.
.PP
Same as mapToGlobal() if the widget has no parent.
.PP
See also mapFromParent(), mapTo() and mapToGlobal().
.SH "int QWidget::maximumHeight () const"
Returns the widget's maximum height.
.PP
See also maximumSize() and maximumWidth().
.SH "QSize QWidget::maximumSize () const"
Returns the maximum widget size.
.PP
The widget cannot be resized to a larger size than the maximum widget size.
.PP
See also maximumWidth(), maximumHeight(), setMaximumSize(), minimumSize() and sizeIncrement().
.SH "int QWidget::maximumWidth () const"
Returns the widget's maximum width.
.PP
See also maximumSize() and maximumHeight().
.SH "int QWidget::metric ( int m ) const \fC[virtual protected]\fR"
Internal implementation of the virtual QPaintDevice::metric() function.
.PP
Use the QPaintDeviceMetrics class instead.
.PP
Reimplemented from QPaintDevice.
.SH "QRect QWidget::microFocusHint () const"
Returns the currently set micro focus hint for this widget.
.PP
See also setMicroFocusHint().
.SH "int QWidget::minimumHeight () const"
Returns the widget's minimum height.
.PP
See also minimumSize() and minimumWidth().
.SH "QSize QWidget::minimumSize () const"
Returns the minimum widget size.
.PP
The widget cannot be resized to a smaller size than the minimum widget size.
.PP
If the returned minimum size equals (0,0) then it means that there are no constraints on the minimum size. However, Qt does nevertheless not allow you to shrink widgets to less than 1 pixel width/height.
.PP
See also maximumWidth(), maximumHeight(), setMinimumSize(), maximumSize() and sizeIncrement().
.SH "QSize QWidget::minimumSizeHint () const \fC[virtual]\fR"
Returns a recommended minimum size for the widget, or an invalid size if no minimum size is recommended.
.PP
The default implementation returns an invalid size if there is no layout for this widget, the layout's minimum size otherwise.
.PP
See also QSize::isValid(), resize(), setMinimumSize() and sizePolicy().
.PP
Reimplemented in QLineEdit, QTabBar, QListBox, QDialog, QMainWindow, QLabel, QSplitter, QListView, QScrollView, QToolBar, QMenuBar, QTabWidget, QSlider, QDial, QProgressBar, QIconView, QWidgetStack and QMultiLineEdit.
.SH "int QWidget::minimumWidth () const"
Returns the widget's minimum width.
.PP
See also minimumSize() and minimumHeight().
.SH "void QWidget::mouseDoubleClickEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive mouse double click events for the widget.
.PP
The default implementation generates a normal mouse press event.
.PP
Note that the widgets gets a mousePressEvent() and a mouseReleaseEvent() before the mouseDoubleClickEvent().
.PP
See also mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), event() and QMouseEvent.
.PP
Reimplemented in QListBox, QMultiLineEdit, QComboBox and QLineEdit.
.SH "QWidget * QWidget::mouseGrabber () \fC[static]\fR"
Returns a pointer to the widget that is currently grabbing the mouse input.
.PP
If no widget in this application is currently grabbing the mouse, 0 is returned.
.PP
See also grabMouse() and keyboardGrabber().
.SH "void QWidget::mouseMoveEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive mouse move events for the widget.
.PP
If mouse tracking is switched off, mouse move events only occur if a mouse button is down while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is down.
.PP
QMouseEvent::pos() reports the position of the mouse cursor, relative to this widget. For press and release events, the position is usually the same as the position of the last mouse move event, but it might be different if the user moves and clicks the mouse fast. This is a feature of the underlying window system, not Qt.
.PP
See also setMouseTracking(), mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), event() and QMouseEvent.
.PP
Reimplemented in QMenuBar, QHeader, QPopupMenu, QLineEdit, QButton, QSlider, QDial, QSizeGrip, QListBox, QComboBox, QMultiLineEdit and QScrollBar.
.SH "void QWidget::mousePressEvent ( QMouseEvent * e ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive mouse press events for the widget.
.PP
If you create new widgets in the mousePressEvent() the mouseReleaseEvent() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.
.PP
The default implementation implements the closing of popup widgets when you click outside the window. For other widget types it does nothing.
.PP
See also mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), event() and QMouseEvent.
.PP
Reimplemented in QHeader, QScrollBar, QComboBox, QSlider, QPopupMenu, QListBox, QSizeGrip, QTabBar, QMultiLineEdit, QButton, QDial, QLineEdit and QMenuBar.
.SH "void QWidget::mouseReleaseEvent ( QMouseEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive mouse release events for the widget.
.PP
See also mouseReleaseEvent(), mouseDoubleClickEvent(), mouseMoveEvent(), event() and QMouseEvent.
.PP
Reimplemented in QScrollBar, QLineEdit, QDial, QListBox, QMultiLineEdit, QButton, QComboBox, QPopupMenu, QSlider, QMenuBar, QTabBar and QHeader.
.SH "void QWidget::move ( int x, int y ) \fC[virtual slot]\fR"
Moves the widget to the position \fI(x,y)\fR relative to the parent widget and including the window frame.
.PP
If the widget is visible, it receives a move event immediately. If the widget is not shown yet, it is guaranteed to receive an event before it actually becomes visible.
.PP
This function is virtual, and all other overloaded move() implementations call it.
.PP
\fBWarning:\fR If you call move() or setGeometry() from moveEvent(), you may see infinite recursion.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also pos(), resize(), setGeometry() and moveEvent().
.PP
Examples:
.(l
drawdemo/drawdemo.cpp popup/popup.cpp
.)l
.PP
Reimplemented in QDialog, QSemiModal and QPushButton.
.SH "void QWidget::move ( const QPoint & ) \fC[slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::moveEvent ( QMoveEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget move events. When the widget receives this event, it is already at the new position.
.PP
The old position is accessible through QMoveEvent::oldPos().
.PP
See also resizeEvent(), event(), move() and QMoveEvent.
.PP
Reimplemented in QXtWidget and QToolButton.
.SH "bool QWidget::ownCursor () const"
Returns whether the widget uses its own cursor or its parent widget's cursor.
.SH "bool QWidget::ownFont () const"
Returns whether the widget uses its own font or its natural default font.
.PP
See also setFont() and unsetFont().
.SH "bool QWidget::ownPalette () const"
Returns whether the widget uses its own palette or its natural default palette.
.PP
See also setPalette() and unsetPalette().
.SH "void QWidget::paintEvent ( QPaintEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget paint events.
.PP
When the paint event occurs, the update region QPaintEvent::region() normally has been cleared to the background color or pixmap. An exception is when repaint(FALSE) is called or the widget sets the WRepaintNoErase or WResizeNoErase flag. Inside the paint event handler, QPaintEvent::erased() carries this information.
.PP
For many widgets it is sufficient to redraw the entire widget each time, but some need to consider the update rectangle or region of the QPaintEvent to avoid slow update.
.PP
During paintEvent(), any QPainter you create on the widget will be clipped to at most the area covered by the update region.
.PP
update() and repaint() can be used to force a paint event.
.PP
See also event(), repaint(), update(), QPainter, QPixmap and QPaintEvent.
.PP
Reimplemented in QComboBox, QSlider, QGroupBox, QGLWidget, QScrollBar, QTabBar, QFrame, QHeader, QLineEdit, QSizeGrip, QStatusBar, QTableView, QPopupMenu, QDial, QTabDialog, QToolBar, QMainWindow and QButton.
.SH "const QPalette & QWidget::palette () const"
Returns the widget palette.
.PP
As long as no special palette has been set, this is either a special palette for the widget class, the parent's palette or - if this widget is a toplevel widget - the default application palette.
.PP
See also setPalette(), colorGroup() and QApplication::palette().
.SH "void QWidget::paletteChange ( const QPalette & oldPalette ) \fC[virtual protected]\fR"
This virtual function is called from setPalette(). \fIoldPalette\fR is the previous palette; you can get the new palette from palette().
.PP
Reimplement this function if your widget needs to know when its palette changes. You will almost certainly need to call this implementation of the function.
.PP
See also setPalette() and palette().
.PP
Reimplemented in QTextView.
.SH "QWidget::PropagationMode QWidget::palettePropagation() const"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
The return value is meaningless.
.SH "QWidget * QWidget::parentWidget () const"
Returns a pointer to the parent of this widget, or a null pointer if it does not have any parent widget.
.SH "void QWidget::polish () \fC[virtual slot]\fR"
Delayed initialization of a widget.
.PP
This function will be called \fIafter\fR a widget has been fully created and \fIbefore\fR it is shown the very first time.
.PP
Polishing is useful for final initialization depending on an instantiated widget. This is something a constructor cannot guarantee since the initialization of the subclasses might not be finished.
.PP
After this function, the widget has a proper font and palette and QApplication::polish() has been called.
.PP
Remember to call QWidget's implementation when reimplementing this function.
.PP
See also constPolish() and QApplication::polish().
.PP
Examples:
.(l
menu/menu.cpp
.)l
.SH "QPoint QWidget::pos () const"
Returns the position of the widget in its parent widget, including the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also move(), frameGeometry(), x() and y().
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "void QWidget::raise () \fC[slot]\fR"
Raises this widget to the top of the parent widget's stack.
.PP
If there are any siblings of this widget that overlap it on the screen, this widget will be visually in front of its siblings afterwards.
.PP
See also lower() and stackUnder().
.SH "QRect QWidget::rect () const"
Returns the the internal geometry of the widget, excluding the window frame. rect() equals QRect(0,0,width(),height()).
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also size().
.PP
Examples:
.(l
grapher/grapher.cpp menu/menu.cpp desktop/desktop.cpp picture/picture.cpp
.)l
.SH "void QWidget::releaseKeyboard ()"
Releases the keyboard grab.
.PP
See also grabKeyboard(), grabMouse() and releaseMouse().
.SH "void QWidget::releaseMouse ()"
Releases the mouse grab.
.PP
See also grabMouse(), grabKeyboard() and releaseKeyboard().
.PP
Examples:
.(l
qmag/qmag.cpp
.)l
.SH "void QWidget::repaint ( const QRegion & reg, bool erase=TRUE ) \fC[slot]\fR"
Repaints the widget directly by calling paintEvent() directly, unless updates are disabled or the widget is hidden.
.PP
Erases the widget region \fIreg\fR if \fIerase\fR is TRUE.
.PP
Use repaint if your widget needs to be repainted immediately, for example when doing some animation. In all other cases, update() is to be preferred. Calling update() many times in a row will generate a single paint event.
.PP
\fBWarning:\fR If you call repaint() in a function which may itself be called from paintEvent(), you may see infinite recursion. The update() function never generates recursion.
.PP
See also update(), paintEvent(), setUpdatesEnabled() and erase().
.PP
Examples:
.(l
xform/xform.cpp qmag/qmag.cpp
.)l
.SH "void QWidget::repaint ( int x, int y, int w, int h, bool erase=TRUE ) \fC[slot]\fR"
Repaints the widget directly by calling paintEvent() directly, unless updates are disabled or the widget is hidden.
.PP
Erases the widget area \fI(x,y,w,h)\fR if \fIerase\fR is TRUE.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR. If \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
Use repaint if your widget needs to be repainted immediately, for example when doing some animation. In all other cases, update() is to be preferred. Calling update() many times in a row will generate a single paint event.
.PP
\fBWarning:\fR If you call repaint() in a function which may itself be called from paintEvent(), you may see infinite recursion. The update() function never generates recursion.
.PP
See also update(), paintEvent(), setUpdatesEnabled() and erase().
.SH "void QWidget::repaint () \fC[slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version erases and repaints the entire widget.
.PP
Examples:
.(l
grapher/grapher.cpp
.)l
.SH "void QWidget::repaint ( bool erase ) \fC[slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version repaints the entire widget.
.SH "void QWidget::repaint ( const QRect & r, bool erase=TRUE ) \fC[slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::reparent ( QWidget * parent, WFlags f, const QPoint & p, bool showIt=FALSE ) \fC[virtual]\fR"
Reparents the widget. The widget gets a new \fIparent,\fR new widget flags (\fIf,\fR but as usual, use 0) at a new position in its new parent (\fIp).\fR
.PP
If \fIshowIt\fR is TRUE, show() is called once the widget has been reparented.
.PP
If the new parent widget is in a different top-level widget, the reparented widget and its children are appended to the end of the TAB chain of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, reparent() calls clearFocus() for that widget.
.PP
If the new parent widget is in the same top-level widget as the old parent, reparent doesn't change the TAB order or keyboard focus.
.PP
\fBWarning:\fR Reparenting widgets should be a real exception. In normal applications, you will almost never need it. Dynamic masks can be achieved much easier and cleaner with classes like QWidgetStack or on a higher abstraction level, QWizard.
.PP
See also getWFlags().
.SH "void QWidget::reparent ( QWidget * parent, const QPoint & p, bool showIt=FALSE )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
A convenience version of reparent that does not take widget flags as argument.
.PP
Calls reparent(\fIparent,\fR getWFlags()&~WType_Mask, \fIp, showit\fR ).
.SH "void QWidget::resize ( int w, int h ) \fC[virtual slot]\fR"
Resizes the widget to size \fIw\fR by \fIh\fR pixels.
.PP
If the widget is visible, it receives a resize event immediately. If the widget is not shown yet, it is guaranteed to receive an event before it actually becomes visible.
.PP
The size is adjusted if it is outside the minimum or maximum widget size.
.PP
This function is virtual, and all other overloaded resize() implementations call it.
.PP
\fBWarning:\fR If you call resize() or setGeometry() from resizeEvent(), you may see infinite recursion.
.PP
See also size(), move(), setGeometry(), resizeEvent(), minimumSize() and maximumSize().
.PP
Examples:
.(l
aclock/main.cpp checklists/main.cpp buttongroups/main.cpp drawdemo/drawdemo.cpp qmag/qmag.cpp qwerty/main.cpp rot13/rot13.cpp
.)l
.PP
Reimplemented in QSemiModal and QDialog.
.SH "void QWidget::resize ( const QSize & ) \fC[slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Examples:
.(l
rangecontrols/main.cpp themes/main.cpp listviews/main.cpp dclock/main.cpp mainlyXt/editor.cpp drawdemo/drawdemo.cpp popup/popup.cpp fileiconview/main.cpp scribble/main.cpp qmag/qmag.cpp mainlyMotif/editor.cpp richtext/main.cpp scrollview/scrollview.cpp qfd/qfd.cpp listboxcombo/main.cpp
.)l
.SH "void QWidget::resizeEvent ( QResizeEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget resize events. When resizeEvent() is called, the widget already has its new geometry. The old size is accessible through QResizeEvent::oldSize(), though.
.PP
The widget will be erased and receive a paint event immediately after processing the resize event. No drawing has to (and should) be done inside this handler.
.PP
Widgets that have been created with the \fCWResizeNoErase\fR flag will not be erased. Nevertheless, they will receive a paint event for their entire area afterwards. Again, no drawing needs to be done inside this handler.
.PP
The default implementation calls updateMask() if the widget has automatic masking enabled.
.PP
See also moveEvent(), event(), resize(), QResizeEvent and paintEvent().
.PP
Reimplemented in QTableView, QMessageBox, QTabBar, QSlider, QLabel, QProgressDialog, QTable, QFrame, QPushButton, QSplitter, QWorkspace, QScrollView, QLineEdit, QListBox, QTabWidget, QWidgetStack, QStatusBar, QMainWindow, QMenuBar, QMultiLineEdit, QGLWidget, QGroupBox, QToolBar, QScrollBar, QCheckBox, QListView, QDial, QTextView, QTabDialog, QSpinBox, QDialog, QRadioButton, QComboBox, QXtWidget and QFileDialog.
.SH "void QWidget::scroll ( int dx, int dy, const QRect & r )"
Scrolls \fIr dx\fR pixels to the right and \fIdy\fR downwards. Both \fIdx\fR and \fIdy\fR may be negative.
.PP
If \fIr\fR is empty or invalid, the result is undefined.
.PP
After scrolling, scroll() sends a paint event for the the part of \fIr\fR that is read but not written. For example, when scrolling 10 pixels rightwards, the leftmost ten pixels of \fIr\fR need repainting. The paint event may be delivered immediately or later, depending on some heuristics.
.PP
This version of scroll() does not move the children of this widget.
.PP
See also QScrollView, erase() and bitBlt().
.SH "void QWidget::scroll ( int dx, int dy )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
This version of the function scrolls the entire widget and moves the widget's children along with the scroll.
.PP
See also bitBlt() and QScrollView.
.SH "void QWidget::setAcceptDrops ( bool on ) \fC[virtual]\fR"
Announces to the system that this widget \fImay\fR be able to accept drop events.
.PP
If the widgets is the desktop, this may fail if another application is using the desktop - you can call acceptDrops() to test if this occurs.
.PP
See also acceptDrops().
.PP
Examples:
.(l
scrollview/scrollview.cpp
.)l
.SH "void QWidget::setActiveWindow () \fC[virtual]\fR"
Sets the top-level widget containing this widget to be the active window.
.PP
An active window is a visible top-level window that has the keyboard input focus.
.PP
This function performs the same operation as clicking the mouse on the title bar of a top-level window. On X11, the result depends on the Window Manager. If you want to ensure that the window is stacked on top as well, call raise() in addition. Note that the window has be to visible, otherwise setActiveWindow() has no effect.
.PP
On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will flash the task bar entry blue to indicate that the window has done something. This is due to Microsoft not allowing an application to interrupt what the user is currently doing in another application.
.PP
See also isActiveWindow(), topLevelWidget() and show().
.PP
Reimplemented in QXtWidget.
.SH "void QWidget::setAutoMask ( bool enable ) \fC[virtual]\fR"
Transparent widgets use a mask to define their visible region. QWidget has some built-in support to make the task of recalculating the mask easier. When setting auto mask to TRUE, updateMask() will be called whenever the widget is resized or changes its focus state.
.PP
Note: When you re-implement resizeEvent(), focusInEvent() or focusOutEvent() in your custom widgets and still want to ensure that the auto mask calculation works, you will have to add
.PP
.nf
.br
    if ( autoMask() )
.br
          updateMask();
.fi
.PP
at the end of your event handlers. Same holds for all member functions that change the appearance of the widget in a way that a recalculation of the mask is necessary.
.PP
While being a technically appealing concept, masks have one big drawback: when using complex masks that cannot be expressed easily with relatively simple regions, they tend to be very slow on some window systems. The classic example is a transparent label. The complex shape of its contents makes it necessary to represent its mask by a bitmap, which consumes both memory and time. If all you want is to blend the background of several neighboring widgets together seamlessly, you may probably want to use setBackgroundOrigin() rather than a mask.
.PP
See also autoMask(), updateMask(), setMask(), clearMask() and setBackgroundOrigin().
.PP
Examples:
.(l
aclock/main.cpp
.)l
.PP
Reimplemented in QLabel.
.SH "void QWidget::setBackgroundColor ( const QColor & color ) \fC[virtual]\fR"
Sets the widget to be cleared to the fixed color \fIcolor\fR before paintEvent() is called.
.PP
Note that using this function is very often a mistake. Here are the most common mistakes:
.PP
If you want to set the background color of a widget to one of the" usual" colors, setBackgroundMode() is usually the best function. For example, man widgets that usually use white backgrounds (and black text on it) can use this:
.PP
.nf
.br
    thatWidget->setBackgroundMode( QWidget::PaletteBase );
.fi
.PP
If you want to change the color scheme of a widget, the setPalette() function is better suited. Here is how to set \fIthatWidget\fR to use a light green (RGB value 80, 255, 80) as background color, with shades of green used for all the 3D effects:
.PP
.nf
.br
    thatWidget->setPalette( QPalette( QColor(80, 255, 80) ) );
.fi
.PP
A fixed background color sometimes is just the right thing, but if you use it, make sure that your application looks right when the desktop color scheme has been changed. (On X11, a quick way to test is e.g. "./yourapp -bg paleblue". On Windows, you have to use the control panel.)
.PP
See also setPalette(), QApplication::setPalette(), backgroundColor(), setBackgroundPixmap() and setBackgroundMode().
.PP
Examples:
.(l
drawlines/connect.cpp xform/xform.cpp drawdemo/drawdemo.cpp splitter/splitter.cpp desktop/desktop.cpp hello/main.cpp customlayout/main.cpp
.)l
.SH "void QWidget::setBackgroundMode ( BackgroundMode m )"
Tells the window system how to clear this widget when sending a paint event. In other words, this decides how the widgets looks when paintEvent() is called.
.PP
For most widgets the default (PaletteBackground, normally gray) suffices, but some need to use PaletteBase (the background color for text output, normally white) and a few need other colors.
.PP
QListBox, which is "sunken" and uses the base color to contrast with its environment, does this:
.PP
.nf
.br
    setBackgroundMode( PaletteBase );
.fi
.PP
Note that two of the BackgroundMode values cannot be used with this function. For \fCFixedPixmap,\fR call setBackgroundPixmap() instead, and for \fCFixedColor,\fR call setBackgroundColor().
.SH "void QWidget::setBackgroundOrigin ( BackgroundOrigin origin )"
Sets the widget's background to be drawn relative to \fIorigin,\fR which is either of \fCWidgetOrigin\fR (the default) or \fCParentOrigin.\fR
.PP
This makes a difference only if the widget has a background pixmap where the positioning matters. In such case, using \fCParentOrigin\fR for several neighboring widgets makes the background blend together seamlessly.
.PP
See also backgroundOrigin(), backgroundPixmap() and setBackgroundMode().
.SH "void QWidget::setBackgroundPixmap ( const QPixmap & pixmap ) \fC[virtual]\fR"
Sets the background pixmap of the widget to \fIpixmap.\fR
.PP
The background pixmap is tiled to cover the entire widget. Note that some widgets do not work well with a background pixmap, for example QLineEdit.
.PP
If \fIpixmap\fR is part of the widget's palette(), we recommend calling setBackgroundMode() instead.
.PP
A fixed background pixmap sometimes is just the right thing, but if you use it, make sure that your application looks right when the desktop color scheme has been changed. (On X11, a quick way to test is e.g. "./yourapp -bg paleblue". On Windows, you have to use the control panel.)
.PP
See also setBackgroundMode(), backgroundPixmap(), backgroundPixmapChange() and setBackgroundColor().
.PP
Examples:
.(l
desktop/desktop.cpp
.)l
.SH "void QWidget::setBaseSize ( int basew, int baseh )"
Sets the base size of the widget. The base size is important only in combination with size increments. See setSizeIncrement() for details.
.PP
See also baseSize().
.SH "void QWidget::setBaseSize ( const QSize & )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::setCaption ( const QString & caption ) \fC[virtual slot]\fR"
Sets the window caption (title) to \fIcaption.\fR
.PP
See also caption(), setIcon() and setIconText().
.PP
Examples:
.(l
showimg/main.cpp action/main.cpp rangecontrols/main.cpp iconview/main.cpp validator/main.cpp themes/main.cpp listviews/main.cpp aclock/main.cpp checklists/main.cpp drawlines/connect.cpp dclock/main.cpp wizard/main.cpp xform/xform.cpp application/main.cpp cursor/cursor.cpp layout/layout.cpp tetrix/tetrix.cpp helpviewer/main.cpp buttongroups/main.cpp life/main.cpp i18n/main.cpp drawdemo/drawdemo.cpp lineedits/main.cpp popup/popup.cpp listbox/main.cpp menu/menu.cpp progress/progress.cpp scribble/main.cpp tabdialog/main.cpp splitter/splitter.cpp progressbar/main.cpp tooltip/main.cpp richtext/main.cpp qwerty/main.cpp forever/forever.cpp rot13/rot13.cpp xml/tagreader
.)l-with-features/tagreader.cpp
scrollview/scrollview.cpp qfd/qfd.cpp addressbook/main.cpp movies/main.cpp picture/picture.cpp hello/main.cpp listboxcombo/main.cpp tictac/main.cpp customlayout/main.cpp mdi/main.cpp dirview/main.cpp
.SH "void QWidget::setCursor ( const QCursor & cursor ) \fC[virtual]\fR"
Sets the widget cursor shape to \fIcursor.\fR
.PP
The mouse cursor will assume this shape when it's over this widget. See a list of predefined cursor objects with a range of useful shapes in the QCursor documentation.
.PP
An editor widget would for example use an I-beam cursor:
.PP
.nf
.br
    setCursor( ibeamCursor );
.fi
.PP
See also cursor(), unsetCursor() and QApplication::setOverrideCursor().
.PP
Examples:
.(l
cursor/cursor.cpp
.)l
.SH "void QWidget::setDisabled ( bool disable ) \fC[slot]\fR"
Disables widget input events if \fIdisable\fR is TRUE, otherwise enables input events.
.PP
An enabled widget receives keyboard and mouse events; a disabled widget does not. Note that an enabled widget receives keyboard events only when it is in focus.
.PP
Some widgets display themselves differently when they are disabled. For example a button might draw its label grayed out. If your widget needs to know when it becomes enabled or disabled, you can reimplement the enabledChange() function.
.PP
Disabling a widget implicitely disables all its children. Enabling respectively enables all child widgets unless they have been explicitly disabled.
.PP
See also setEnabled(), isEnabled(), isEnabledTo(), QKeyEvent, QMouseEvent and enabledChange().
.SH "void QWidget::setEnabled ( bool enable ) \fC[virtual slot]\fR"
Enables widget input events if \fIenable\fR is TRUE, otherwise disables input events.
.PP
An enabled widget receives keyboard and mouse events; a disabled widget does not. Note that an enabled widget receives keyboard events only when it is in focus.
.PP
Some widgets display themselves differently when they are disabled. For example a button might draw its label grayed out. If your widget needs to know when it becomes enabled or disabled, you can reimplement the enabledChange() function.
.PP
Disabling a widget implicitely disables all its children. Enabling respectively enables all child widgets unless they have been explicitly disabled.
.PP
See also isEnabled(), isEnabledTo(), QKeyEvent, QMouseEvent and enabledChange().
.PP
Reimplemented in QScrollView.
.SH "void QWidget::setFixedHeight ( int h )"
Sets both the minimum and maximum heights of the widget to \fIh\fR without changing the widths. Provided for convenience.
.PP
See also sizeHint(), minimumSize(), maximumSize(), setFixedSize() and more.
.PP
Examples:
.(l
layout/layout.cpp
.)l
.SH "void QWidget::setFixedSize ( const QSize & s )"
Sets both the minimum and maximum sizes of the widget to \fIs,\fR thereby preventing it from ever growing or shrinking.
.PP
See also setMaximumSize() and setMinimumSize().
.SH "void QWidget::setFixedSize ( int w, int h )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::setFixedWidth ( int w )"
Sets both the minimum and maximum width of the widget to \fIw\fR without changing the heights. Provided for convenience.
.PP
See also sizeHint(), minimumSize(), maximumSize(), setFixedSize() and more.
.SH "void QWidget::setFocus () \fC[virtual slot]\fR"
Gives the keyboard input focus to the widget (or its focus proxy).
.PP
First, a focus out event is sent to the focus widget (if any) to tell it that it is about to lose the focus. Then a focus in event is sent to this widget to tell it that it just received the focus.
.PP
setFocus() gives focus to a widget regardless of its focus policy.
.PP
\fBWarning:\fR If you call setFocus() in a function which may itself be called from focusOutEvent() or focusInEvent(), you may see infinite recursion.
.PP
See also hasFocus(), clearFocus(), focusInEvent(), focusOutEvent(), setFocusPolicy() and QApplication::focusWidget().
.PP
Examples:
.(l
xform/xform.cpp popup/popup.cpp
.)l
.SH "void QWidget::setFocusPolicy ( FocusPolicy policy )"
Enables or disables the keyboard focus for the widget.
.PP
The keyboard focus is initially disabled (i.e. \fIpolicy\fR == \fCQWidget::NoFocus).\fR
.PP
You must enable keyboard focus for a widget if it processes keyboard events. This is normally done from the widget's constructor. For instance, the QLineEdit constructor calls setFocusPolicy(\fCQWidget::StrongFocus).\fR
.PP
See also isFocusEnabled(), focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent() and isEnabled().
.PP
Examples:
.(l
rot13/rot13.cpp
.)l
.SH "void QWidget::setFocusProxy ( QWidget * w ) \fC[virtual]\fR"
Sets this widget's focus proxy to \fIw.\fR If \fIw\fR is 0, this function resets this widget to not have any focus proxy.
.PP
Some widgets, such as QComboBox, can "have focus," but create a child widget to actually handle the focus. QComboBox, for example, creates a QLineEdit.
.PP
setFocusProxy() sets the widget which will actually get focus when" this widget" gets it. If there is a focus proxy, focusPolicy(), setFocusPolicy(), setFocus() and hasFocus() all operate on the focus proxy.
.PP
See also focusProxy().
.SH "void QWidget::setFont ( const QFont & font ) \fC[virtual]\fR"
Sets the font for the widget and informs all children about the change.
.PP
The fontInfo() function reports the actual font that is being used by the widget.
.PP
This code fragment sets a 12 point helvetica bold font:
.PP
.nf
.br
    QFont f("Helvetica", 12, QFont::Bold);
.br
    setFont( f );
.fi
.PP
See also font(), fontChange(), fontInfo(), fontMetrics(), unsetFont() and ownFont().
.PP
Examples:
.(l
grapher/grapher.cpp xform/xform.cpp
.)l
.PP
Reimplemented in QWizard, QPopupMenu, QTabDialog and QFontDialog.
.SH "void QWidget::setFont ( const QFont & font, bool )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Use setFont( const QFont& font) instead.
.PP
Examples:
.(l
xform/xform.cpp hello/main.cpp
.)l
.SH "void QWidget::setFontPropagation ( PropagationMode )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Calling this function has no effect.
.SH "void QWidget::setGeometry ( int x, int y, int w, int h ) \fC[virtual slot]\fR"
Sets the widget geometry to \fIw\fR by \fIh,\fR positioned at \fIx,y\fR in its parent widget.
.PP
If the widget is visible, it receives a move event and/or resize event immediately. If the widget is not shown yet, it is guaranteed to receive appropriate events before it actually becomes visible.
.PP
The size is adjusted if it is outside the minimum or maximum widget size.
.PP
This function is virtual, and all other overloaded setGeometry() implementations call it.
.PP
\fBWarning:\fR If you call setGeometry() from resizeEvent() or moveEvent(), you may see infinite recursion.
.PP
See also geometry(), move(), resize(), moveEvent(), resizeEvent(), minimumSize() and maximumSize().
.PP
Reimplemented in QDialog.
.SH "void QWidget::setGeometry ( const QRect & ) \fC[virtual slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.PP
Examples:
.(l
i18n/main.cpp drawdemo/drawdemo.cpp popup/popup.cpp qmag/qmag.cpp
.)l
.PP
Reimplemented in QDialog.
.SH "void QWidget::setIcon ( const QPixmap & pixmap ) \fC[virtual slot]\fR"
Sets the window icon to \fIpixmap.\fR
.PP
See also icon(), setIconText(), setCaption() and Setting the Application Icon
.PP
Reimplemented in QMessageBox.
.SH "void QWidget::setIconText ( const QString & iconText ) \fC[virtual slot]\fR"
Sets the text of the window's icon to \fIiconText.\fR
.PP
See also iconText(), setIcon() and setCaption().
.SH "void QWidget::setKeyCompression ( bool compress ) \fC[virtual protected]\fR"
Enables key event compression, if \fIenable\fR is TRUE, and disables it if \fIenable\fR is FALSE.
.PP
By default key compression is off, so widgets receive one key press event for each key press (or more, since autorepeat is usually on). If you turn it on and your program doesn't keep up with key input, Qt tries to compress key events so that more than one character can be processed in each event.
.PP
For example, a word processor widget might receive 2, 3 or more characters in each QKeyEvent::text(), if the layout recalculation takes too long for the CPU.
.PP
If a widget supports multiple character unicode input, it is always safe to turn the compression on.
.PP
See also QKeyEvent::text();.
.SH "void QWidget::setMask ( const QBitmap & bitmap ) \fC[virtual]\fR"
Causes only the pixels of the widget for which \fIbitmap\fR has a corresponding 1 bit to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.
.PP
Note that this effect can be slow if the region is particularly complex.
.PP
See also setMask(const, QRegion&) and clearMask().
.SH "void QWidget::setMask ( const QRegion & region ) \fC[virtual]\fR"
Causes only the parts of the widget which overlap \fIregion\fR to be visible. If the region includes pixels outside the rect() of the widget, window system controls in that area may or may not be visible, depending on the platform.
.PP
Note that this effect can be slow if the region is particularly complex.
.PP
See also setMask(QBitmap) and clearMask().
.SH "void QWidget::setMaximumHeight ( int h )"
Sets the maximum height of the widget to \fIh\fR without changing the width. Provided for convenience.
.PP
See also sizeHint(), minimumSize(), maximumSize(), setFixedSize() and more.
.PP
Examples:
.(l
splitter/splitter.cpp
.)l
.SH "void QWidget::setMaximumSize ( int maxw, int maxh ) \fC[virtual]\fR"
Sets the maximum size of the widget to \fIw\fR by \fIh\fR pixels.
.PP
The widget cannot be resized to a larger size than the maximum widget size. The widget's size is forced to the maximum size if the current size is greater.
.PP
See also maximumSize(), setMinimumSize(), setSizeIncrement(), resize() and size().
.SH "void QWidget::setMaximumSize ( const QSize & size )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::setMaximumWidth ( int w )"
Sets the maximum width of the widget to \fIw\fR without changing the height. Provided for convenience.
.PP
See also sizeHint(), minimumSize(), maximumSize(), setFixedSize() and more.
.SH "void QWidget::setMicroFocusHint ( int x, int y, int width, int height, bool text=TRUE ) \fC[virtual protected]\fR"
When a widget gets focus, it should call setMicroFocusHint for some appropriate position and size - \fIx, y\fR and \fIw\fR by \fIh.\fR This has no \fIvisual\fR effect, it just provides hints to any system-specific input handling tools.
.PP
The \fItext\fR argument should be TRUE if this is a position for text input.
.PP
In the Windows version of Qt, this method sets the system caret, which is used for user Accessibility focus handling. If \fItext\fR is TRUE, it also sets the IME composition window in Far East Asian language input systems.
.PP
In the X11 version of Qt, if \fItext\fR is TRUE, this method sets the XIM "spot" point for complex language input handling.
.PP
See also microFocusHint().
.SH "void QWidget::setMinimumHeight ( int h )"
Sets the minimum height of the widget to \fIh\fR without changing the width. Provided for convenience.
.PP
See also sizeHint(), minimumSize(), maximumSize(), setFixedSize() and more.
.SH "void QWidget::setMinimumSize ( int minw, int minh ) \fC[virtual]\fR"
Sets the minimum size of the widget to \fIw\fR by \fIh\fR pixels.
.PP
The widget cannot be resized to a smaller size than the minimum widget size. The widget's size is forced to the minimum size if the current size is smaller.
.PP
If you use a layout inside the widget, the minimum size will be set by the layout and not by setMinimumSize, unless you set the layouts resize mode to QLayout::FreeResize.
.PP
See also minimumSize(), setMaximumSize(), setSizeIncrement(), resize(), size() and QLayout::setResizeMode().
.PP
Examples:
.(l
menu/menu.cpp qmag/qmag.cpp splitter/splitter.cpp
.)l
.SH "void QWidget::setMinimumSize ( const QSize & size )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::setMinimumWidth ( int w )"
Sets the minimum width of the widget to \fIw\fR without changing the height. Provided for convenience.
.PP
See also sizeHint(), minimumSize(), maximumSize(), setFixedSize() and more.
.SH "void QWidget::setMouseTracking ( bool enable ) \fC[virtual slot]\fR"
Enables mouse tracking if \fIenable\fR is TRUE, or disables it if \fIenable\fR is FALSE.
.PP
If mouse tracking is disabled (default), this widget only receives mouse move events when at least one mouse button is pressed down while the mouse is being moved.
.PP
If mouse tracking is enabled, this widget receives mouse move events even if no buttons are pressed down.
.PP
See also hasMouseTracking(), mouseMoveEvent() and QApplication::setGlobalMouseTracking().
.PP
Examples:
.(l
popup/popup.cpp qmag/qmag.cpp
.)l
.PP
Reimplemented in QGLWidget.
.SH "void QWidget::setName ( const char * name ) \fC[virtual]\fR"
Reimplemented for internal reasons; the API is not affected.
.PP
Reimplemented from QObject.
.SH "void QWidget::setPalette ( const QPalette & p, bool )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Use setPalette( const QPalette& p ) instead.
.SH "void QWidget::setPalette ( const QPalette & palette ) \fC[virtual]\fR"
Sets the widget palette to \fIpalette\fR and informs all children about the change.
.PP
See also QApplication::setPalette(), palette(), paletteChange(), unsetPalette(), ownPalette() and colorGroup().
.SH "void QWidget::setPalettePropagation ( PropagationMode )"
\fBThis function is obsolete.\fR It is provided to keep old source working, and will probably be removed in a future version of Qt. We strongly advise against using it in new code.
.PP
Calling this function has no effect.
.SH "void QWidget::setSizeIncrement ( int w, int h ) \fC[virtual]\fR"
Sets the size increment of the widget. When the user resizes the window, the size will move in steps of \fIw\fR pixels horizontally and \fIh\fR pixels vertically, with baseSize() as basis. Preferred widget sizes are therefore for non-negative integers \fIi\fR and \fIj:\fR
.PP
.nf
.br
  width = baseSize().width() + i * sizeIncrement().width();
.br
  height = baseSize().height() + j * sizeIncrement().height();
.fi
.PP
Note that while you can set the size increment for all widgets, it has no effect except for top-level widgets.
.PP
\fBWarning:\fR The size increment has no effect under Windows, and may be disregarded by the window manager on X.
.PP
See also sizeIncrement(), setMinimumSize(), setMaximumSize(), resize() and size().
.SH "void QWidget::setSizeIncrement ( const QSize & )"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::setSizePolicy ( QSizePolicy policy )"
Sets the size policy for this widget to \fIpolicy.\fR The size policy specifies the default layout behaviour.
.PP
The default policy is Preferred/Preferred, which means that the widget can be freely resized, but prefers to be the size sizeHint() returns. Button-like widgets set the size policy to specify that they may stretch horizontally, but are fixed vertically. The same applies to lineedit controls (such as QLineEdit, QSpinBox or an editable QComboBox) and other horizontally orientated widgets (such as QProgressBar). A QToolButton on the other hand wants to be squared, therefore it allows growth in both directions. Widgets that support different directions (such as QSlider, QScrollBar or QHeader) specify stretching in the respective direction only. Widgets that can provide scrollbars (usually subclasses of QScrollView) tend to specify that they can use additional space, and that they can survive on less than sizeHint().
.PP
See also sizeHint(), QLayout, QSizePolicy and updateGeometry().
.SH "void QWidget::setStyle ( QStyle * style )"
Sets the widget's GUI style to \fIstyle.\fR Ownership of the style object is not transferred.
.PP
If no style is set, the widget uses the application's style QApplication::style() instead.
.PP
Setting a widget's style has no effect on existing or future child widgets.
.PP
\fBWarning:\fR This function is particularly useful for demonstration purposes, where you want to show Qt's styling capabilities. Real applications should stay away from it and use one consistent GUI style instead.
.PP
See also style(), QStyle, QApplication::style() and QApplication::setStyle().
.PP
Examples:
.(l
grapher/grapher.cpp
.)l
.SH "void QWidget::setTabOrder ( QWidget * first, QWidget * second ) \fC[static]\fR"
Moves the \fIsecond\fR widget around the ring of focus widgets so that keyboard focus moves from \fIfirst\fR widget to \fIsecond\fR widget when Tab is pressed.
.PP
Note that since the tab order of the \fIsecond\fR widget is changed, you should order a chain like this:
.PP
.nf
.br
    setTabOrder(a, b ); // a to b
.br
    setTabOrder(b, c ); // a to b to c
.br
    setTabOrder(c, d ); // a to b to c to d
.fi
.PP
not like this:
.PP
.nf
.br
    setTabOrder(c, d); // c to d
.br
    setTabOrder(a, b); // a to b AND c to d
.br
    setTabOrder(b, c); // a to b to c, but not c to d
.fi
.PP
If either \fIfirst\fR or \fIsecond\fR has a focus proxy, setTabOrder() substitutes its/their proxies.
.PP
See also setFocusPolicy() and setFocusProxy().
.PP
Examples:
.(l
customlayout/main.cpp
.)l
.SH "void QWidget::setUpdatesEnabled ( bool enable ) \fC[virtual slot]\fR"
Enables widget updates if \fIenable\fR is TRUE, or disables widget updates if \fIenable\fR is FALSE.
.PP
Calling update() and repaint() has no effect if updates are disabled. Paint events from the window system are processed normally even if updates are disabled.
.PP
This function is normally used to disable updates for a short period of time, for instance to avoid screen flicker during large changes.
.PP
Example:
.PP
.nf
.br
    setUpdatesEnabled( FALSE );
.br
    bigVisualChanges();
.br
    setUpdatesEnabled( TRUE );
.br
    repaint();
.fi
.PP
See also isUpdatesEnabled(), update(), repaint() and paintEvent().
.PP
Reimplemented in QHeader.
.SH "void QWidget::setWFlags ( WFlags f ) \fC[virtual protected]\fR"
Sets the widget flags \fIf.\fR
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also testWFlags(), getWFlags() and clearWFlags().
.SH "void QWidget::show () \fC[virtual slot]\fR"
Shows the widget and its child widgets.
.PP
If its size or position has changed, Qt guarantees that a widget gets move and resize events just before the widget is shown.
.PP
You almost never have to reimplement this function. If you need to change some settings before a widget is shown, use showEvent() instead. If you need to do some delayed initialization use polish().
.PP
See also showEvent(), hide(), showMinimized(), showMaximized(), showNormal(), isVisible() and polish().
.PP
Examples:
.(l
showimg/main.cpp rangecontrols/main.cpp validator/main.cpp listviews/main.cpp aclock/main.cpp checklists/main.cpp drawlines/connect.cpp dclock/main.cpp xform/xform.cpp cursor/cursor.cpp layout/layout.cpp tetrix/tetrix.cpp buttongroups/main.cpp life/main.cpp i18n/main.cpp drawdemo/drawdemo.cpp lineedits/main.cpp popup/popup.cpp listbox/main.cpp menu/menu.cpp progress/progress.cpp qmag/qmag.cpp splitter/splitter.cpp progressbar/main.cpp tooltip/main.cpp richtext/main.cpp qwerty/main.cpp forever/forever.cpp rot13/rot13.cpp xml/tagreader
.)l-with-features/tagreader.cpp
scrollview/scrollview.cpp movies/main.cpp picture/picture.cpp hello/main.cpp listboxcombo/main.cpp biff/main.cpp tictac/main.cpp customlayout/main.cpp
.PP
Reimplemented in QToolBar, QSemiModal, QProgressBar, QWidgetStack, QTabBar, QPopupMenu, QTableView, QDialog, QListView, QMenuBar, QMainWindow, QScrollView, QTabDialog and QWizard.
.SH "void QWidget::showEvent ( QShowEvent * ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive widget show events.
.PP
Non-spontaneous show events are sent to widgets right before they are shown. Spontaneous show events of toplevel widgets are delivered afterwards, naturally.
.PP
See also event() and QShowEvent.
.PP
Reimplemented in QTable, QProgressDialog, QHeader, QTextBrowser, QWorkspace, QListView, QTabWidget, QListBox and QTextView.
.SH "void QWidget::showFullScreen () \fC[slot]\fR"
Shows the widget in full-screen mode.
.PP
Calling this function has no effect for other than top-level widgets.
.PP
To return from full-screen mode, call showNormal().
.PP
Full-screen mode works fine under Windows, but has certain problems under X. These problems are due to limitations of the ICCCM protocol that specifies the communication between X11 clients and the window manager. ICCCM simply does not know the concept of non-decorated full-screen windows. Therefore, the best we can do is to request a borderless window and place and resize it to fill the entire screen. Depending on the window manager, this may or may not work. The borderless window is requested using MOTIF hints, which are at least partially supported by virtually all modern window managers.
.PP
An alternative would be to bypass the window manager at all and to create a window with the WX11BypassWM flag. This has other severe problems, though, like totally broken keyboard focus and very strange effects on desktop changes or when the user raises other windows.
.PP
Future window managers that follow modern post-ICCCM specifications may support full-screen mode properly.
.PP
See also showNormal(), showMaximized(), show(), hide() and isVisible().
.SH "void QWidget::showMaximized () \fC[virtual slot]\fR"
Shows the widget maximized.
.PP
Calling this function has no effect for other than top-level widgets.
.PP
On X11, this function may not work properly with certain window managers. See the Window Geometry documentation for details on why.
.PP
See also showNormal(), showMinimized(), show(), hide() and isVisible().
.PP
Examples:
.(l
helpviewer/main.cpp scribble/main.cpp qwerty/main.cpp
.)l
.SH "void QWidget::showMinimized () \fC[virtual slot]\fR"
Shows the widget minimized, as an icon.
.PP
Calling this function has no effect for other than top-level widgets.
.PP
See also showNormal(), showMaximized(), show(), hide(), isVisible() and isMinimized().
.SH "void QWidget::showNormal () \fC[virtual slot]\fR"
Restores the widget after it has been maximized or minimized.
.PP
Calling this function has no effect for other than top-level widgets.
.PP
See also showMinimized(), showMaximized(), show(), hide() and isVisible().
.SH "QSize QWidget::size () const"
Returns the size of the widget, excluding the window frame.
.PP
See also geometry(), width() and height().
.SH "QSize QWidget::sizeHint () const \fC[virtual]\fR"
Returns a recommended size for the widget, or an invalid size if no size is recommended.
.PP
The default implementation returns an invalid size if there is no layout for this widget, the layout's preferred size otherwise.
.PP
See also QSize::isValid(), minimumSizeHint(), sizePolicy(), setMinimumSize() and updateGeometry().
.PP
Reimplemented in QTable, QMenuBar, QSizeGrip, QHBox, QRadioButton, QPopupMenu, QGroupBox, QToolButton, QCheckBox, QWidgetStack, QTabBar, QGrid, QListBox, QScrollView, QDial, QLabel, QTabWidget, QSlider, QLineEdit, QLCDNumber, QSplitter, QWorkspace, QPushButton, QSpinBox, QHeader, QIconView, QScrollBar, QProgressDialog, QCanvasView, QComboBox, QListView, QProgressBar, QFrame, QMainWindow, QDialog and QMultiLineEdit.
.SH "QSize QWidget::sizeIncrement () const"
Returns the widget size increment.
.PP
See also setSizeIncrement(), minimumSize() and maximumSize().
.SH "QSizePolicy QWidget::sizePolicy () const \fC[virtual]\fR"
Returns the default layout behaviour of this widget.
.PP
If there is a QLayout that manages this widget's children, the size policy specified by that layout is used. If there is no such QLayout, the result of this function is used.
.PP
See also setSizePolicy(), sizeHint(), QLayout, QSizePolicy and updateGeometry().
.PP
Reimplemented in QToolButton, QLineEdit, QFrame, QLCDNumber, QSizeGrip, QSplitter, QRadioButton, QPushButton, QWorkspace, QTabBar, QHeader, QSlider, QScrollView, QIconView, QTabWidget, QMultiLineEdit, QCheckBox, QScrollBar, QLabel, QSpinBox and QProgressBar.
.SH "void QWidget::stackUnder ( QWidget * w ) \fC[slot]\fR"
Places the widget under \fIw\fR in the parent widget's stack.
.PP
To make this work, the widget itself and \fIw\fR have to be siblings.
.PP
See also raise() and lower().
.SH "QStyle& QWidget::style () const"
Returns the GUI style for this widget
.PP
See also QWidget::setStyle(), QApplication::setStyle() and QApplication::style().
.SH "void QWidget::styleChange ( QStyle & oldStyle ) \fC[virtual protected]\fR"
This virtual function is called when the style of the widgets. changes.\fIoldStyle\fR is the previous GUI style; you can get the new style from style().
.PP
Reimplement this function if your widget needs to know when its GUI style changes. You will almost certainly need to update the widget using update().
.PP
The default implementation updates the widget including its geometry.
.PP
See also QApplication::setStyle(), style(), update() and updateGeometry().
.PP
Reimplemented in QScrollView, QPopupMenu, QSlider, QTabWidget, QProgressBar, QSpinBox, QListView, QIconView, QMainWindow, QTabDialog, QToolBar, QComboBox, QProgressDialog, QSplitter, QScrollBar, QTabBar and QMenuBar.
.SH "bool QWidget::testWFlags ( WFlags f ) const"
Returns TRUE if any of the widget flags in \fIf\fR are set.
.PP
Widget flags are a combination of Qt::WidgetFlags.
.PP
See also getWFlags(), setWFlags() and clearWFlags().
.SH "QWidget * QWidget::topLevelWidget () const"
Returns the top-level widget for this widget, i.e. the next ancestor widget that has a window-system frame (or at least may have one).
.PP
If the widget is a top-level, the widget itself is returned.
.PP
Typical usage is changing the window caption:
.PP
.nf
.br
    aWidget->topLevelWidget()->setCaption( "New Caption" );
.fi
.PP
See also isTopLevel().
.SH "void QWidget::unsetCursor () \fC[virtual]\fR"
Unset the cursor for this widget. The widget will use the cursor of its parent from now on.
.PP
This functions does nothing for top-level windows.
.PP
See also cursor(), setCursor() and QApplication::setOverrideCursor().
.SH "void QWidget::unsetFont ()"
Unsets the font for this widget. The widget will use its natural default font from now on. This is either a special font for the widget class, the parent's font or - if this widget is a toplevel widget - the default application font.
.PP
See also setFont() and ownFont().
.SH "void QWidget::unsetPalette ()"
Unsets the palette for this widget. The widget will use its natural default palette from now on.
.PP
See also setPalette() and ownPalette().
.SH "void QWidget::update () \fC[slot]\fR"
Updates the widget unless updates are disabled or the widget is hidden.
.PP
Updating the widget will erase the widget contents and generate an appropriate paint event for the invalidated region. The paint event is processed after the program has returned to the main event loop. Calling update() many times in a row will generate a single paint event.
.PP
If the widgets sets the WRepaintNoErase flag, update() will not erase its contents.
.PP
See also repaint(), paintEvent(), setUpdatesEnabled(), erase() and setWFlags().
.PP
Examples:
.(l
grapher/grapher.cpp scrollview/scrollview.cpp
.)l
.SH "void QWidget::update ( int x, int y, int w, int h ) \fC[slot]\fR"
Updates a rectangle (\fIx, y, w, h)\fR inside the widget unless updates are disabled or the widget is hidden.
.PP
Updating the widget erases the widget area \fI(x,y,w,h)\fR and generate an appropriate paint event for the invalidated region. The paint event is processed after the program has returned to the main event loop. Calling update() many times in a row will generate a single paint event.
.PP
If \fIw\fR is negative, it is replaced with \fCwidth() - x\fR. If \fIh\fR is negative, it is replaced width \fCheight() - y\fR.
.PP
If the widgets sets the WRepaintNoErase flag, update() will not erase its contents.
.PP
See also repaint(), paintEvent(), setUpdatesEnabled() and erase().
.PP
Examples:
.(l
drawlines/connect.cpp drawdemo/drawdemo.cpp desktop/desktop.cpp picture/picture.cpp
.)l
.SH "void QWidget::update ( const QRect & r ) \fC[slot]\fR"
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.
.SH "void QWidget::updateGeometry ()"
Notifies the layout system that this widget has changed and may need to change geometry.
.PP
Call this function if the sizeHint() or sizePolicy() have changed.
.PP
For explicitly hidden widgets, updateGeometry() is a no-op. The layout system will be notified as soon as the widget is shown.
.SH "void QWidget::updateMask () \fC[virtual protected]\fR"
This function can be reimplemented in a subclass to support transparent widgets. It is supposed to be called whenever a widget changes state in a way that the shape mask has to be recalculated.
.PP
See also setAutoMask(), updateMask(), setMask() and clearMask().
.PP
Reimplemented in QPushButton, QGroupBox, QFrame, QTabBar, QCheckBox, QSlider, QRadioButton, QComboBox and QTabWidget.
.SH "QRect QWidget::visibleRect () const"
Returns the currently visible rectangle of the widget. This function is in particular useful to optimize immediate repainting of a widget. Typical usage is
.PP
.nf
.br
  repaint( w->visibleRect() );
.fi
.PP
or
.PP
.nf
.br
  repaint( w->visibleRect(), FALSE );
.fi
.PP
If nothing is visible, the rectangle returned is empty.
.SH "void QWidget::wheelEvent ( QWheelEvent * e ) \fC[virtual protected]\fR"
This event handler can be reimplemented in a subclass to receive wheel events for the widget.
.PP
If you reimplement this handler, it is very important that you ignore() the event if you do not handle it, so that the widget's parent can interpret it.
.PP
The default implementation ignores the event.
.PP
See also QWheelEvent::ignore(), QWheelEvent::accept(), event() and QWheelEvent.
.PP
Reimplemented in QSlider, QScrollBar, QSpinBox, QScrollView, QMultiLineEdit and QDial.
.SH "int QWidget::width () const"
Returns the width of the widget, excluding the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also geometry(), height() and size().
.PP
Examples:
.(l
grapher/grapher.cpp xform/xform.cpp drawdemo/drawdemo.cpp menu/menu.cpp qmag/qmag.cpp
.)l
.SH "WId QWidget::winId () const"
Returns the window system identifier of the widget.
.PP
Portable in principle, but if you use it you are probably about to do something non-portable. Be careful.
.PP
See also find().
.SH "int QWidget::x () const"
Returns the x coordinate of the widget, relative to its parent widget and including the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also frameGeometry(), y() and pos().
.SH "int QWidget::y () const"
Returns the y coordinate of the widget, relative to its parent widget and including the window frame.
.PP
See the Window Geometry documentation for an overview of geometry issues with top-level widgets.
.PP
See also frameGeometry(), x() and pos().
.PP
Examples:
.(l
drawdemo/drawdemo.cpp
.)l
.SH "void QWidget::clearWState ( uint n ) \fC[protected]\fR"
For internal use only.
.SH "QWExtra * QWidget::extraData () \fC[protected]\fR"
For internal use only.
.SH "uint QWidget::getWState () const \fC[protected]\fR"
For internal use only.
.SH "void QWidget::setCRect ( const QRect & r ) \fC[virtual protected]\fR"
For internal use only.
.SH "void QWidget::setFRect ( const QRect & r ) \fC[virtual protected]\fR"
For internal use only.
.SH "void QWidget::setWState ( uint n ) \fC[virtual protected]\fR"
For internal use only.
.SH "bool QWidget::testWState ( uint n ) const"
For internal use only.
.SH "QTLWExtra * QWidget::topData () \fC[protected]\fR"
For internal use only.
.SH "QWidgetMapper * QWidget::wmapper () \fC[static]\fR"
For internal use only.
.SH "SEE ALSO"
.BR http://doc.trolltech.com/qwidget.html
.BR http://www.trolltech.com/faq/tech.html
.SH COPYRIGHT
Copyright 1992-2001 Trolltech AS, http://www.trolltech.com.  See the
license file included in the distribution for a complete license
statement.
.SH AUTHOR
Generated automatically from the source code.
.SH BUGS
If you find a bug in Qt, please report it as described in
.BR http://doc.trolltech.com/bughowto.html .
Good bug reports make our job much simpler. Thank you.
.P
In case of content or formattting problems with this manual page, please
report them to
.BR qt-bugs@trolltech.com .
Please include the name of the manual page (qwidget.3qt) and the Qt
version (2.3.2).
