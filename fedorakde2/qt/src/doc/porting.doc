/****************************************************************************
** $Id: qt/doc/porting.doc   2.3.2   edited 2001-01-26 $
**
** Help with porting from Qt 1.x to Qt 2.x
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page porting.html

\title Porting to Qt 2.x

<p>
You're probably looking at this page because you want to port
your application from Qt 1.x to Qt 2.x, but to be sure, let's
review the good reasons to do this:
<ul>
 <li>To get access to all the new Qt 2.x features like the rich text
	HTML subset for formatted labels, tooltips, online help etc.
	and the much easier to use layout classes and widgets.
 <li>To make your application truly international, with support
	for Unicode and translations for the languages of the world.
 <li>To allow your application to fit into the new look of the
	Unix desktop with configurable, very powerful "themes". The
	extended style system also integrates Qt applications better
	on MS-Windows desktops. Qt will automatically chose the right
	colors and fonts and obey global system setting changes.
 <li>To stay up-to-date with the version of Qt that gets all the
	new features and bug-fixes.
 <li>To get more speed and smoother widgets display with all the
	new anti-flicker changes in Qt.
 <li>Most of all though, you want to port to Qt 2.x
	so that your Wheel Mouse works!
</ul>

<p>
The Qt 2.x series is not binary compatible with the 1.x series.
This means programs compiled for Qt 1.x must be recompiled to work
with Qt 2.x.  Qt 2.x is also not completely <em>source</em> compatible
with 1.x, however all points of incompatibility cause
compiler errors (rather than mysterious results), or produce run-time
messages.  The result is that Qt 2.x includes many additional features,
discards obsolete functionality that is easily converted to use the new
features, and that porting an application from Qt 1.x to Qt 2.x is
a simple task well worth the amount of effort required.


To port code using Qt 1.x to use Qt 2.x:

<ul>
 <li> Briefly read the porting notes below to get an idea of what to expect.
 <li> Be sure your code compiles and runs well on all your target platforms with Qt 1.x.
 <li> Recompile with Qt 2.x.  For each error, search below for related
	identifiers (eg. function names, class names) - this documented is
	structured to mention all relevant identifiers to facilitate such
	searching, even if that makes it a little verbose.
 <li> If you get stuck, ask on the qt-interest mailing list, or
	Trolltech Technical Support if you're a Professional Edition
	licensee.
</ul>


Many very major projects, such as <a href=http://www.kde.org>KDE</a>
have been port, so there is plenty of expertise in the collective conscious
that is the Qt Developer Community!
</p>


<hr>

<h2 align=center>The Porting Notes</h2>

<ul>
 <li><b><a href="#Namespace">Namespace</a></b>
 <li><b><a href="#Virtual">Virtual Functions</a></b>
 <li><b><a href="#Collection">Collection classes</a></b>
 <li><b><a href="#DefaultParent">No Default 0 Parent Widget</a></b>
 <li><b><a href="#DebugVsRelease">Debug vs. Release</a></b>

 <li><b><a href="#QApplication">QApplication</a></b>
 <li><b><a href="#QClipboard">QClipboard</a></b>
 <li><b><a href="#QColor">QColor</a></b>
 <li><b><a href="#QDataStream">QDataStream</a></b>
 <li><b><a href="#QDialog">QDialog</a></b>
 <li><b><a href="#QDropSite">QDropSite</a></b>
 <li><b><a href="#QEvent">QEvent</a></b>
 <li><b><a href="#QFile">QFile</a></b>
 <li><b><a href="#QFontMetrics">QFontMetrics</a></b>
 <li><b><a href="#QIODevice">QIODevice</a></b>
 <li><b><a href="#QLabel">QLabel</a></b>
 <li><b><a href="#QLayout">QLayout</a></b>
 <li><b><a href="#QListView">QListView</a></b>
 <li><b><a href="#QMenuData">QMenuData</a></b>
 <li><b><a href="#QMenuData">QPopupMenu</a></b>
 <li><b><a href="#QMultiLineEdit">QMultiLineEdit</a></b>
 <li><b><a href="#QPainter">QPainter</a></b>
 <li><b><a href="#QPicture">QPicture</a></b>
 <li><b><a href="#QPoint">QPoint, QPointArray, QSize and QRect</a></b>
 <li><b><a href="#QPixmap">QPixmap</a></b>
 <li><b><a href="#QRgb">QRgb</a></b>
 <li><b><a href="#QScrollView">QScrollView</a></b>
 <li><b><a href="#QStrList">QStrList</a></b>
 <li><b><a href="#QString">QString</a></b>
 <li><b><a href="#QTextStream">QTextStream</a></b>
 <li><b><a href="#QUriDrag">QUriDrag / QUrlDrag</a></b>
 <li><b><a href="#QValidator">QComboBox</a></b>
 <li><b><a href="#QValidator">QLineEdit</a></b>
 <li><b><a href="#QValidator">QSpinBox</a></b>
 <li><b><a href="#QValidator">QValidator</a></b>
 <li><b><a href="#QWidget">QWidget</a></b>
 <li><b><a href="#QWindow">QWindow</a></b>
</ul>

<hr>

<h3><a name=Namespace>Namespace</a></h3>

<p> Qt 2.x is namespace-clean, unlike 1.x. Qt now uses very few
global identifiers. Identifiers like <code>red, blue, LeftButton,
AlignRight, Key_Up, Key_Down, NoBrush</code> etc. are now part of a
special class <code>Qt</code> (defined in qnamespace.h),
which is inherited by
most Qt classes.  Member functions of classes that inherit from QWidget,
etc. are totally unaffected, but code that is
<em>not</em> in functions of classes inherited from <code>Qt</code>,
you must qualify these identifiers like this: <code>Qt::red,
Qt::LeftButton, Qt::AlignRight</code>, etc.

<p>The <code>qt/bin/qt20fix</code> script helps to fix the code that
needs adaption, though most code does not need changing.

Compiling with -DQT1COMPATIBILITY will help you get going with Qt 2.x
- it allows all the old "dirty namespace" identifiers from Qt 1.x to
continue working.  Without it, you'll get compile errors that can
easily be fixed by searching this page for the clean identifiers.

<h3><a name=DefaultParent>No Default 0 Parent Widget</a></h3>

In Qt 1.x, all widget constructors were defined with a default value
of 0 for the parent widget. However, only the main window of the
application should be created with a 0 parent, all other widgets
should have parents. Having the 0 default made it too simple to create
bugs by forgetting to specify the parent of non-mainwindow
widgets. Such widgets would typically never be deleted (causing memory
leaks), and they would become top-level widgets, confusing the window
managers. Therefore, in Qt 2.x the 0 default parent has been removed
for the widget classes that are not likely to be used as main windows.

Note also that programs no longer need (or should) use 0 parent just
to indicate that a widget should be top-level. See
\code QWidget::isTopLevel() \endcode for details. See also the notes about
<a href=#QMenuData>QPopupMenu</a> and <a href=#QDialog>QDialog</a>
below.

<h3><a name=Virtual>Virtual Functions</a></h3>

<p> Some virtual functions have changed signature in Qt 2.x.
If you override them in derived classes, you must change the signature
of your functions accordingly.

<!-- warwick can check for additions to this with his qt-2-report -->
<ul>
 <li>\code QWidget::setStyle(GUIStyle)\endcode
 <li>\code QListView::addColumn(const char *, int)\endcode
 <li>\code QListView::setColumnText(int, const char *)\endcode
 <li>\code QListViewItem::setText(int, const char *)\endcode
 <li>\code QMultiLineEdit::insertLine(const char *, int)\endcode
 <li>\code QMultiLineEdit::insertAt(const char *, int, int, bool)\endcode
 <li>\code QSpinBox::setPrefix(const char *)\endcode
 <li>\code QSpinBox::setSuffix(const char *)\endcode
 <li>\code QToolButton::setTextLabel(const char *, bool)\endcode
 <li>\code QDoubleValidator::validate(QString &, int &)\endcode
 <li>\code QIntValidator::validate(QString &, int &)\endcode
 <li>\code QValidator::fixup(QString &)\endcode
 <li>\code QSlider::paintSlider(QPainter *, const QRect &)\endcode
</ul>

This is one class of changes that are
not detected by the compiler,
so you should mechanically search for each of
these function names in your header files, eg.

\code
egrep -w 'setStyle|addColumn|setColumnText|setText...' *.h
\endcode

Of course, you'll get a few false positives (eg. if you have a setText
function that is not in a subclass of QListViewItem).


<h3><a name=Collection>Collection classes</a></h3>

<p> The collection classes include generic
classes such as QGDict, QGList, and
the subclasses such as QDict and QList.

<p> The macro-based Qt collection classes are obsolete; use the
template-based classes instead. Simply remove includes of qgeneric.h and
replace e.g. Q_DECLARE(QCache,QPixmap) with QCache<QPixmap>.

<p> The GCI global typedef is replaced by QCollection::Item.  Only if you
make your own subclasses of the undocumented generic collection classes
will you have GCI in your code.
This change has been made to avoid collisions with other namespaces.

<p> The GCF global typedef is removed (it was not used in Qt).



<h3><a name=DebugVsRelease>Debug vs. Release</a></h3>

<p>The ASSERT macro is now a null expression if the CHECK_STATE flag
is not set (i.e. if the NO_CHECK flag is defined).

<p>The debug() function now outputs nothing if Qt was compiled with
the NO_DEBUG macro defined.


<h3><a name=QString>QString</a></h3>

QString has undergone major changes internally, and although it is highly
backward compatible, it is worth studying in detail when porting to Qt 2.x.
The Qt 1.x QString class has been renamed to QCString in Qt 2.x, though if
you use that you will incur a performance penalty since all Qt functions
that took const char* now take const QString&.

<p>
To take full advantage of the new Internationalization
functionality in Qt 2.x, the following steps are required:

    <ul>
     <li> Start converting all uses of "const char*" in parameters to
            "const QString&" - this can often be done mechanically, eg.
            using Perl.  Convert usage of char[] for temporary string
            building to QString (much software already uses QString for
            this purpose as it offers many more facilities).

            If you find that you are mixing usage of QCString, QString,
            and QByteArray, this causes lots of unnecessary copying and
            might indicate that the true nature of the data you are
            dealing with is uncertain.  If the data is NUL-terminated
            8-bit data, use QCString; if it is unterminated (ie.
            contains NULs) 8-bit data, use QByteArray; if it is text,
            use QString.
	    </p>

     <li> Put a breakpoint in \code QString::latin1()\endcode
	    to catch places where
	    Unicode information is being converted to ASCII (loosing
	    information if your user in not using Latin1).  Qt has
	    a small number of calls to this - ignore those.  As a stricter
	    alternative, compile your code with QT_NO_ASCII_CAST defined,
	    which hides the automatic conversion of QString to const char*,
	    so you can catch problems at compile time.
	    </p>

     <li> See the Qt \link i18n.html Internationalization page\endlink
	    for information about the full process of internationalizing
	    your software.
    </ul>

<p>
Points to note about the new QString are:

<dl compact>
<dt><b>Unicode</b></dt>
<dd>
 Qt now uses Unicode throughout.
 data() now returns a <em>const</em> reference to an ASCII version
 of the string - you cannot directly access the
 string as an array of bytes, because it isn't one.  Often, latin1() is
 what you want rather than data(), or just leave it to convert to
 const char* automatically.  data() is only used now to aide porting to Qt 2.x,
 and ideally you'll only need latin1() or implicit conversion when interfacing
 to facilities that do not have Unicode support.

<dt><b>Automatic-expanding</b></dt>
<dd>
A big advantage of the new QString is that it automatically expands
when you write to an indexed position.

<dt><b>QChar and QCharRef</b></dt>
<dd>
QChar are the Unicode characters that make up a QString.  A QCharRef is
a temporary reference to a QChar in a QString that when assigned to
ensures that the implicit sharing semantics of the QString are maintained.
You are unlikely to use QCharRef in your own code - but so that you
understand compiler error messages, just know that <tt>mystring[123]</tt>
is a QCharRef whenever <tt>mystring</tt> is not a constant string. A QCharRef
has basically the same functionality as a QChar, except it is more restricted
in what you can assign to it and cast it to (to avoid programming errors).

<dt><b>Use QString</b></dt>
<dd>
Try to always use QString.  If you <em>must</em>, use QCString which is the
old implementation from Qt 1.x.

<dt><b>Unicode vs. ASCII</b></dt>
<dd>
Every conversion to and from ASCII is wasted time, so try to use QString
 as much as possible rather than const char*.  This also ensures you have
 full 16-bit support.

<dt><b>Convertion to ASCII</b></dt>
<dd>
The return value from operator const char*() is transient - don't expect
 it to remain valid while you make deep function calls.
 It is valid for as long as you don't modify or destroy the QString.

<dt><b>QString is simpler</b></dt>
<dd>
Expect your code to become simpler with the new QString, especially
 places where you have used a char* to wander over the string rather
 than using indexes into the string.

<dt><b>Some hacks don't work</b></dt>
<dd>
This hack:
  use_sub_string( &my_string[index] )
 should be replaced by:
  use_sub_string( my_string.mid(index) )

<dt><b>QString(const char*, int) is removed</b></dt>
<dd>
The QString constructor taking a const char* and an integer is removed.
Use of this constructor was error-prone, since the length included the
'\0' terminator. Use QString::left(int) or QString::fromLatin1( const char*,
int ) -- in both cases the int parameter signifies the number of characters.

<dt><b>QString(int) is private</b></dt>
<dd>
The QString constructor taking an integer is now private.  This function
is not meaningful anymore, since QString does all space allocation
automatically.  99% of cases can simple be changed to use the
default constructor, QString().
<p>
In Qt 1.x the constructor was used in two ways:  accidentally,
by attempting to convert a char to a QString (the char converts to int!) -
giving strange bugs, and as a way to make a QString big enough prior to
calling \code QString::sprintf()\endcode.  In Qt 2.x, the accidental bug case is
prevented (you will get a compilation error) and QString::sprintf has
been made safe - you no longer need to pre-allocate space (though for
other reasons, sprintf is still a poor choice - eg. it doesn't pass Unicode).
The only remaining common case is conversion of 0 (NULL) to QString, which
would usually give expected results in Qt 1.x.  For Qt 2.x the correct
syntax is to use QString::null, though note that
the default constructor, QString(), creates a null string too.
Assignment of 0 to a QString is ambiguous - assign
QString::null; you'll mainly find these in code that has been converted
from const char* types to QString.
This also prevents a common error case from Qt 1.x - in
that version, mystr = 'X' would <em>not</em> produce the expected
results and was always a programming error; in Qt 2.x, it works - making
a single-character string.

<p>
Also see <a href=#QStrList>QStrList</a>.

<dt><b>Signals and Slots</b></dt>
<dd>
Many signal/slots have changed from const char* to QString.  You will
 get run-time errors when you try to \code QObject::connect()\endcode
 to the old
 signals and slots, usually with a message indicating the const QString&
 replacement signal/slot.

<dt><b>Optimize with Q2HELPER</b></dt>
<dd>
In qt/src/tools/qstring.cpp there is a Q2HELPER - define it for some
extra debugging/optimizing features (don't leave it it - it kills performance).
You'll get an extra function, qt_qstring_stats(), which will print a
summary of how much your application is doing Unicode and ASCII
back-and-forth conversions.

<dt><b>QString::detach() is obsolete and removed</b></dt>
<dd>
Since QString is now always shared, this function does nothing.
Remove calls to QString::detach().

<dt><b>QString::resize(int size) is obsolete and removed</b></dt>
<dd>
Code using this to truncate a string should use
    \link QString::truncate() truncate(size-1)\endlink.
Code using qstr.resize(0) should use qstr = QString::null.
Code calling resize(n) prior to using
    \link QString::operator[] operator[]\endlink up to n just remove
the resize(n) completely.

<dt><b>QString::size() is obsolete and removed</b></dt>
<dd>
Calls to this function must be replaced by
\link QString::length() length()\endlink+1.

<dt><b>QString::setStr(const char*) is removed</b></dt>
<dd>Try to understand why you were using this.
If you just meant assignment, use that.  Otherwise,
you are probably using QString as an array of bytes, in which case use
QByteArray or QCString instead.

<dt><b>QString is not an array of bytes</b></dt>
<dd>
Code that uses QString as an array of bytes should use QByteArray
or a char[], <em>then</em> convert that to a QString if needed.

<dt><b>"string = 0"</b></dt>
<dd>
Assigning 0 to a QString should be assigning the null string,
ie. string = QString::null.

<dt><b>System functions</b></dt>
<dd>
You may find yourself needing latin1() for passing to the operating system
 or other libraries, and be tempted to use QCString to save the conversion,
 but you are better off using Unicode throughout, then when the operating
 system supports Unicode, you'll be prepared. Some Unix operating systems
 are now beginning to have basic Unicode support, and Qt will be tracking
 these improvements as they become more widespread.

<dt><b>Bugs removed</b></dt>
<dd>
toShort() returns 0 (and sets *ok to false) on error.
toUInt() now works for big valid unsigned integers.
insert() now works into the same string.

<dt><b>NULL pointers</b></dt>
<dd>
When converting "const char*" usage to QString in order to make your
 application fully Unicode-aware, use QString::null for the null value
 where you would have used 0 with char pointers.

<dt><b>QString is not null terminated</b></dt>
<dd>
This means that inserting a 0-character
 in the middle of the string does <em>not</em> change the length().  ie.
 \code
   QString s = "fred";
   s[1] = '\0';
     // s.length() == 4
     // s == "f\0ed"
     // s.latin1() == "f"
   s[1] = 'r';
     // s == "fred"
     // s.latin1() == "fred"
 \endcode
 Especially look out for this type of code:
 \code
   QString s(2);
   s[0] = '?';
   s[1] = 0;
 \endcode
 This creates a string 2 characters long.
 To find these problems while converting, you might like to
 add ASSERT(strlen(d->ascii)==d->len) inside
 \code QString::latin1()\endcode.

<dt><b>QString or Standard C++ string?</b></dt>
<dd>
<p>
The Standard C++ Library string is not Unicode.  Nor is wstring defined
to be so (for the small number of platforms where it is defined at all).
This is the same mistake made over and over
in the history of C - only when non-8-bit characters are <em>the norm</em>
do programmers find them usable. Though it is possible to convert between
string and QString, it is less efficient than using QString throughout.
For example, when using:
\code
    QLabel::setText( const QString& )
\endcode
if you use string, like this:
\code
    void myclass::dostuffwithtext( const string& str )
    {
	mylabel.setText( QString(str.c_str()) );
    }
\endcode
that will create a (ASCII only) copy of str, stored in mylabel.
But this:
\code
    void myclass::dostuffwithtext( const QString& str )
    {
	mylabel.setText( str );
    }
\endcode
will make an implicitly shared reference to str in the QLabel - no copying
at all.  This function might be 10 nested function calls away from something
like this:
\code
    void toplevelclass::initializationstuff()
    {
	doStuff( tr("Okay") );
    }
\endcode
At this point, in Qt 2.x, the tr() does a very fast dictionary lookup
through memory-mapped message files, returning some Unicode QString for
the appropriate language (the default being to just make a QString out
of the text, of course - you're not <em>forced</em> to use any of these
features), and that <em>same</em> memory mapped Unicode will be passed
though the system.  All occurrences of the translation of "Okay" can
potentially be shared.

</dl>



<h3><a name=QApplication>QApplication</a></h3>

In the function \code QApplication::setColorSpec()\endcode,
PrivateColor and TrueColor are obsolete.  Use ManyColor instead.


<h3><a name=QColor>QColor</a></h3>

<p>
All colors
(color0,
color1,
black,
white,
darkGray,
gray,
lightGray,
red,
green,
blue,
cyan,
magenta,
yellow,
darkRed,
darkGreen,
darkBlue,
darkCyan,
darkMagenta,
and
darkYellow)
are in the Qt namespace.
In members of classes that inherit the Qt namespace-class (eg. QWidget
subclasses), you can use the unqualified names as before, but in global
functions (eg. main()), you need to qualify them:  Qt::red, Qt::white, etc.
See also the <a href=#QRgb>QRgb</a> section below.

<h3><a name=QRgb>QRgb</a></h3>

In QRgb (a typedef of long), the order of the RGB channels has changed to
be in the more efficient order (for typical contemporary hardware).  If your
code made assumptions about the order, you will get blue where you expect
red and vice versa (you'll not notice the problem if you use shades of
grey, green, or magenta).  You should port your code to use the
creator function qRgb(int r,int g,int b) and the
access functions qRed(QRgb), qBlue(QRgb), and qGreen(QRgb).
If you are using the alpha channel, it hasn't moved, but you should use
the functions qRgba(int,int,int,int) and qAlpha(QRgb). Note also that
QColor::pixel() does <i>not</i> return a QRgb (it never did on all platforms,
but your code may have assumed so on your platform) - this may also produce
strange color results - use QColor::rgb() if you want a QRgb.


<h3><a name=QDataStream>QDataStream</a></h3>

<p>The QDatastream serialization format of most Qt classes is changed
in Qt 2.x. Use \code QDataStream::setVersion( 1 )\endcode to get a
datastream object that can read and write Qt 1.x format data streams.

<p>If you want to write Qt 1.x format datastreams, note the following
compatibility issues:
	<ul>
	<li>QString: Qt 1.x has no Unicode support, so strings will be
	serialized by writing the classic C string returned by \code
	QString::latin1().\endcode
	<li><a href=#QPoint>QPoint & al.</a>: Coordinates will be
	truncated to the Qt 1.x 16 bit format.
	</ul>

<h3><a name=QWidget>QWidget</a></h3>

<h4>QWidget::recreate()</h4>
<p>
This function is now called \link QWidget::reparent() reparent()\endlink.

<h4>QWidget::setAcceptFocus(bool)</h4>
<p>
This function is removed.
Calls like QWidget::setAcceptFocus(TRUE) should be replaced by
    \code QWidget::setFocusPolicy(StrongFocus)\endcode, and
calls like QWidget::setAcceptFocus(FALSE) should be replaced by
    \code QWidget::setFocusPolicy(NoFocus)\endcode.
Additional policies are TabFocus and ClickFocus.


<h4>QWidget::paintEvent()</h4>
<p>
paintEvent(0) is not permitted - subclasses need not check for
a null event, and might crash.
Never pass 0 as the argument to paintEvent().  You probably
just want repaint() or update() instead.
<p>
When processing a paintEvent, painting is only permitted within
the update region specified in the event. Any painting outside will be
clipped away. This shouldn't break any code (it was always like this
on MS-Windows) but makes many explicit calls to
QPainter::setClipRegion() superfluous. Apart from the improved
consistency, the change is likely to reduce flicker and to make Qt
event slightly faster.

<h3><a name=QIODevice>QIODevice</a></h3>
<p>
The protected member QIODevice::index is renamed to QIODevice::ioIndex
to avoid warnings and to allow compilation with bad C libraries that
#define index to strchr.  If you have made a subclass of QIODevice,
check every occurrence of the string "index" in the implementation, since
a compiler will not always catch cases like \code(uint)index\endcode
that need to be changed.

<h3><a name=QLabel>QLabel</a></h3>

<h4>\code QLabel::setMargin()\endcode</h4>
<p>
\code QLabel::setMargin()\endcode and\code QLabel::margin()\endcode
have been renamed to \code QLabel::setIndent()\endcode and
\code QLabel::indent()\endcode, respectively. This was done to avoid
collision with QFrame::setMargin(), which is now virtual.

<h4>\code QLabel::setMovie()\endcode</h4>
<p>
Previously, setting a movie on a label cleared the value of text().
Now it doesn't.  If you somehow used <tt>QLabel::text()</tt>
to detect if a
movie was set, you might have trouble.  This is unlikely.


<h3><a name=QDialog>QDialog</a></h3>

<p> The semantics of the parent pointer changed for non-modal dialogs:
In Qt-2.x, dialogs are always toplevel windows. The parent, however,
takes the ownership of the dialog, i.e. it will delete the dialog at
destruction if it has not been explicitly deleted
already. Furthermore, the window system will be able to tell that both
the dialog and the parent belong together. Some X11 window managers
will for instance provide a common taskbar entry in that case.

<p>
If the dialog belongs to a toplevel main window
of your application, pass this main window as parent to the dialog's
constructor. Old code (with 0 pointer) will still run. Old code that
included QDialogs as child widgets will no longer work (it never really did).
If you think you might be doing this, put a breakpoint in
QDialog::QDialog() conditional on parent not being 0.


<h3><a name=QStrList>QStrList</a></h3>

Many methods that took a QStrList can now instead take a QStringList,
which is a real list of QString values.

To use QStringList rather than QStrList, change loops that look like this:
\code
    QStrList list = ...;
    const char* s;
    for ( s = list.first(); s; s = list.next() ) {
	process(s);
    }
\endcode
to be like this:
\code
    QStringList list = ...;
    QStringList::ConstIterator i;
    for ( i = list.begin(); i != list.end(); ++i ) {
	process(*i);
    }
\endcode

In general, the QStrList functions are less efficient, building a temporary QStringList.

The following functions now use QStringList rather than QStrList
for return types/parameters.

<ul>
 <li><tt>void QFileDialog::setFilters(const QStrList&)</tt>
      becomes <tt>void QFileDialog::setFilters(const QStringList&)</tt>
 <li><tt>QStrList QFileDialog::getOpenFileNames(...)</tt>
      becomes <tt>QStringList QFileDialog::getOpenFileNames(...)</tt>
 <li><tt>bool QUrlDrag::decodeLocalFiles(QMimeSource*, QStrList&)</tt>
      becomes <tt>bool QUriDrag::decodeLocalFiles(QMimeSource*, QStringList&)</tt>
 <li><tt>const QStrList *QDir::entryList(...) const</tt>
      becomes <tt>QStringList QDir::entryList(...) const</tt>
	(note that the return type is no longer a pointer).  You may also
	choose to use encodedEntryList().
</ul>

The following functions are added:
<ul>
 <li><tt>QComboBox::insertStringList(const QStringList &, int index=-1)</tt>
 <li><tt>QListBox::insertStringList(const QStringList &,int index=-1)</tt>
</ul>

The rarely used static function <tt>void
QFont::listSubstitutions(QStrList*)</tt> is replaced by <tt>QStringList
QFont::substitutions()</tt>.


<h3><a name=QLayout>QLayout</a></h3>

<p> Calling resize(0,0) or resize(1,1) will no longer work magically.
Remove all such calls. The default size of toplevel widgets will be their
\link QWidget::sizeHint() sizeHint()\endlink.

<p> The default implementation of QWidget::sizeHint() will no longer
return just an invalid size; if the widget has a layout, it will return
the layout's preferred size.

<p> The special maximum MaximumHeight/Width is now QWIDGETSIZE_MAX,
not QCOORD_MAX.

<p> \link QBoxLayout::addWidget() QBoxLayout::addWidget()\endlink
now interprets the \e alignment parameter more aggressively.  A
non-default alignment now indicates that the widget should not grow to
fill the available space, but should be sized according to sizeHint().
If a widget is too small, set the alignment to 0. (Zero indicates no
alignment, and is the default.)

<p> The class QGManager is removed. Subclasses of QLayout need to be rewritten
to use the new, much simpler \link QLayout QLayout API\endlink.

<p> For typical layouts, all use of
\link QWidget::setMinimumSize() setMinimumSize()\endlink
and
\link QWidget::setFixedSize() setFixedSize()\endlink
can be removed.
\link QLayout::activate() activate()\endlink is no longer necessary.

<p>
You might like to look at the QGrid, QVBox, and QHBox widgets - they offer
a simple way to build nested widget structures.


<h3><a name=QListView>QListView</a></h3>

<p>In Qt 1.x mouse events to the viewport where redirected to the
event handlers for the listview; in Qt 2.x, this functionality is
in QScrollView where mouse (and other position-oriented) events are
redirected to viewportMousePressEvent() etc, which in turn translate
the event to the coordinate system of the contents and call
contentsMousePressEvent() etc, thus providing events in the most
convenient coordinate system.  If you overrode QListView::MouseButtonPress(),
QListView::mouseDoubleClickEvent(), QListView::mouseMoveEvent(), or
QListView::mouseReleaseEvent() you must instead override
viewportMousePressEvent(),
viewportMouseDoubleClickEvent(), viewportMouseMoveEvent(), or
viewportMouseReleaseEvent() respectively.  New code will usually override
contentsMousePressEvent() etc.

<p>The signal QListView::selectionChanged(QListViewItem *) can now be
emitted with a null pointer as parameter. Programs that use the
argument without checking for 0, may crash.

<h3><a name=QMultiLineEdit>QMultiLineEdit</a></h3>

<p>
The protected function
\code QMultiLineEdit::textWidth(QString*)\endcode
changed to
\code QMultiLineEdit::textWidth(const QString&)\endcode.
This is unlikely to be a problem, and you'll get a compile error
if you called it.


<h3><a name=QClipboard>QClipboard</a></h3>

<p>
\code QClipboard::pixmap()\endcode now returns a QPixmap, not a QPixmap*.
The pixmap
will be \link QPixmap::isNull() null\endlink if no pixmap is on the
clipboard.  QClipboard now offers powerful MIME-based types on the
clipboard, just like drag-and-drop (in fact, you can reuse most of your
drag-and-drop code with clipboard operations).


<h3><a name=QDropSite>QDropSite</a></h3>

<P>
QDropSite is obsolete.  If you simply passed <tt>this</tt>, just remove
the inheritance of QDropSite and call
\link QWidget::setAcceptDrops() setAcceptDrops(TRUE)\endlink in the class
constructor.
If you passed something other than <tt>this</tt>,
your code will not work.  A common case is passing
the
\link QScrollView::viewport() viewport()\endlink of a QListView,
in which case,
override the
\link QScrollView::viewportDragMoveEvent() viewportDragMoveEvent()\endlink,
etc.
functions rather than QListView's dragMoveEvent() etc.  For other
cases, you will need to use an event filter to act on the drag/drop events
of another widget (as is the usual way to intercept foreign events).


<h3><a name=QScrollView>QScrollView</a></h3>

The parameters in the signal
\link QScrollView::contentsMoving() contentsMoving(int,int)\endlink
are now positive rather than negative values, coinciding with
\link QScrollView::setContentsPos setContentsPos()\endlink.  Search for
connections you make to this signal, and either change the slot they are
connected to such that it also expects positive rather than negative
values, or introduce an intermediate slot and signal that negates them.

If you used drag and drop with QScrollView, you may experience the problem
described for <a href=#QDropSite>QDropSite</a>.


<h3><a name=QTextStream>QTextStream</a></h3>

<p>
\code operator<<(QTextStream&, QChar&)\endcode does not skip whitespace.
\code operator<<(QTextStream&, char&)\endcode does,
    as was the case with Qt 1.x.  This is for backward compatibility.

<h3><a name=QUriDrag>QUriDrag</a></h3>

The class QUrlDrag is renamed to QUriDrag, and the API has been
broadened to include additional conversion routines, including
conversions to Unicode filenames (see the class documentation
for details).  Note that in Qt 1.x
the QUrlDrag class used the non-standard MIME type "url/url",
while QUriDrag uses the standardized "text/uri-list" type.  Other
identifiers affected by the Url to Uri change are
QUrlDrag::setUrls() and QUrlDrag::urlToLocalFile().

<h3><a name=QPainter>QPainter</a></h3>

<p> The GrayText painter flag has been removed. Use
\link QPainter::setPen() setPen( palette().disabled().foreground() )\endlink
instead.


<p> The RasterOp enum
(CopyROP,
        OrROP,
        XorROP,
        NotAndROP,
        EraseROP,
        NotCopyROP,
        NotOrROP,
        NotXorROP,
        AndROP, NotEraseROP,
        NotROP,
        ClearROP,
        SetROP,
        NopROP,
        AndNotROP,
        OrNotROP,
        NandROP,
        NorROP, LastROP)
is now part of the Qt namespace class, so if you
use it outside a member function, you'll need to prefix with Qt::.


<h3><a name=QPicture>QPicture</a></h3>

<p>The binary storage format of QPicture is changed, but the Qt 2.x
QPicture class can both read and write Qt 1.x format QPictures. No
special handling is required for reading; QPicture will automatically
detect the version number. In order to write a Qt 1.x format QPicture,
set the formatVersion parameter to 1 in the QPicture constructor.

<p>For writing Qt 1.x format QPictures, the compatibility issues of <a
href=#QDataStream>QDataStream</a> applies.

<p>It is safe to try to read a QPicture file generated with Qt 2.x
(without formatVersion set to 1) with a program compiled with Qt
1.x. The program will not crash, it will just issue the warning
"QPicture::play: Incompatible version 2.x" and refuse to load the
picture.



<h3><a name=QPoint>QPoint, QPointArray, QSize and QRect</a></h3>

<p>The basic coordinate datatype in these classes, QCOORD, is now 32
bit (int) instead of a 16 bit (short). The const values QCOORD_MIN and
QCOORD_MAX have changed accordingly.

<p>QPointArray is now actually, not only seemingly, a QArray of QPoint
objects. The semi-internal workaround classes QPointData and QPointVal
are removed since they are no longer needed; QPoint is used directly
instead. The function \code QPointArray::shortPoints()\endcode
provides the point array converted to short (16bit) coordinates for
use with external functions that demand that format.


<h3><a name=QImage>QImage</a></h3>

QImage uses QRgb for the colors - see <a href=#QRgb>the changes to that</a>.


<h3><a name=QPixmap>QPixmap</a></h3>

\code QPixmap::convertToImage()\endcode with bitmaps now guarantees that color0 pixels
become color(0) in the resulting QImage.  If you worked around the lack of
this, you may be able to simplify your code.  If you made assumptions
about the previous undefined behavior, the symptom will be inverted
bitmaps (eg. "inside-out" masks).

<p>
\code QPixmap::optimize(TRUE)\endcode
is replaced by
\code QPixmap::setOptimization(QPixmap::NormalOptim)\endcode
or
\code QPixmap::setOptimization(QPixmap::BestOptim)\endcode
- see the documentation
to choose which is best for your application.  NormalOptim is most like
the Qt 1.x "TRUE" optimization.


<h3><a name=QMenuData>QMenuData / QPopupMenu</a></h3>

In Qt 1.x, new menu items were assigned either an application-wide
unique identifier or an identifier equal to the index of the item, depending on the
\link QMenuData::insertItem() insertItem(...)\endlink function used.
In Qt 2.x this confusing
situation has been cleaned up: generated identifiers are always
unique across the entire application.

If your code depends on generated ids
being equal to the item's index, a quick fix is to use
\code QMenuData::indexOf(int id)\endcode
in the handling function instead. You may alternatively pass
\code QMenuData::count()\endcode
as identifier when you insert the items.

Furthermore, QPopupMenus can (and should!) be created with a parent
widget now, for example the main window that is used to display the
popup. This way, the popup will automatically be destroyed together
with its main window. Otherwise you'll have to take care of the
ownership manually.

QPopupMenus are also reusable in 2.x. They may occur in different
locations within one menu structure or be used as both a menubar
drop-down and as a context popup-menu.  This should make it possible to
significantly simplify many applications.

Last but not least, QPopupMenu no longer inherits QTableView. Instead,
it directly inherits QFrame.

<h3><a name=QValidator>QValidator (QLineEdit, QComboBox, QSpinBox) </a></h3>

\code QValidator::validate(...)\endcode
and
\code QValidator::fixup( QString & )\endcode
are now const
functions. If your subclass reimplements validate() as a
non-const function,
you will get a compile error (validate was pure virtual).

In QLineEdit, QComboBox, and QSpinBox,
setValidator(...) now takes a const pointer to a QValidator, and
validator() returns a const pointer. This change highlights the fact
that the widgets do not take the ownership of the validator (a validator is
a QObject on its own, with its own parent - you can easily set the same validator
object on many different widgets), so changing the state of
such an object or deleting it is very likely a bug.


<h3><a name=QFile>QFile, QFileInfo, QDir</a></h3>

File and directory names are now always Unicode strings (ie. QString).  If you used QString
in the past for the simplicity it offers, you'll probably have little consequence.  However,
if you pass filenames to system functions rather than using Qt functions (eg. if you use the
Unix <tt>unlink()</tt> function rather than <tt>QFile::remove()</tt>, your code will probably
only work for Latin1 locales (eg. Western Europe, the U.S.).  To ensure your code will support
filenames in other locales, either use the Qt functions, or convert the filenames via
\code QFile::encodeFilename()\endcode and \code QFile::decodeFilename()\endcode - but do it
\e just as you call the system function - code that mixes encoded and unencoded filenames
is very error prone.  See the comments in QString, such as regarding QT_NO_ASCII_CAST that
can help find potential problems.


<h3><a name=QFontMetrics>QFontMetrics</a></h3>

boundingRect(char) is replaced by
boundingRect(QChar), but since
char auto-converts to QChar, you're not likely to run into problems
with this.


<h3><a name=QWindow>QWindow</a></h3>

This class (which was just QWidget under a different name) has been
removed.  If you used it, do a global search-and-replace of the word
"QWindow" with "QWidget".


<h3><a name=QEvent>QEvent</a></h3>

<p> The global #define macros in qevent.h have been replaced by an
enum in QEvent.  Use e.g. QEvent::Paint instead of Event_Paint. Same
for all of:
Event_None,
Event_Timer,
Event_MouseButtonPress,
Event_MouseButtonRelease,
Event_MouseButtonDblClick,
Event_MouseMove,
Event_KeyPress,
Event_KeyRelease,
Event_FocusIn,
Event_FocusOut,
Event_Enter,
Event_Leave,
Event_Paint,
Event_Move,
Event_Resize,
Event_Create,
Event_Destroy,
Event_Show,
Event_Hide,
Event_Close,
Event_Quit,
Event_Accel,
Event_Clipboard,
Event_SockAct,
Event_DragEnter,
Event_DragMove,
Event_DragLeave,
Event_Drop,
Event_DragResponse,
Event_ChildInserted,
Event_ChildRemoved,
Event_LayoutHint,
Event_ActivateControl,
Event_DeactivateControl,
and
Event_User.

<p> The Q_*_EVENT macros in qevent.h have been deleted.  Use an
explicit cast instead. The macros were:
Q_TIMER_EVENT,
Q_MOUSE_EVENT,
Q_KEY_EVENT,
Q_FOCUS_EVENT,
Q_PAINT_EVENT,
Q_MOVE_EVENT,
Q_RESIZE_EVENT,
Q_CLOSE_EVENT,
Q_SHOW_EVENT,
Q_HIDE_EVENT,
and
Q_CUSTOM_EVENT.

<p> QChildEvents are now sent for all QObjects, not just QWidgets.
You may need to add extra checking if you use a QChildEvent without
much testing of its values.

<h3>All the removed functions</h3>

All <a href="removed20.html">these functions</a> have been removed in
Qt 2.x.  Most are simply cases where "const char*" has changed to
"const QString&", or when an enumeration type has moved into the Qt::
namespace (which, technically, is a new name, but your code will
compile just the same anyway).  This list is provided for completeness.

*/

// I split this to work around limitations in perl's regexp parser. --Arnt

// warwick can regenerate this with his qt-2-report

/*! \page removed20.html

\title Functions removed in  Qt 2.0

<pre>

QFileDialog::fileHighlighted(const char *)
QFileDialog::fileSelected(const char *)
QFileDialog::dirEntered(const char *)
QFileDialog::updatePathBox(const char *)
QObject::name(void) const
QFileDialog::getOpenFileName(const char *, const char *, QWidget *, const char *)
QFileDialog::getSaveFileName(const char *, const char *, QWidget *, const char *)
QFileDialog::getExistingDirectory(const char *, QWidget *, const char *)
QFileDialog::getOpenFileNames(const char *, const char *, QWidget *, const char *)
QFileDialog::setSelection(const char *)
QFileDialog::setDir(const char *)
QMessageBox::setText(const char *)
QMessageBox::setButtonText(const char *)
QMessageBox::setButtonText(int, const char *)
QMessageBox::setStyle(GUIStyle)
QMessageBox::standardIcon(QMessageBox::Icon, GUIStyle)
QMessageBox::information(QWidget *, const char *, const char *, const char *, const char *, const char *, int, int)
QMessageBox::information(QWidget *, const char *, const char *, int, int, int)
QMessageBox::warning(QWidget *, const char *, const char *, const char *, const char *, const char *, int, int)
QMessageBox::warning(QWidget *, const char *, const char *, int, int, int)
QMessageBox::critical(QWidget *, const char *, const char *, const char *, const char *, const char *, int, int)
QMessageBox::critical(QWidget *, const char *, const char *, int, int, int)
QMessageBox::about(QWidget *, const char *, const char *)
QMessageBox::aboutQt(QWidget *, const char *)
QMessageBox::message(const char *, const char *, const char *, QWidget *, const char *)
QMessageBox::buttonText(void) const
QMessageBox::query(const char *, const char *, const char *, const char *, QWidget *, const char *)
QProgressDialog::setLabelText(const char *)
QProgressDialog::setCancelButtonText(const char *)
QProgressDialog::styleChange(GUIStyle)
QProgressDialog::init(QWidget *, const char *, const char *, int)
QTabDialog::addTab(QWidget *, const char *)
QTabDialog::isTabEnabled(const char *) const
QTabDialog::setTabEnabled(const char *, bool)
QTabDialog::setDefaultButton(const char *)
QTabDialog::setCancelButton(const char *)
QTabDialog::setApplyButton(const char *)
QTabDialog::setOKButton(const char *)
QTabDialog::setOkButton(const char *)
QTabDialog::styleChange(GUIStyle)
QTabDialog::selected(const char *)
QObject::name(void) const
QApplication::setStyle(GUIStyle)
QApplication::palette(void)
QApplication::setPalette(const QPalette &, bool)
QApplication::font(void)
QApplication::setFont(const QFont &, bool)
QBrush::setStyle(BrushStyle)
QBrush::init(const QColor &, BrushStyle)
QObject::name(void) const
QClipboard::data(const char *) const
QClipboard::setData(const char *, void *)
QClipboard::setText(const char *)
QUrlDrag::decodeLocalFiles(QDropEvent *, QStrList &)
QObject::name(void) const
QStoredDrag::setEncodedData(QArrayT<char> const &)
QTextDrag::setText(const char *)
QImageDrag::canDecode(QDragMoveEvent *)
QTextDrag::canDecode(QDragMoveEvent *)
QUrlDrag::canDecode(QDragMoveEvent *)
QImageDrag::decode(QDropEvent *, QImage &)
QImageDrag::decode(QDropEvent *, QPixmap &)
QTextDrag::decode(QDropEvent *, QString &)
QUrlDrag::decode(QDropEvent *, QStrList &)
QDragMoveEvent::format(int)
QDragMoveEvent::provides(const char *)
QDragMoveEvent::data(const char *)
QDropEvent::data(const char *)
QEvent::peErrMsg(void)
QFont::substitute(const char *)
QFont::insertSubstitution(const char *, const char *)
QFont::removeSubstitution(const char *)
QFont::load(unsigned int) const
QFont::setFamily(const char *)
QFont::bold(void) const
QFont::setBold(bool)
QFont::handle(unsigned int) const
QFont::bold(void) const
QFontInfo::font(void) const
QFontInfo::reset(const QWidget *)
QFontInfo::type(void) const
QFontMetrics::inFont(char) const
QFontMetrics::leftBearing(char) const
QFontMetrics::rightBearing(char) const
QFontMetrics::width(char) const
QFontMetrics::width(const char *, int) const
QFontMetrics::boundingRect(char) const
QFontMetrics::boundingRect(const char *, int) const
QFontMetrics::boundingRect(int, int, int, int, int, const char *, int, int, int *, char **) const
QFontMetrics::size(int, const char *, int, int, int *, char **) const
QFontMetrics::font(void) const
QFontMetrics::reset(const QWidget *)
QFontMetrics::type(void) const
QObject::name(void) const
QGManager::setBorder(int)
QGManager::newSerChain(QGManager::Direction)
QGManager::newParChain(QGManager::Direction)
QGManager::add(QChain *, QChain *, int)
QGManager::addWidget(QChain *, QWidget *, int)
QGManager::addSpacing(QChain *, int, int, int)
QGManager::addBranch(QChain *, QChain *, int, int)
QGManager::setStretch(QChain *, int)
QGManager::activate(void)
QGManager::unFreeze(void)
QGManager::xChain(void)
QGManager::yChain(void)
QGManager::setMenuBar(QWidget *)
QGManager::mainWidget(void)
QGManager::remove(QWidget *)
QGManager::setName(QChain *, const char *)
QGManager::eventFilter(QObject *, QEvent *)
QGManager::resizeHandle(QWidget *, const QSize &)
QGManager::resizeAll(void)
QIconSet::setPixmap(const char *, QIconSet::Size, QIconSet::Mode)
QImage::imageFormat(const char *)
QImageIO::imageFormat(const char *)
QImage::load(const char *, const char *)
QImage::loadFromData(QArrayT<char>, const char *)
QImage::save(const char *, const char *) const
QImageIO::setFileName(const char *)
QImageIO::setDescription(const char *)
QBoxLayout::addB(QLayout *, int)
QObject::name(void) const
QLayout::basicManager(void)
QLayout::verChain(QLayout *)
QLayout::horChain(QLayout *)
QObject::name(void) const
QObject::tr(const char *) const
QPaintDevice::x11Screen(voidQPaintDevice::x11Depth(voidQPaintDevice::x11Cells(voidQPaintDevice::x11Colormap(voidQPaintDevice::x11DefaultColormap(void) QPaintDevice::x11Visual(voidQPaintDevice::x11DefaultVisual(void)
QPainter::translate(float, float)
QPainter::scale(float, float)
QPainter::shear(float, float)
QPainter::rotate(float)
QPainter::drawText(const QPoint &, const char *, int)
QPainter::drawText(const QRect &, int, const char *, int, QRect *, char **)
QPainter::drawText(int, int, const char *, int)
QPainter::drawText(int, int, int, int, int, const char *, int, QRect *, char **)
QPainter::boundingRect(int, int, int, int, int, const char *, int, char **)
QPainter::testf(unsigned short) const
QPainter::setf(unsigned short)
QPainter::setf(unsigned short, bool)
QPainter::clearf(unsigned short)
QPainter::setPen(PenStyle)
QPainter::setBrush(BrushStyle)
QPainter::setBackgroundMode(BGMode)
QPen::setStyle(PenStyle)
QPen::init(const QColor &, unsigned int, PenStyle)
QPicture::load(const char *)
QPicture::save(const char *)
QPixmap::isOptimized(void) const
QPixmap::optimize(bool)
QPixmap::isGloballyOptimized(void)
QPixmap::optimizeGlobally(bool)
QPixmap::imageFormat(const char *)
QPixmap::load(const char *, const char *, QPixmap::ColorMode)
QPixmap::load(const char *, const char *, int)
QPixmap::loadFromData(QArrayT<char>, const char *, int)
QPixmap::save(const char *, const char *) const
QPixmapCache::find(const char *)
QPixmapCache::find(const char *, QPixmap &)
QPixmapCache::insert(const char *, QPixmap *)
QPixmapCache::insert(const char *, const QPixmap &)
QPrinter::setPrinterName(const char *)
QPrinter::setOutputFileName(const char *)
QPrinter::setPrintProgram(const char *)
QPrinter::setDocName(const char *)
QPrinter::setCreator(const char *)
QRect::setX(int)
QRect::setY(int)
QRegion::exec(QArrayT<char> const &)
QObject::name(void) const
QObject::name(void) const
QSignalMapper::setMapping(const QObject *, const char *)
QSignalMapper::mapped(const char *)
QObject::name(void) const
QObject::name(void) const
QWidget::setCaption(const char *)
QWidget::setIconText(const char *)
QWidget::drawText(const QPoint &, const char *)
QWidget::drawText(int, int, const char *)
QWidget::acceptFocus(void) const
QWidget::setAcceptFocus(bool)
QWidget::create(unsigned int)
QWidget::create(void)
QWidget::internalMove(int, int)
QWidget::internalResize(int, int)
QWidget::internalSetGeometry(int, int, int, int)
QWidget::deferMove(const QPoint &)
QWidget::deferResize(const QSize &)
QWidget::cancelMove(voidQWidget::cancelResize(voidQWidget::sendDeferredEvents(voidQWidget::setBackgroundColorFromMode(voidQObject::name(void) const QWidget::setMask(QBitmapQWMatrix::setMatrix(float, float, float, float, float, float)
QWMatrix::map(float, float, float *, float *) const
QWMatrix::translate(float, float)
QWMatrix::scale(float, float)
QWMatrix::shear(float, float)
QWMatrix::rotate(float)
QBuffer::setBuffer(QArrayT<char>)
QDir::entryList(const char *, int, int) const
QDir::entryInfoList(const char *, int, int) const
QDir::mkdir(const char *, bool) const
QDir::rmdir(const char *, bool) const
QDir::exists(const char *, bool)
QDir::remove(const char *, bool)
QDir::rename(const char *, const char *, bool)
QDir::setCurrent(const char *)
QDir::match(const char *, const char *)
QDir::cleanDirPath(const char *)
QDir::isRelativePath(const char *)
QDir::setPath(const char *)
QDir::filePath(const char *, bool) const
QDir::absFilePath(const char *, bool) const
QDir::convertSeparators(const char *)
QDir::cd(const char *, bool)
QDir::setNameFilter(const char *)
QFile::setName(const char *)
QFile::exists(const char *)
QFile::remove(const char *)
QFileInfo::setFile(const QDir &, const char *)
QFileInfo::setFile(const char *)
QFile::exists(const char *)
QFileInfo::extension(void) const
QRegExp::match(const char *, int, int *) const
QRegExp::matchstr(unsigned short *, char *, char *) const
QString::resize(unsigned int)
QString::fill(char, int)
QString::find(const char *, int, bool) const
QString::findRev(const char *, int, bool) const
QString::leftJustify(unsigned int, char, bool) const
QString::rightJustify(unsigned int, char, bool) const
QString::insert(unsigned int, const char *)
QString::append(const char *)
QString::prepend(const char *)
QString::replace(const QRegExp &, const char *)
QString::replace(unsigned int, unsigned int, const char *)
QString::setStr(const char *)
QString::setNum(int)
QString::setNum(unsigned long)
QString::setExpand(unsigned int, char)
QButton::setText(const char *)
QComboBox::setEditText(const char *)
QComboBox::activated(const char *)
QComboBox::highlighted(const char *)
QComboBox::insertItem(const char *, int)
QComboBox::changeItem(const char *, int)
QComboBox::setStyle(GUIStyle)
QComboBox::setValidator(QValidator *)
QGroupBox::setTitle(const char *)
QHeader::moveAround(int, int)
QHeader::addLabel(const char *, int)
QHeader::setLabel(int, const char *, int)
QHeader::setOrientation(QHeader::Orientation)
QHeader::resizeEvent(QResizeEvent *QHeader::paintCell(QPainter *, int, intQHeader::setupPainter(QPainter *QHeader::cellHeight(intQHeader::cellWidth(int) QLabel::setText(const char *QLCDNumber::display(const char *)
QLCDNumber::resizeEvent(QResizeEvent *)
QLCDNumber::internalDisplay(const char *)
QLCDNumber::drawString(const char *, QPainter &, QBitArray *, bool)
QLCDNumber::drawDigit(const QPoint &, QPainter &, int, char, char)
QLCDNumber::drawSegment(const QPoint &, char, QPainter &, int, bool)
QLineEdit::event(QEvent *)
QLineEdit::setValidator(QValidator *)
QLineEdit::validateAndSet(const char *, int, int, int)
QLineEdit::setText(const char *)
QLineEdit::insert(const char *)
QLineEdit::textChanged(const char *)
QListBox::insertItem(const char *, int)
QListBox::inSort(const char *)
QListBox::changeItem(const char *, int)
QListBox::maxItemWidth(void)
QListBox::highlighted(const char *)
QListBoxItem::setText(const char *)
QListBox::selected(const char *)
QListViewItem::isExpandable(void)
QListView::setStyle(GUIStyle)
QMainWindow::addToolBar(QToolBar *, const char *, QMainWindow::ToolBarDock, bool)
QMenuData::insertItem(const QPixmap &, const QObject *, const char *, int)
QMenuData::insertItem(const QPixmap &, const char *, QPopupMenu *, int, int)
QMenuData::insertItem(const QPixmap &, const char *, const QObject *, const char *, int)
QMenuData::insertItem(const QPixmap &, const char *, const QObject *, const char *, int, int, int)
QMenuData::insertItem(const QPixmap &, const char *, int, int)
QMenuData::insertItem(const char *, QPopupMenu *, int, int)
QMenuData::insertItem(const char *, const QObject *, const char *, int)
QMenuData::insertItem(const char *, const QObject *, const char *, int, int, int)
QMenuData::insertItem(const char *, int, int)
QMenuData::changeItem(const QPixmap &, const char *, int)
QMenuData::changeItem(const char *, int)
QMenuData::insertAny(const char *, const QPixmap *, QPopupMenu *, int, int)
QMenuItem::setText(const char *)
QMultiLineEdit::textWidth(QString *)
QMultiLineEdit::repaintAll(void)
QMultiLineEdit::repaintDelayed(void)
QMultiLineEdit::setText(const char *)
QMultiLineEdit::append(const char *)
QPopupMenu::itemAtPos(const QPoint &)
QPopupMenu::actSig(int)
QRadioButton::mouseReleaseEvent(QMouseEvent *)
QRadioButton::keyPressEvent(QKeyEvent *)
QRangeControl::adjustValue(void)
QScrollBar::setOrientation(QScrollBar::Orientation)
QScrollView::horizontalScrollBar(void)
QScrollView::verticalScrollBar(void)
QScrollView::viewport(void)
QSlider::setOrientation(QSlider::Orientation)
QSpinBox::setSpecialValueText(const char *)
QSpinBox::setValidator(QValidator *)
QSpinBox::valueChanged(const char *)
QSpinBox::paletteChange(const QPalette &)
QSpinBox::enabledChange(bool)
QSpinBox::fontChange(const QFont &)
QSpinBox::styleChange(GUIStyle)
QSplitter::setOrientation(QSplitter::Orientation)
QSplitter::event(QEvent *)
QSplitter::childInsertEvent(QChildEvent *)
QSplitter::childRemoveEvent(QChildEvent *)
QSplitter::moveSplitter(short)
QSplitter::adjustPos(int)
QSplitter::splitterWidget(void)
QSplitter::startMoving(void)
QSplitter::moveTo(QPoint)
QSplitter::stopMoving(void)
QSplitter::newpos(void) const
QStatusBar::message(const char *)
QStatusBar::message(const char *, int)
QObject::name(void) const
QToolTipGroup::showTip(const char *)
QToolTip::add(QWidget *, const QRect &, const char *)
QToolTip::add(QWidget *, const QRect &, const char *, QToolTipGroup *, const char *)
QToolTip::add(QWidget *, const char *)
QToolTip::add(QWidget *, const char *, QToolTipGroup *, const char *)
QToolTip::tip(const QRect &, const char *)
QToolTip::tip(const QRect &, const char *, const char *)
QObject::name(void) const
QWhatsThis::add(QWidget *, const QPixmap &, const char *, const char *, bool)
QWhatsThis::add(QWidget *, const char *, bool)
QWhatsThis::textFor(QWidget *)
QWidgetStack::event(QEvent *)

</pre>

*/
