/****************************************************************************
** $Id: qt/doc/tutorial.doc   2.3.2   edited 2001-01-26 $
**
** Tutorial
**
** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
**
** This file is part of the Qt GUI Toolkit.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** This file may be distributed and/or modified under the terms of the
** GNU General Public License version 2 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.
**
** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
** licenses may use this file in accordance with the Qt Commercial License
** Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
**   information about Qt Commercial License Agreements.
** See http://www.trolltech.com/qpl/ for QPL licensing information.
** See http://www.trolltech.com/gpl/ for GPL licensing information.
**
** Contact info@trolltech.com if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

/*! \page tutorial.html


<title>
Qt Tutorial - The 14 Steps
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Tutorial: The 14 Steps</h1><br clear="all">



This tutorial gives an introduction to GUI programming using the Qt
toolkit \version .  It doesn't cover everything: The emphasis is on
teaching the programming philosophy of GUI programming, and Qt's
features are introduced as needed.  Some commonly used features are
never used in this tutorial.

Chapter one starts with a ten-line hello-world and each subsequent
chapter introduces one or a few more concepts.  By chapter 14, the ten
lines from chapter one have turned into a 650-line game.

Tutorial chapters:
<ol>
<li>\link t1.html Hello, World!\endlink
<li>\link t2.html Calling it Quits\endlink
<li>\link t3.html Family Values\endlink
<li>\link t4.html Let There Be Widgets\endlink
<li>\link t5.html Building Blocks\endlink
<li>\link t6.html Building Blocks Galore!\endlink
<li>\link t7.html One Thing Leads to Another\endlink
<li>\link t8.html Preparing for Battle\endlink
<li>\link t9.html With Cannon You Can\endlink
<li>\link t10.html Smooth as Silk\endlink
<li>\link t11.html Giving It a Shot\endlink
<li>\link t12.html Hanging in the Air the Way Bricks Don't\endlink
<li>\link t13.html Game Over\endlink
<li>\link t14.html Facing the Wall\endlink
</ol>

This little game doesn't look much like a modern GUI application.  It
uses a good few of the GUI techniques, but after you've worked through
it, we recommend reading the \link simple-application.html Simple
Application Walkthrough \endlink too.  That discusses a very simple
application with all the common features (menu bars, tool bars,
on-line help, printing, a couple of dialogs) in detail.

*/


------------------------------------------------------------------------------


/*! \page t1.html


<title>
Qt Tutorial - Chapter 1: Hello, World!
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 1: Hello, World!</h1><br clear="all">



<center><img src="t1.png" alt="Screenshot of tutorial one"></center>

This first program is a simple hello-world example.  It contains only
the bare minimum you need to get a Qt application up and running.
The picture above is a snapshot of this program.

\include t1/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip include
\line qapp

This line includes the QApplication class definition.  There has to be
exactly one QApplication object in every application that uses Qt.
QApplication manages various application-wide resources, such as the
default font and cursor.

\line qpushbutton

This line includes the QPushButton class definition.  The <a
href="hierarchy.html">reference documentation</a> for each class
mentions at the top which file needs to be included to use that class.

QPushButton is a classical GUI push button, which the user can press
and release.  It manages its own look and feel, like every other \l
QWidget.  A widget is a user interface object which can process user
input and draw graphics.  The programmer can change both the overall
\link QApplication::setStyle() look and feel\endlink and many minor
properties of it such as color, as well as the widget's content.  A
QPushButton can show either a text or a \l QPixmap.

\line main
\line {

The \c main() function is the entry point to the program.  Almost always
when using Qt, main() only needs to perform some kind of initialization
before passing the control to the Qt library, which then tells the
program about the user's actions via events.

\c argc is the number of command-line arguments and \c argv is the array
of command-line arguments.  This is a C/C++ feature.  It is not Qt specific,
however, Qt needs to process these arguments (see below).

\line QApplication

\c a is this program's QApplication.  Here it is created and processes
some of the command-line arguments (such as -display under X11).
Note that all command-line arguments recognized by Qt are removed from
\c argv (and \c argc is decremented accordingly).  See the \link
QApplication::argv() QApplication::argv()\endlink documentation for
details.

<strong>Note:</strong> It is essential that the QApplication object is
created before any window-system parts of Qt are used.

\line QPushButton

Here, \e after the QApplication, comes the first window-system code: A
push button is created.

The button is set up to display the text "Hello world!" and be a
window of its own (since the constructor specifies 0 for the parent
window which the button should be inside).

\line resize

The button is set up to be 100 pixels wide and 30 pixels high (plus the
window system frame).  In this case we don't care about the button's
position and accept the default value.

\line setMainWidget

The push button is chosen as the main widget for the application.  If
the user closes a main widget, the application exits.

You don't have to have a main widget, but most programs have one.

\line show

A widget is never visible when you create it.  You must call show() to
make it visible.

\line exec

This is where \c main() passes control to Qt.  exec() will return when
the application exits.

In exec(), Qt receives and processes user and system events and passes
these on to the appropriate widgets.

\line }

<h2>Behavior</h2>

You should now try to compile and run this program.

When you run it, you will see a small window filled with a single
button, and on it you can read the famous words, Hello World!

<h2>Exercises</h2>

Try to resize the window.  Press the button.  If you're running X11,
try running the program with the -geometry option
(e.g.  -geometry 100x200+10+20)

You may now go on to \link t2.html chapter two.  \endlink

[\link t2.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t2.html


<title>
Qt Tutorial - Chapter 2: Calling it Quits
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 2: Calling it Quits</h1><br clear="all">



<center><img src="t2.png" alt="Screenshot of tutorial two"></center>

Having created a window in \link t1.html chapter one, \endlink we will
now go on to make the application quit properly when the user tells it to.

We will also use a font that is more exciting than the default one.

\include t2/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip qfont
\line qfont

Since this program uses QFont, it needs to include qfont.h.  Qt's font
abstraction is rather different from the horror provided by X, and
loading and using fonts has been highly optimized.

\skip QPushButton
\line QPushButton

This time, the button says "Quit" and that's exactly what the program
will do when the user clicks the button.  This is not a coincidence.
We still pass 0 as the parent, since the button is a top-level window.

\line resize

We've chosen another size for the button since the text is a bit
shorter than "Hello world!".  We could also have used \l QFontMetrics
to set right size.

\line setFont

Here we choose a new font for the button, an 18-point bold font from
the Times family.  Note that we create the font on the spot.

It is also possible to change the default font (using \l
QApplication::setFont()) for the whole application.

\line connect

connect() is perhaps \e the most central feature of Qt.
Note that connect() is a static function in QObject.  Do not confuse it
with the connect() function in the socket library.

This line establishes a one-way connection between two Qt objects (objects
that inherit QObject, directly or indirectly).  Every Qt object can have
both \c signals (to send messages) and \c slots (to receive messages).  All
widgets are Qt objects.  They inherit QWidget which in turn inherits
QObject.

Here, the \e clicked() signal of \e quit is connected to the \e
quit() slot of \e a, so that when the button is clicked, the
application quits.

The \link signalsandslots.html Signals and Slots\endlink documentation
describes this topic in detail.

<h2>Behavior</h2>

When you run this program, you will see an even smaller window than in
chapter one, filled with an even smaller button.

<h2>Exercises</h2>

Try to resize the window.  Press the button.  Oops!  That connect()
would seem to make some difference :)

Are there any other signals in QPushButton you can connect to quit?
Hint: The QPushButton inherits most of its behavior from QButton.

You may now go on to \link t3.html chapter three.  \endlink

[\link t1.html Previous tutorial\endlink]
[\link t3.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t3.html


<title>
Qt Tutorial - Chapter 3: Family Values
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 3: Family Values</h1><br clear="all">



<center><img src="t3.png" alt="Screenshot of tutorial three"></center>

This example shows how to create mother and child widgets.

We'll keep it simple and use just a single mother (uh, family values?)
and a lone child.

\include t3/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip qvbox.h
\line qvbox.h

We add an include of qvbox.h, to get the layout class we'll use.

\skip QVBox
\line QVBox

Here we simply create a vertical box container.  The QVBox arranges
its child widgets in a vertical row, one above the other, handing out
space according to each child's \l QWidget::sizePolicy().

\line resize

We set its width to 200 pixels and the height to 120 pixels.

\line quit

A child is born.

This QPushButton is created with both a text, "Quit", and a mother,
box.  A child widget is always on top of its mother.  When displayed,
it is clipped by its mother's bounds.

The mother widget, the QVBox, automatically adds the child, centered
in its box.  Since nothing else is added, the button gets all the
space the mother has.

\skip show
\line show

When a mother widget is shown, it will call show for all its children
(except those on which you have done an explicit \l QWidget::hide()).

<h2>Behavior</h2>

The button no longer fills the entire widget.  Instead, it gets a
"natural" size.  This is because there is now a new top-level widget,
which uses layout management to set a good size and position for the
button.

<h2>Exercises</h2>

Try resizing the window.  How does the button change?  What is the
button's size change policy?  What happens if you try to make the
window \e really small?

You may now go on to \link t4.html chapter four.  \endlink

[\link t2.html Previous tutorial\endlink]
[\link t4.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t4.html


<title>
Qt Tutorial - Chapter 4: Let There Be Widgets
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 4: Let There Be Widgets</h1><br clear="all">



<center><img src="t4.png" alt="Screenshot of tutorial four"></center>

This example shows how to create your own widget, how to control the
minimum and maximum sizes of a widget, and introduces widget names.

\include t4/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip MyWidget
\until }

Here we create a new class.  Since this class inherits from QWidget,
the new class is a widget, and may be a top level window or a child
widget (like the push button in chapter three).

This class has only one member, a constructor (in addition to the
members it inherits from QWidget).  The constructor is a standard Qt
widget constructor; you should always include a similar constructor
when you create widgets.

The first argument is its parent widget.  To create a top level window
you specify a null pointer as the parent.  As you can see, this widget
defaults to be a top level window.

The second argument is the widget's name.  This is \e not the text
that appears in the window's title bar or in the button.  It is a name
associated with a widget to make it possible to \link
QObject::queryList() look up \endlink this widget later, and there is
also a \link QObject::dumpObjectTree() handy debugging function
\endlink that will list a complete widget hierarchy.

\line MyWidget
\line QWidget

The implementation of the constructor starts here.  Like most widgets,
it just passes on the \c parent and \c name to the QWidget
constructor.

\until setMaximumSize

Since this widget doesn't know how to handle resizing, we fix its size
by setting the minimum and maximum to be equal.  In the next chapter,
we will show how a widget can respond to resize event from the user.

\until setFont

Here we create and set up a child widget of this widget (the new widget's
parent is \c this) which has the widget name "quit".  The widget
name has nothing to do with the button text, they just happen to be
similar in this case.

Note that \c quit is a local variable in the constructor.  MyWidget
does not keep track of it, but Qt does, and will by default delete it
when MyWidget is deleted.  This is why MyWidget doesn't need a
destructor.  (On the other hand, there is no harm in deleting a child
when you choose to, the child will automatically tell Qt about its
imminent death.)

The setGeometry() call does the same as move() and resize() did in the
previous chapters.

\line qApp
\line }

Since the MyWidget class doesn't know about the application object, it
has to connect to Qt's pointer to it, \c qApp.

A widget is a software component and should know as little as possible
about its environment in order to be as general and reusable as
possible.

Knowing the name of the application object would break this principle,
so Qt offers an alias, qApp, for the cases where a component such as
MyWidget needs to talk to the application object.

\until }

Here we instantiate our new baby, set it to be the main widget, and
execute the application.

<h2>Behavior</h2>

This program is very similar in behavior to the previous one.  The
difference lies in the way we have implemented it.  It does behave
slightly different though.  Just try to resize it to see.

<h2>Exercises</h2>

Try to create another MyWidget object in main().  What happens?

Try to add more buttons, or put in widgets other than QPushButton.

You may now go on to \link t5.html chapter five.  \endlink

[\link t3.html Previous tutorial\endlink]
[\link t5.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t5.html


<title>
Qt Tutorial - Chapter 5: Building Blocks
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 5: Building Blocks</h1><br clear="all">



<center><img src="t5.png" alt="Screenshot of tutorial five"></center>

This example shows how to create and connect together several widgets
using signals and slots, and how to handle resize events.

\include t5/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip qapp
\until qvbox

Three new include files here.  qslider.h and qlcdnumber.h are there
because we use two new widgets; QSlider and QLCDNumber.  qvbox.h is
there because we use Qt's automatic layout support.

\skip MyWidget
\until }

<a name=constructor></a>
\until {

MyWidget is now derived from QVBox instead of QWidget. That way we use
the layout of the QVBox (which places all of its children vertically
inside itself). Resizes are handled automatically by the QVBox and
therefore by MyWidget too, now.

\skip lcd
\line lcd

\c lcd is a QLCDNumber, a widget which displays numbers in an LCD-like
fashion.  This instance is set up to display two digits, be a child of
\e this and is named "lcd".

\line QSlider
\line slider
\line slider

QSlider is a classical slider; a widget where the user can drag
something to adjust an integer value in a range.  Here, we create a
horizontal one, set its range to 0-99 (inclusive, see the \l
QSlider::setRange() documentation) and its initial value to 0.

\line connect

Here we use the \link signalsandslots.html signal/slot mechanism \endlink
to connect the slider's valueChanged() signal to the LCD number's
display() slot.

Whenever the slider's value changes, it broadcasts the new value by
emitting the valueChanged() signal.  Since that signal is connected to
the LCD number's display() slot, the slot is called when the signal is
broadcast.  Neither of the objects know about the other.  This is
essential in component programming.

Slots are otherwise normal C++ member functions and follow the normal
C++ access rules.

<h2>Behavior</h2>

The LCD number reflects everything you do to the slider, and the
widget handles resizing well.  Notice how the LCD number widget
changes in size when the window is resized (because it can), but the
others stay about the same (because they would look stupid otherwise).

<h2>Exercises</h2>

Try changing the LCD number to add more digits or \link
QLCDNumber::setMode() change mode.  \endlink You can even add four push
buttons to set the number base.

You can also change the slider's range.

Perhaps it would have been better to use \l QSpinBox than a slider?

Try to make the application quit when the LCD number overflows.

You may now go on to \link t6.html chapter six.  \endlink

[\link t4.html Previous tutorial\endlink]
[\link t6.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t6.html


<title>
Qt Tutorial - Chapter 6: Building Blocks Galore!
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 6: Building Blocks Galore!</h1><br clear="all">



<center><img src="t6.png" alt="Screenshot of tutorial six"></center>

This example shows how to encapsulate two widgets into a new component and
how easy it is to use many widgets.  For the first time, we use a custom
widget as a child widget.

<a name=main></a>
\include t6/main.cpp

<h2>Line by Line Walk-Through</h2>

\skip LCDRange
\until };

The LCDRange widget is a widget without any API.  It just has a
constructor.  This sort of widget is not very useful, so later on
we'll add some API.

\until }

This is lifted straight from the <a
href="t5.html#constructor">MyWidget constructor</a> in chapter five.
The only differences are that the button is left out and the class
renamed.

\line MyWidget
\until }

MyWidget, too, contains no API except a constructor.

\line MyWidget
\until connect

The push button that used to be in what's now LCDRange has been
separated, so that we can have one "Quit" button and many LCDRange
objects.

\line grid

We create a QGrid object with four columns.  The QGRid widget
automatically arranges its children in rows and columns; you can
specify the number of rows or of columns, and QGrid will discover its
new children and fit them into the grid.

\line for
\line for
\line LCDRange

Four columns, for rows.

We create 4*4 LCDRanges, all of which children of the grid object.
The QGrid widget will arrange them.

\line }

That's all.

<h2>Behavior</h2>

This program shows how easy it is to use many widgets at a time.  Each
single one behaves like the slider and LCD number in the previous
chapter.  Again, the difference lies in the implementation.

<h2>Exercises</h2>

Initialize each slider with a different/random value on startup.

The source contains three occurrences of "4".  What happens if you
change the one in the \l QGrid constructor call?  What about the other
two?  Why is this?

You may now go on to \link t7.html chapter seven.  \endlink

[\link t5.html Previous tutorial\endlink]
[\link t7.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t7-lcdrange-h.html
<title>
Qt Tutorial - t7/lcdrange.h
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Source code for \link t7.html tutorial 7\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t7/lcdrange.h
*/

/*! \page t7-lcdrange-cpp.html
<title>Qt Tutorial - t7/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t7.html tutorial 7\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t7/lcdrange.cpp
*/

/*! \page t7-main-cpp.html
<title>Qt Tutorial - t7/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t7.html tutorial 7\endlink: main.cpp</h1><br clear="all">
<hr>
\include t7/main.cpp
*/

/*! \page t7-makefile.html
<title>Qt Tutorial - t7/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t7.html tutorial 7\endlink</h1><br clear="all">
<hr>
\include t7/Makefile
*/



/*! \page t7.html


<title>
Qt Tutorial - Chapter 7: One Thing Leads to Another
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 7: One Thing Leads to Another</h1><br clear="all">



<center><img src="t7.png" alt="Screenshot of tutorial seven"></center>

This example shows how to create custom widgets with signals and
slots, and how to connect them together in more complex ways.  For the
first time, the source is split among several files.

<ul>
<li>\link t7-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t7-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t7-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t7-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>\link t7-lcdrange-h.html lcdrange.h\endlink</h3>

This file is mainly lifted from <a href="t6.html#main">main.cpp</a> in
chapter 6 and only the changes are noted here.

\dontinclude t7/lcdrange.h

\skip ifndef
\until define

This is the classic C construction to avoid errors if a header file
happens to be included more than once.  If you don't use it already:
It is a very good habit.  The #ifndef should enclose \e all of the
header file.

\line include

\c qvbox.h is included.  LCDRange inherits QVBox, and the header file
of a parent class must always be included.  We cheated a bit in the
previous chapters, and let \c qwidget.h be included indirectly via
other header files like \c qpushbutton.h.

\line QSlider

This is another classic trick, but one that's much less used.  Since
we don't need QSlider in the \e interface of the class, only in the
implementation, we use a forward declaration of the class in the
header file, and #include the header file for QSlider in the .cpp
file.

This makes compilation of big projects much faster, since when a
header file has changed, fewer files need to be recompiled.  It can
often speed up big compilations by a factor of two or more.

\skip LCDRange
\until parent=0

Note the Q_OBJECT.  This macro must be included in \e all classes that
contain signals and/or slots.  If you are curious, it defines the
functions that are implemented in the
<a href="metaobjects.html">meta object file.</a>

\line value
\until valueChanged

These three members make up an interface between this widget and other
components in a program.  Until now, LCDRange didn't really have an
interface at all.

value() is a public function for accessing the value of the LCDRange.
setValue() is our first custom slot and valueChanged() is our first
custom signal.

Slots must be implemented in the normal way (remember, a slot is also
a C++ member function).  Signals are automatically implemented in the
\link signalsandslots.html meta object\endlink file.  Signals follow the
access rules of protected C++ functions, i.e.  they can only be emitted
by the class they are defined in or by classes inheriting from it.

The signal valueChanged() is used when the LCDRange's value has
changed - just as you guessed from the name.  This is not the last
signal you'll see called <i>something</i>Changed().

<h3>\link t7-lcdrange-cpp.html lcdrange.cpp\endlink</h3>

\dontinclude t7/lcdrange.cpp

This file is mainly lifted from <a href="t6.html#main">t6/main.cpp</a> and
only the changes are noted here.

\skip connect
\line connect
\line display
\line connect
\line valueChanged

This code is from the LCDRange constructor.

The first connect is the same you've seen in the previous chapter.
The second is new: It connects slider's valueChanged() signal to this
object's valueChanged \e signal.  connect() with 3 arguments always
connect to signals or slots in \c this object.

Yes, that's right.  Signals can be connected to other signals.  When
the first is emitted, the second signal is also emitted.

Let's look at what happens when the user operates the slider: The
slider sees that its value has changed, and emits the valueChanged()
signal.  That signal is connected both to the display() slot of the
QLCDNumber and to the valueChanged() signal of the LCDRange.

Thus, when the signal is emitted, LCDRange emits its own
valueChanged() signal.  In addition, QLCDNumber::display() is called
and shows the new number.

Note that you're not guaranteed any particular order of execution -
LCDRange::valueChanged() may be emitted before or after
QLCDNumber::display(), entirely arbitrarily.

\skip LCDRange::value
\until }

The implementation of value() is straight forward, it simply returns
the slider's value.

\line setValue
\until }

The implementation of setValue() is equally straight forward.  Note
that since the slider and LCD number are connected, setting the
slider's value automatically updates the LCD number as well.  In
addition, the slider will automatically adjust the value if it is
outside its legal range.

<h3>\link t7-main-cpp.html main.cpp\endlink</h3>
\dontinclude t7/main.cpp

\skip previous
\line previous
\until setValue
\line previous
\line }
\line }

All of main.cpp is copied from the previous chapter, except that in
the constructor for MyWidget, when we create the 16 LCDRange object we
now connect them together using the \link signalsandslots.html
signal/slot\endlink mechanism.  Each one has its valueChanged() signal
connected to the setValue() slot in the previous one.  Since LCDRange
emits the signal valueChanged() when its value changes (surprise!), we
are here creating a "chain" of signals and slots.

<h2>Behavior</h2>

On startup, the program's appearance is identical to the previous one.
Try operating the slider to the bottom right...

<h2>Exercises</h2>

Use the bottom right slider to set all LCDs to 50.  Then set the top
half to 40 by clicking once to the left of the slider handle.  Now,
use the one to the left of the last one operated to set the first
seven LCDs back to 50.

Click to the left of the handle on the bottom right slider.  What
happens?  Why is this the correct behavior?

You may now go on to \link t8.html chapter eight.  \endlink

[\link t6.html Previous tutorial\endlink]
[\link t8.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t8-lcdrange-h.html
<title>Qt Tutorial - t8/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t8.html tutorial 8\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t8/lcdrange.h
*/

/*! \page t8-lcdrange-cpp.html
<title>Qt Tutorial - t8/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t8.html tutorial 8\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t8/lcdrange.cpp
*/

/*! \page t8-cannon-h.html
<title>Qt Tutorial - t8/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t8.html tutorial 8\endlink: cannon.h</h1><br clear="all">
<hr>
\include t8/cannon.h
*/

/*! \page t8-cannon-cpp.html
<title>Qt Tutorial - t8/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t8.html tutorial 8\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t8/cannon.cpp
*/

/*! \page t8-main-cpp.html
<title>Qt Tutorial - t8/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t8.html tutorial 8\endlink: main.cpp</h1><br clear="all">
<hr>
\include t8/main.cpp
*/

/*! \page t8-makefile.html
<title>Qt Tutorial - t8/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t8.html tutorial 8\endlink</h1><br clear="all">
<hr>
\include t8/Makefile
*/



/*! \page t8.html


<title>
Qt Tutorial - Chapter 8: Preparing for Battle
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 8: Preparing for Battle</h1><br clear="all">



<center><img src="t8.png" alt="Screenshot of tutorial eight"></center>

In this example, we introduce the first custom widget that can paint
itself.  We also add a useful keyboard interface (with two lines of
code).

<ul>
<li>\link t8-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t8-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t8-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t8-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t8-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t8-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>\link t8-lcdrange-h.html lcdrange.h\endlink</h3>

This file is very similar to the lcdrange.h in chapter 7.  We have added
one slot, setRange().

\dontinclude t8/lcdrange.h

\skip setRange
\line setRange

We now add the possibility of setting the range of the LCDRange.
Until now, it has been fixed at 0..99.

<h3>\link t8-lcdrange-cpp.html lcdrange.cpp\endlink</h3>

\dontinclude t8/lcdrange.cpp

There is a change to the constructor, we'll discuss that later.

\skip ::setRange
\until slider
\line }

setRange() sets the range of the slider in the LCDRange.  Since we
have set up the QLCDNumber to always display two digits, we want to
limit the possible range of \c minVal and \c maxVal to 0..99 to avoid
overflow of the QLCDNumber.  (We could have allowed values down to -9
but chose not to.)  If the arguments are illegal, we use Qt's
qWarning() function to issue a warning to the user and return
immediately.  qWarning() is a printf-like function that by default
sends its output to \c stderr.  You can install your own handler
function using \l ::qInstallMsgHandler() if you want.

<h3>\link t8-cannon-h.html cannon.h\endlink</h3>

CannonField is a new custom widget that knows how to display itself.

\dontinclude t8/cannon.h

\skip include
\skip class
\until parent=0

CannonField inherits QWidget and we use the same idiom as for LCDRange.

\until angleChanged

For the time being, CannonField only contains an angle value for which we
provide an interface using the same idiom as for value in LCDRange.

\line protected
\line paintEvent

This is the second of the many event handlers in QWidget that we
encounter.  This virtual function is called by Qt whenever a widget needs
to update itself (i.e.  paint the widget's surface).


<h3>\link t8-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t8/cannon.cpp

\skip ::CannonField
\until {

Again, we use the same idiom as for LCDRange in the previous chapter.

\until }

The constructor initializes the angle value to 45 degrees, and sets a
custom palette for this widget.

This palette uses the indicated color as background, and picks other
colors suitably.  (For this widget, only the background and text
colors will be used.)

\skip ::setAngle
\until emit
\line }

This function sets the angle value.  We have chosen a legal range of
5..70 and adjust the given number of degrees accordingly.  We have
chosen not to issue a warning if the new angle is out of range.

If the new angle equals the old one, we return immediately.  It is
important to only emit the signal angleChanged() when the angle \e
really has changed.

Then we set the new angle value and repaint our widget.  The \l
QWidget::repaint() function clears the widget (usually filling it with
its background color) and send a paint event to the widget.  This
results in a call the paint event function of the widget.

Finally, we emit the angleChanged() signal to tell the outside world
that the angle has changed.  The \c emit keyword is unique to Qt and
not regular C++ syntax.  In fact, it is a macro.

\skip ::paintEvent
\until drawText
\line }

This is our first attempt to write a paint event handler.  The event
argument contains a description of the paint event.  \l QPaintEvent
contains the region in the widget that must be updated.  For the time
being, we will be lazy and just paint everything.

Our code displays the angle value in the widget at a fixed position.
First we create a QString with some text and the angle, then we create
a QPainter operating on this widget, and use it to paint the string.
We'll come back to QPainter later; it can do a great many things.


<h3>\link t8-main-cpp.html main.cpp\endlink</h3>

\dontinclude t8/main.cpp

\skip cannon.h
\line cannon.h

We include our new class.

\skip MyWidget
\until };

This time, we include a single LCDRange and a CannonField in our top level
widget.

\skip angle
\line angle

In the constructor, we create and set up our LCDRange.

\line setRange

We set the LCDRange to accept ranges from 5 to 70 degrees.

\line cannonField
\line CannonField

We create our CannonField.

\until setValue

Here we connect the valueChanged() signal of the LCDRange to the
setAngle() slot of the CannonField.  This will update CannonField's angle
value whenever the user operates the LCDRange.  We also make the reverse
connection, so that changing the angle in the CannonField will update the
LCDRange value.  In our example, we never change the angle of the
CannonField directly, but by doing the last connect(), we ensure that no
future changes will disrupt the synchronization between those two values.

This illustrates the power of component programming and proper
encapsulation.

Notice how important it is to only emit the angleChanged() signal when
the angle actually changes.  If both the LCDRange and the CannonField
had omitted this check, the program would have entered an infinite
loop upon the first change of one of the values.

\line QGridLayout
\line 2x2

Until now we've used the no-assembly-required QVBox and QGrid widgets
for geometry management.  However, now we want to have a little more
control over the layout, and switch to the more powerful QGridLayout
class.  QGridLayout isn't a widget, it is a different class that can
manage the children of \e any widget.

As the comment indicates, we create a two-by-two array, with ten pixel
borders.  (The constructor for \l QGridLayout can be a little cryptic,
so it's good to put in such comments.)

\line addWidget

We add the Quit button in the top-left cell of the grid: 0, 0.

\line addWidget

We put the angle LCDRange in the bottom-left cell, aligned to the top
of its cell.  (This alignment is one of the things QGridLayout allows
but QGrid does not.)

\line addWidget

We put the CannonField object in the bottom right cell.  (The top
right cell is empty, yes.)

\line setColStretch

We tell QGridLayout that the right column (column 1) is stretchable.
Since the left column isn't (it has stretch factor 0 - the default
value), QGridLayout will try to let the left-hand widgets' sizes be
unchanged and resize just the CannonField when the MyWidget is
resized.

\line setValue

We set an initial angle value.  Note that this will trigger the
connection from LCDRange to CannonField.

\line setFocus

And our last action is to set \c angle to have keyboard focus, so that
by default, keyboard input will go to the LCDRange widget.

LCDRange does not contain any keyPressEvent(), so that would seem not
to be terribly useful.  However, its constructor just got a new line:

\dontinclude t8/lcdrange.cpp
\skip setFocusProxy
\line setFocusProxy

The LCDRange sets the slider to be its focus proxy.  That means that
when someone (the program or the user) wants to give the LCDRange
keyboard focus, the slider should take care of it.  QSlider has a decent
keyboard interface, so with just one line of code we've give LCDRange
one.

<h2>Behavior</h2>

The keyboard now does something - the arrow keys, Home, End, PageUp
and PageDown now all do something vaguely sensible.

When the slider is operated, the CannonField displays the new angle
value.  Upon resize, CannonField is gives as much space as possible.

On Windows machines with an 8-bit display, the new background color is
dithered to death.  The next chapter works around this.

<h2>Exercises</h2>

Try to resize the window.  What happens if you make it really narrow
or really squat?

If you remove the AlignTop, what happens to the LCDRange's position
and size?  Why?

If you give the left-hand column a non-zero stretch factor, what
happens when you resize the window?

Leave out the setFocus() call.  Which behavior do you prefer?

Try to change "Quit" to "&Quit" in the QButton::setText() call.  How
does the button's look change?  What happens if you press Alt-Q while
the program's running?  (Meta-Q on a few keyboards.)

Center the text in the CannonField.

You may now go on to \link t9.html chapter nine.  \endlink

[\link t7.html Previous tutorial\endlink]
[\link t9.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t9-lcdrange-h.html
<title>Qt Tutorial - t9/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t9.html tutorial 9\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t9/lcdrange.h
*/

/*! \page t9-lcdrange-cpp.html
<title>Qt Tutorial - t9/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t9.html tutorial 9\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t9/lcdrange.cpp
*/

/*! \page t9-cannon-h.html
<title>Qt Tutorial - t9/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t9.html tutorial 9\endlink: cannon.h</h1><br clear="all">
<hr>
\include t9/cannon.h
*/

/*! \page t9-cannon-cpp.html
<title>Qt Tutorial - t9/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t9.html tutorial 9\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t9/cannon.cpp
*/

/*! \page t9-main-cpp.html
<title>Qt Tutorial - t9/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t9.html tutorial 9\endlink: main.cpp</h1><br clear="all">
<hr>
\include t9/main.cpp
*/

/*! \page t9-makefile.html
<title>Qt Tutorial - t9/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t9.html tutorial 9\endlink</h1><br clear="all">
<hr>
\include t9/Makefile
*/



/*! \page t9.html


<title>
Qt Tutorial - Chapter 9: With Cannon You Can
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 9: With Cannon You Can</h1><br clear="all">



<center><img src="t9.png" alt="Screenshot of tutorial nine"></center>

In this example, we become graphic, by drawing a cute little blue
cannon.  Only cannon.cpp differs from the previous chapter.

<ul>
<li>\link t9-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t9-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t9-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t9-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t9-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t9-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>\link t9-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t9/cannon.cpp

\skip ::paintEvent
\until QPainter

We'll now start to use QPainter in earnest.  We create a painter that
operates on this widget.

\line setBrush

When QPainter fills a rectangle, a circle or something, it fills the
shape using its brush.  Here, we set it to use a blue brush.  (We
could also use a pattern.)

\line setPen

And the edges of what QPainter draws are drawn using the pen.  Here we
set it to NoPen, meaning that there will be no special edge when we
draw something.  The blue brush will go all the way to the edges of
the things we draw.

\skip translate
\line translate

The \l QPainter::translate() function translates the coordinate system
of the QPainter, i.e.  moves it by an offset.  Here we set the (0,0)
point to the bottom left corner of the widget.  The x and y directions
remain unchanged, i.e.  all the y coordinates inside the widget are now
negative (see \link coordsys.html The Coordinate System\endlink for
more information about Qt's coordinate system).

\line drawPie

The drawPie() function draws a pie shape inside the specified
rectangle using a start angle and an arc length.  The angles are
specified in 1/16th of a degree.  Zero degrees is at the 3 o'clock
position.  The drawing direction is counter-clockwise.  Here we draw a
quarter of a circle in the bottom left corner of the widget.  The pie
is filled with blue and has no outline.

\line rotate

The QPainter::rotate() function rotates the coordinate system of the
QPainter around the origin.  The rotation argument is a \c float given
in degrees (not given in 1/16th of a degree as above) and clockwise.
Here we rotate the coordinate system \c ang degrees counter-clockwise.

\line drawRect

The QPainter::drawRect() function draws the specified rectangle.  Here
we draw the barrel of the cannon.

It can often be difficult to envision the resulting drawing when the
coordinate system has been transformed (translated, rotated, scaled or
sheared) as above.

In this case, the coordinate system is first translated, then rotated.
If the rectangle QRect(33, -4, 15, 8) had been drawn in the translated
coordinate system, it would have looked like this:

<img src="t9_1.png" alt="The cannon, translated but not rotated">

Note that the rectangle is clipped by the border of the CannonField
widget.  When we rotate the coordinate system, for instance 60
degrees, the rectangle will be rotated around (0,0), which is the
bottom left corner, since we have translated the coordinate system.
The result looks like this:

<img src="t9_2.png" alt="The cannon, translated and rotated">

We're done, except that we haven't explained why Windows didn't dither
this time.

\dontinclude t9/main.cpp
\skip main
\line main
\line {
\line CustomColor
\line QApplication

We tell Qt that we want a different color allocation strategy for this
program.  There is no single correct color allocation strategy.  Since
this program uses an unusual yellow but not many colors, \c
CustomColor is best.  There are several other allocation strategies.
You can read about them in the \l QApplication::setColorSpec()
documentation.

Mostly, you can ignore this - the default is good.  Occasionally some
applications with unusual color use look bad, and often changing the
allocation strategy helps.

<h2>Behavior</h2>

When the slider is operated, the angle of the drawn cannon changes
accordingly.

The Q on the Quit button is now underlined, and Alt-Q does what you
think it does.  If you do not know why, you didn't do the exercises in
chapter eight.

You may notice that the cannon flickers annoyingly, especially on a
slow machine.  We'll fix this in the next chapter.

<h2>Exercises</h2>

Set a different pen instead of NoPen.  Set a patterned brush.

Try "Q&uit" or "Qu&it" as button text instead of "&Quit" - what
happens?

You may now go on to \link t10.html chapter ten.  \endlink

[\link t8.html Previous tutorial\endlink]
[\link t10.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t10-lcdrange-h.html
<title>Qt Tutorial - t10/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t10.html tutorial 10\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t10/lcdrange.h
*/

/*! \page t10-lcdrange-cpp.html
<title>Qt Tutorial - t10/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t10.html tutorial 10\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t10/lcdrange.cpp
*/

/*! \page t10-cannon-h.html
<title>Qt Tutorial - t10/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t10.html tutorial 10\endlink: cannon.h</h1><br clear="all">
<hr>
\include t10/cannon.h
*/

/*! \page t10-cannon-cpp.html
<title>Qt Tutorial - t10/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t10.html tutorial 10\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t10/cannon.cpp
*/

/*! \page t10-main-cpp.html
<title>Qt Tutorial - t10/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t10.html tutorial 10\endlink: main.cpp</h1><br clear="all">
<hr>
\include t10/main.cpp
*/

/*! \page t10-makefile.html
<title>Qt Tutorial - t10/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t10.html tutorial 10\endlink</h1><br clear="all">
<hr>
\include t10/Makefile
*/



/*! \page t10.html


<title>
Qt Tutorial - Chapter 10: Smooth as Silk
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 10: Smooth as Silk</h1><br clear="all">



<center><img src="t10.png" alt="Screenshot of tutorial ten"></center>

In this example, we introduce painting in a pixmap to remove flickering.
We also add a force control.

<ul>
<li>\link t10-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t10-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t10-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t10-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t10-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t10-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for
<a href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>\link t10-cannon-h.html cannon.h\endlink</h3>

The CannonField now has a force value in addition to the angle.

\dontinclude t10/cannon.h

\skip angle
\until forceChanged

The interface to the force follows the same practice as for angle.

\skip private
\until cannonRect

We have put the definition of the cannon's enclosing rectangle in a
separate function.

\skip ang
\until };

The force is stored in the integer f.

<h3>\link t10-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t10/cannon.cpp

\skip include
\skip pixmap
\line pixmap

We include the QPixmap class definition.

\skip ::CannonField
\until }

The force (f) is initialized to zero.

\skip ::setAngle
\until }

We have made a slight change in the setAngle() function.  It repaints
only the portion of the widget that contains the cannon.  The FALSE
argument indicates that the specified rectangle should not be erased
before a paint event is sent to the widget.  This speeds up and smooths
drawing a little bit.

\skip ::setForce
\until }

The implementation of setForce() is quite similar to that of
setAngle().  The only difference is that since we don't show the force
value, we don't need to repaint the widget.

\skip ::paintEvent
\until return

We have now optimized the paint event to repaint only the parts of the
widget that need updating.  First we check whether we have to paint
anything at all, and return if we don't.

\line cannonRect
\line pix

Then we create a temporary pixmap, which we use for flicker-free
painting.  All the painting operations are done into this pixmap, and
then the pixmap is drawn on the screen in a single operation.

This is the essence of flicker-free drawing: Draw on each pixel
precisely once.  Less, and you get drawing errors.  More, and you get
flicker.  It doesn't matter much in this example - when the code was
written there were still machines slow enough for it to flicker, but
not any more.  We've kept the code for educational purposes.

\line fill

We fill the pixmap with the background from this widget.

\line QPainter
\until end

We paint, as in chapter 9, but now we paint in the pixmap.

At this point, we have a painter variable and a pixmap that looks
precisely right, but we still haven't painted on the screen.

\line begin
\line drawPixmap

So we open the painter on the CannonField itself and then draw the pixmap.

That's all.  A couple of extra lines at the top and a couple at the
bottom, and the code is 100% flicker-free.

\skip cannonRect
\until }

This function returns the rectangle enclosing the cannon in widget
coordinates.  First we create a rectangle with the size 50x50, then
move it so its bottom left corner is equal to the widget's own bottom
left corner.

The \l QWidget::rect() function returns the widget's enclosing
rectangle in the widget's own coordinates (where the top left corner
is 0,0).

<h3>\link t10-main-cpp.html main.cpp\endlink</h3>

\dontinclude t10/main.cpp

\skip MyWidget::MyWidget
\until {

The constructor is mostly the same, but some new bits have been added.

\skip force
\line force
\line force

We add a second LCDRange which will be used to set the force.

\skip force
\line connect
\line cannonField
\line connect
\line force

We connect the \c force widget and the \c cannonField widget just like
we did for the \c angle widget.

\skip QVBoxLayout
\line QVBoxLayout
\line addLayout
\line addWidget
\line addWidget

In chapter 9, we put \c angle in the lower-left cell of the layout.
Now, we want to have two widgets in that cell, so we make a vertical
box, put the vertical box in the grid cell, and put each of \c angle
and \c range in the vertical box.

\skip force
\line setValue

We initialize the force value to 25.

<h2>Behavior</h2>

The flicker has gone and we have a force control.


<h2>Exercises</h2>

Make the size of the cannon barrel be dependent on the force.

Put the cannon in the bottom right corner.

Try adding a better keyboard interface.  For example, make + and -
increase and decrease the force and enter shoot.  Hint: \l QAccel and
new addStep() and subtractStep() slots in LCDRange, like \l
QSlider::addStep().  If you're bothered by the way the left and right
keys work (I am!), change that too.

You may now go on to \link t11.html chapter eleven.  \endlink

[\link t9.html Previous tutorial\endlink]
[\link t11.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t11-lcdrange-h.html
<title>Qt Tutorial - t11/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t11.html tutorial 11\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t11/lcdrange.h
*/

/*! \page t11-lcdrange-cpp.html
<title>Qt Tutorial - t11/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t11.html tutorial 11\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t11/lcdrange.cpp
*/

/*! \page t11-cannon-h.html
<title>Qt Tutorial - t11/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t11.html tutorial 11\endlink: cannon.h</h1><br clear="all">
<hr>
\include t11/cannon.h
*/

/*! \page t11-cannon-cpp.html
<title>Qt Tutorial - t11/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t11.html tutorial 11\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t11/cannon.cpp
*/

/*! \page t11-main-cpp.html
<title>Qt Tutorial - t11/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t11.html tutorial 11\endlink: main.cpp</h1><br clear="all">
<hr>
\include t11/main.cpp
*/

/*! \page t11-makefile.html
<title>Qt Tutorial - t11/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t11.html tutorial 11\endlink</h1><br clear="all">
<hr>
\include t11/Makefile
*/



/*! \page t11.html


<title>
Qt Tutorial - Chapter 11: Giving It a Shot
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 11: Giving It a Shot</h1><br clear="all">



<center><img src="t11.png" alt="Screenshot of tutorial eleven"></center>

In this example, we introduce a timer to implement animated shooting.

<ul>
<li>\link t11-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t11-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t11-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t11-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t11-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t11-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>

<h3>\link t11-cannon-h.html cannon.h\endlink</h3>

The CannonField now has a shooting capabilities.

\dontinclude t11/cannon.h

\skip shoot
\line shoot

Calling this slot will make the cannon shoot if a shot is not in the air.

\line private
\line moveShot

This private slot is used to move the shot while it is in the air,
using a \l QTimer.

\skip private
\line private
\line paintShot

This private function paints the shot.

\skip shotRect
\line shotRect

This private function returns the shot's enclosing rectangle if
one is in the air, otherwise the returned rectangle is undefined.

\skip timerCount
\until shoot_f
\line };

These private variables contain information that describes the shot.  The
\c timerCount keeps track of the time passed since the shot was fired.
The \c shoot_ang is the cannon angle and \c shoot_f is the cannon force
when the shot was fired.


<h3>\link t11-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t11/cannon.cpp

\skip include
\skip math
\line math

We include the math library because we need the sin() and cos() functions.

\skip ::CannonField
\until }

We initialize our new private variables and connect the \l
QTimer::timeout() signal to our moveShot() slot.  We'll move the
shot every time the timer times out.

\skip ::shoot
\until start
\line }

This function shoots a shot unless a shot is in the air.  The \c timerCount
is reset to zero.  The \c shoot_ang and \c shoot_f are set to the current
cannon angle and force.  Finally we start the timer.

\skip ::moveShot
\until repaint
\line }

moveShot() is the slot that moves the shot, called every 50
milliseconds when the QTimer fires.

Its tasks are to compute the new position, repaint the screen with the
shot in the new position, and if necessary stop the timer.

First we make a \l QRegion that holds the old shotRect().  A QRegion
is capable of holding any sort of region, and we'll use it here to
simplify the painting.  shotRect() returns the rectangle where the
shot is now - it is explained in detail later.

Then we increment the \c timerCount, which has the effect of moving the
shot one step along its trajectory.

Next, we fetch the new shot rectangle.

If the shot has moved beyond the right or bottom edge of the widget, we
stop the timer.  Else, we add the new shotRect() to the QRegion.

Finally, we repaint the QRegion.  This will send a single paint event,
for just the one or two rectangles that need updating.

\skip ::paintEvent
\until }

The paint event function has been split in two since the previous
chapter.  Now, we fetch the bounding rectangle of the region that
needs painting, check whether it intersects either the cannon and/or
the shot, and if necessary call paintCannon() and/or paintShot().

\skip ::paintShot
\until drawRect
\line }

This private function paints the shot by drawing a black filled rectangle.

We leave out the implementation of paintCannon(); it is the same as
the paintEvent() from the previous chapter.

\skip ::shotRect
\until return
\line }

This private function calculates the center point of the shot and returns
the enclosing rectangle of the shot.  It uses the initial cannon force and
angle in addition to \c timerCount, which increases as time passes.

The formula used is the classical Newtonian formula for frictionless
movement in a gravity field.  For simplicity, we've chosen to
disregard any Einsteinian effects.

We calculate the center point in a coordinate system where y
coordinates increase upwards.  After we have calculated the center
point, we construct a QRect with size 6x6 and move its center point to
the point calculated above.  In the same operation, we convert the
point into the widget's coordinate system (see \link coordsys.html The
Coordinate System\endlink).

The qRound() function is an inline function defined in qglobal.h (included
by all other Qt header files).  qRound() rounds a double to the closest
integer.

<h3>\link t11-main-cpp.html main.cpp\endlink</h3>

\dontinclude t11/main.cpp

\skip class
\until };

The only addition is the shoot button.

\skip ::MyWidget
\skip shoot
\until setFont

In the constructor we create and set up the shoot button exactly like we
did with the quit button.  Note that the first argument to the constructor
is the button text and the third is the widget's name.

\skip connect
\line connect

Connects the clicked() signal of the shoot button to the shoot() slot
of the CannonField.


<h2>Behavior</h2>

The cannon can shoot, but there's nothing to shoot at.


<h2>Exercises</h2>

Make the shot a filled circle (hint: \l QPainter::drawEllipse() may
help).

Change the color of the cannon when a shot is in the air.

You may now go on to \link t12.html chapter twelve.  \endlink

[\link t10.html Previous tutorial\endlink]
[\link t12.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/



------------------------------------------------------------------------------


/*! \page t12-lcdrange-h.html
<title>Qt Tutorial - t12/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t12.html tutorial 12\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t12/lcdrange.h
*/

/*! \page t12-lcdrange-cpp.html
<title>Qt Tutorial - t12/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t12.html tutorial 12\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t12/lcdrange.cpp
*/

/*! \page t12-cannon-h.html
<title>Qt Tutorial - t12/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t12.html tutorial 12\endlink: cannon.h</h1><br clear="all">
<hr>
\include t12/cannon.h
*/

/*! \page t12-cannon-cpp.html
<title>Qt Tutorial - t12/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t12.html tutorial 12\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t12/cannon.cpp
*/

/*! \page t12-main-cpp.html
<title>Qt Tutorial - t12/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t12.html tutorial 12\endlink: main.cpp</h1><br clear="all">
<hr>
\include t12/main.cpp
*/

/*! \page t12-makefile.html
<title>Qt Tutorial - t12/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t12.html tutorial 12\endlink</h1><br clear="all">
<hr>
\include t12/Makefile
*/



/*! \page t12.html


<title>
Qt Tutorial - Chapter 12: Hanging in the Air the Way Bricks Don't
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 12: Hanging in the Air the Way Bricks Don't</h1><br clear="all">



<center><img src="t12.png" alt="Screenshot of tutorial twelve"></center>

In this example, we extend our LCDRange class to include a text label.
We also provide something to shoot at.

<ul>
<li>\link t12-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t12-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t12-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t12-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t12-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t12-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>


<h3>\link t12-lcdrange-h.html lcdrange.h\endlink</h3>

The LCDRange now has a text label.

\dontinclude t12/lcdrange.h

\skip QLabel
\line QLabel

We name declare QLabel since we want to use a pointer to it in the class
definition.

\skip class
\until parent=0
\line parent=0
\line name=0

We have added a new constructor that sets the label text in addition to
the parent and name.

\skip text
\line text

This function returns the label text.

\skip setText
\line setText

This slot sets the label text.

\skip private
\until init

Since we now have two constructors, we have chosen to put the common
initialization in the private init() function.

\skip QLabel
\line label

We also have a new private variable; a QLabel.  QLabel is one of Qt's
standard widgets and can show a text or a pixmap with or without a
frame.


<h3>\link t12-lcdrange-cpp.html lcdrange.cpp\endlink</h3>

\dontinclude t12/lcdrange.cpp

\skip qlabel
\line include

Here we include the QLabel class definition.

\skip ::LCDRange
\until }

This constructor calls the init() function, which contains the common
initialization code.

\skip ::LCDRange
\until }

This constructor first calls init(), then sets the label text.

\skip ::init
\until }

The set up of \c lcd and \c slider is the same as in the previous
chapter.  Next, we create a QLabel and tell it to align the contents
centered (both vertically and horizontally).  The connect() statements
have also been taken from the previous chapter.

\skip ::text
\until }

This function returns the label text.

\skip ::setText
\until }

This function sets the label text.

<h3>\link t12-cannon-h.html cannon.h\endlink</h3>

The CannonField now has two new signals: hit() and missed().  In addition
it contains a target.

\dontinclude t12/cannon.h

\skip slots
\skip newTarget
\line newTarget

This slot creates a target at a new position.

\skip signals
\until missed

The hit() signal is emitted when a shot hits the target.  The missed()
signal is emitted when the shot moves beyond the right or bottom edge
of the widget (i.e.  it has is certain that it has not and will not
hit the target).

\skip paintTarget
\line paintTarget

This private function paints the target.

\skip targetRect
\line targetRect

This private function returns the enclosing rectangle of the target.

\skip target
\line target

This private variable contains the center point of the target.


<h3>\link t12-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t12/cannon.cpp

\skip qdatetime
\line qdatetime

We include the QDate, QTime and QDateTime class definitions.

\skip stdlib
\line stdlib

We include the stdlib library because we need the rand() function.

\skip newTarget
\line newTarget

This line has been added to the constructor.  It creates a "random"
position for the target.  In fact, the newTarget() function will try
to paint the target.  Since we are in a constructor, the CannonField
widget is invisible.  Qt guarantees that no harm is done when calling
repaint() on a hidden widget.

\skip ::newTarget
\until repaint
\line }

This private function creates a target center point at a new "random"
position.

We use the rand() function to fetch random integers.  The rand() function
normally returns the same series of numbers each time you run a program.
This would make the target appear at the same position every time.  To
avoid this, we must set a random seed the first time this function is
called.  The random seed must also be random in order to avoid equal random
number series.  The solution is to use the number of seconds that have
passed since midnight as a pseudo-random value.

First we create a static bool local variable.  A static variable like
this one is guaranteed to keep its value between calls to the function.

The \c if test will only succeed the first time this function is called,
because we set \c first_time to FALSE inside the \c if block.

Then we create the QTime object \c midnight which represents the time
00:00:00.  Next, we fetch the number of seconds from midnight until
now and use it as a random seed.  See the documentation for \l QDate,
\l QTime and \l QDateTime for more information.

Finally, we calculate the target's center point.  We keep it within
the rectangle (x=200,y=35,width=190,height=255), (i.e.  the possible
x and y values are x = 200..390 and y = 35..290) in a coordinate system
where we put y position 0 at the bottom edge of the widget and let
y values increase upwards.  x is as normal, with 0 at the left edge and
with x values increasing to the right.

By experimentation, we have found this to always be in reach of the shot.

Note that rand() return a random integer >= 0.

\skip ::moveShot
\until QRect

This part of the timer event has not changed from the previous chapter.

\until hit

This \c if statement checks if the shot rectangle intersects the
target rectangle.  If it does, the shot has hit the target (ouchh!).
We stop the shoot timer and emit the hit() signal to tell the outside
world that a target was destroyed and return.

Note that we could have created a new target on the spot, but since the
CannonField is a component, we leave such decisions to the user of the
component.

\until missed

This \c if statement is the same as in the previous chapter, except that
it now emits the missed() signal to tell the outside world about the
failure.

\until }

And the rest of the function is as before.

CannonField::paintEvent() is as before, except that this has been
added:

\skip ::paintEvent
\skip targetRect
\line updateR
\line paintTarget

These two lines make sure the target too is painted, when necessary.

\skip ::paintTarget
\until }

This private function paints the target; a rectangle filled with red and
with a black outline.

\skip ::targetRect
\until }

This private function returns the enclosing rectangle of the target.
Remember from newTarget() that the \c target point uses y coordinate 0 at
the bottom of the widget.  We calculate the point in widget coordinates
before we call \l QRect::moveCenter().

The reason we have chosen this coordinate mapping is to fix the distance
between the target and the bottom of the widget.  Remember that the widget
can be resized by the user or the program at any time.

<h3>\link t12-main-cpp.html main.cpp\endlink</h3>

\dontinclude t12/main.cpp

There are no new members in the MyWidget class, but we have slightly
changed the constructor to set the new LCDRange text labels.

\skip ::MyWidget
\skip angle
\line ANGLE

We set the angle text label to "ANGLE".


\skip force
\line FORCE

We set the force text label to "FORCE".


<h2>Behavior</h2>

The cannon can shoot at a target and a new target is automatically created
when one has been hit.

The LCDRange widgets look a bit strange - the built-in layout
management in QVBox gives the labels too much space and the rest not
enough.  We'll fix that in the next chapter.

<h2>Exercises</h2>

Make a cheat button that when pressed makes the CannonField display
the shot trajectory for 5 seconds.

If you did the "round shot" exercise from the previous chapter, try
changing the shotRect() to a shotRegion() that returns a \l QRegion so
you can have really accurate collision detection.

Make a moving target.

Make sure the target is always created entirely on-screen.

Make sure that the widget cannot be resized so that the target isn't
visible.  Hint: \l QWidget::setMinimumSize() is your friend.

(Not easy:) Make it possible to have several shots in the air at the
same time.  Hint: make a Shot object.

You may now go on to \link t13.html chapter thirteen.  \endlink

[\link t11.html Previous tutorial\endlink]
[\link t13.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t13-lcdrange-h.html
<title>Qt Tutorial - t13/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t13/lcdrange.h
*/

/*! \page t13-lcdrange-cpp.html
<title>Qt Tutorial - t13/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t13/lcdrange.cpp
*/

/*! \page t13-cannon-h.html
<title>Qt Tutorial - t13/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: cannon.h</h1><br clear="all">
<hr>
\include t13/cannon.h
*/

/*! \page t13-cannon-cpp.html
<title>Qt Tutorial - t13/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t13/cannon.cpp
*/

/*! \page t13-gamebrd-h.html
<title>Qt Tutorial - t13/gamebrd.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: gamebrd.h</h1><br clear="all">
<hr>
\include t13/gamebrd.h
*/

/*! \page t13-gamebrd-cpp.html
<title>Qt Tutorial - t13/gamebrd.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: gamebrd.cpp</h1><br clear="all">
<hr>
\include t13/gamebrd.cpp
*/

/*! \page t13-main-cpp.html
<title>Qt Tutorial - t13/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t13.html tutorial 13\endlink: main.cpp</h1><br clear="all">
<hr>
\include t13/main.cpp
*/

/*! \page t13-makefile.html
<title>Qt Tutorial - t13/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t13.html tutorial 13\endlink</h1><br clear="all">
<hr>
\include t13/Makefile
*/



/*! \page t13.html


<title>
Qt Tutorial - Chapter 13: Game Over
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 13: Game Over</h1><br clear="all">



<center><img src="t13.png" alt="Screenshot of tutorial thirteen"></center>

In this example we start to approach a real playable game, with a
score.  We give MyWidget a new name (GameBoard) and add some slots.

We put the definition in gamebrd.h and the implementation in gamebrd.cpp.

The CannonField now has a game over state.

The layout problems in LCDRange are fixed.

<ul>
<li>\link t13-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t13-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t13-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t13-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t13-gamebrd-h.html gamebrd.h\endlink contains the GameBoard
class definition
<li>\link t13-gamebrd-cpp.html gamebrd.cpp\endlink contains the GameBoard
implementation
<li>\link t13-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t13-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>


<h3>\link t13-lcdrange-h.html lcdrange.h\endlink</h3>

\dontinclude t13/lcdrange.h

\skip include
\until QWidget

We inherit QWidget rather than QVBox: QVBox is very easy to use, but
again it showed its limitations, so we switch to the more powerful and
slightly harder to use QVBoxLayout.  (As you remember, QVBoxLayout is
not a widget, it manages one.)

<h3>\link t13-lcdrange-cpp.html lcdrange.cpp\endlink</h3>

\dontinclude t13/lcdrange.cpp

\skip layout
\line layout

We need to include qlayout.h now, to get the other layout management
API.

\line LCDRange
\line QWidget

We inherit QWidget in the usual way.

The other constructor has the same change.  init() is unchanged,
except that we've added some lines at the end:

\skip QVBoxLayout
\line QVBoxLayout

We create a QVBoxLayout with all the default values, managing this
widget's children.

\line addWidget

At the top, we add the QLCDNumber, with a non-zero stretch.

\line addWidget
\line addWidget

Then we add the other two, both with the default zero stretch.

This stretch control is something QVBoxLayout (and QHBoxLayout, and
QGridLayout) offers, but classes like QVBox do not.  In this case,
we're saying that the QLCDNumber should stretch and the others should
not.

<h3>\link t13-cannon-h.html cannon.h\endlink</h3>

The CannonField now has a game over state and a few new functions.

\dontinclude t13/cannon.h

\skip gameOver
\line gameOver

This function returns TRUE if the game is over, or FALSE if a game
is going on.

\skip setGameOver
\until restartGame

Here are two new slots; setGameOver() and restartGame().

\skip canShoot
\line canShoot

This new signal indicates that the CannonField is in a state where the
shoot() slot makes sense.  We'll use it below to enable/disable the
Shoot button.

\skip gameEnded
\line gameEnded

This private variable contains the game state.  TRUE means that the
game is over, and FALSE means that a game is going on.

<h3>\link t13-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t13/cannon.cpp

\skip ::CannonField
\skip gameEnded
\line gameEnded

This line has been added to the constructor.  Initially, the game is not
over (luckily for the player :-).

\skip ::shoot
\until }

We added a new isShooting() function, so shoot() uses it instead of
testing directly.  Also, shoot tells the world that the CannonField
cannot shot now.

\skip ::setGameOver
\until }

This slot ends the game.  It must be called from outside CannonField,
because this widget does not know when to end the game.  This is is an
important design principle in component programming.  We choose to
make the component as flexible as possible to make it usable with
different rules.  For example, a multi-player version of this, where
the first one to hit ten times could use the CannonField unchanged.

If the game has already been ended, we return immediately.  If a game is
going on, we stop the shot, set the game over flag and repaint the entire
widget.

\skip ::restartGame
\until }

This slot starts a new game.  If a shot is in the air, we stop shooting.
We then reset the \c gameEnded variable and repaint the widget.

moveShot() too emits the new canShoot(TRUE) signal at the same time as
either hit() or miss().

Modifications in CannonField::paintEvent():

\skip ::paintEvent
\until }

The paint event has been enhanced to display the text "Game Over" if
the game is over, i.e.  \c gameEnded is TRUE.  We don't bother to
check the update rectangle here, because speed is not critical when
the game is over.

To draw the text, we first set a black pen.  The pen color is used
when drawing text.  Next, we choose a 48 point bold font from the
Courier family.  Finally, we draw the text centered in the widget's
rectangle.  Unfortunately, on some systems (especially X servers with
Unicode fonts) it can take a while to load such a large font.  Since
Qt caches fonts, you will only notice this the first time the font is
used.

\until }

We only draw the shot when shooting and the target only when playing
(that is, when the game is not ended).


<h3>\link t13-gamebrd-h.html gamebrd.h\endlink</h3>

This file is new.  It contains the definition of the GameBoard class,
which was last seen as MyWidget.

\dontinclude t13/gamebrd.h

\skip include
\skip class
\until };

We have now added four slots.  These are protected and are used internally.
We have also added two QLCDNumbers: \c hits and \c shotsLeft, which display
the game status.


<h3>\link t13-gamebrd-cpp.html gamebrd.cpp\endlink</h3>

This file is new.  It contains the implementation of the GameBoard
class, which was last seen as MyWidget.

\dontinclude t13/gamebrd.cpp

We have made some changes in the GameBoard constructor.

\skip ::GameBoard
\skip cannonField
\line cannonField

\c cannonField is now a member variable, so we carefully change the
constructor to use it.  (The \e good programmers at Trolltech never
forget this, but I do.  Caveat programmor.  If "programmor" is latin,
at least.  Anyway, back to the code.)

\skip hit
\line connect
\line hit
\line connect
\line missed

This time we want to do something when the shot has hit or missed the
target.  Thus we connect the hit() and missed() signals of the
CannonField to two protected slots with the same names in this class.

\skip shoot
\skip connect
\line fire

Previously, we connected the shoot button's clicked() signal directly
to the CannonField's shoot() slot.  This time we want to keep track of
the number of shots fired, so we connect it to a protected slot in
this class instead.

Notice how easy it is to change the behavior of a program when you are
working with self-contained components.

\line connect
\line setEnabled

We also use the cannonField's canShoot() signal to enable or disable
the Shoot button appropriately.

\skip restart
\until connect

We create, set up and connect the New Game button like we have done
with the other buttons.  Clicking this button will activate the
newGame() slot in this widget.

\until shotsLeftL
\line QLabel

We create four new widgets.  Note that we don't bother to keep the
pointers to the QLabel widgets in the GameBoard class since there's
nothing much we want to do with them.  Qt will delete them when the
GameBoard widget is destroyed, and the layout classes will resize them
appropriately.

\skip QHBoxLayout
\until addStretch
\line addWidget

The number of widgets in the top-right cell is getting large.  Once it
was empty, now it's full enough that we group together the layout
setting for better overview.

Notice how we let all the widgets have their preferred sizes, instead
putting the stretch just to the left of the New Game button.

\skip newGame
\line newGame
\line }

We're all done constructing the GameBoard, so we start it all using
newGame().  (newGame() is a slot, but as we said, slots can be used as
ordinary functions too.)

\skip ::fire
\until }

This function fires a shot.  If the game is over or there is a shot in the
air, we return immediately.  We decrement number of shots left and tell
the cannon to shoot.

\skip ::hit
\until }

This slot is activated when a shot has hit the target.  We increment the
number of hits.  If there are no shots left, the game is over.  Otherwise,
we make the CannonField generate a new target.

\skip ::missed
\until }

This slot is activated when a shot has missed the target.  If there are no
shots left, the game is over.

\skip ::newGame
\until }

This slot is activated when the user clicks the restart button.  It is
also called from the constructor.  First, it sets the number of shots
to 15.  Note that this is the only place in the program that we set
the number of shots.  Change it to whatever you like to change the
game rules.  Next, we reset the number of hits, restart the game and
generate a new target.

<h3>\link t13-main-cpp.html main.cpp\endlink</h3>

This file has just been on a diet.  MyWidget is gone and the only
thing left is the main() function, unchanged except for the name
change.


<h2>Behavior</h2>

Hits and shots left are displayed and the program keeps track of them.
The game can end and there's a button to start a new game.


<h2>Exercises</h2>

Add a random wind factor and show it to the user.

Make some splatter effects when the shot hits the target.

Implement multiple targets.

You may now go on to \link t14.html chapter fourteen.  \endlink

[\link t12.html Previous tutorial\endlink]
[\link t14.html Next tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/


------------------------------------------------------------------------------


/*! \page t14-lcdrange-h.html
<title>Qt Tutorial - t14/lcdrange.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: lcdrange.h</h1><br clear="all">
<hr>
\include t14/lcdrange.h
*/

/*! \page t14-lcdrange-cpp.html
<title>Qt Tutorial - t14/lcdrange.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: lcdrange.cpp</h1><br clear="all">
<hr>
\include t14/lcdrange.cpp
*/

/*! \page t14-cannon-h.html
<title>Qt Tutorial - t14/cannon.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: cannon.h</h1><br clear="all">
<hr>
\include t14/cannon.h
*/

/*! \page t14-cannon-cpp.html
<title>Qt Tutorial - t14/cannon.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: cannon.cpp</h1><br clear="all">
<hr>
\include t14/cannon.cpp
*/

/*! \page t14-gamebrd-h.html
<title>Qt Tutorial - t14/gamebrd.h</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: gamebrd.h</h1><br clear="all">
<hr>
\include t14/gamebrd.h
*/

/*! \page t14-gamebrd-cpp.html
<title>Qt Tutorial - t14/gamebrd.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: gamebrd.cpp</h1><br clear="all">
<hr>
\include t14/gamebrd.cpp
*/

/*! \page t14-main-cpp.html
<title>Qt Tutorial - t14/main.cpp</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Source code for \link t14.html tutorial 14\endlink: main.cpp</h1><br clear="all">
<hr>
\include t14/main.cpp
*/

/*! \page t14-makefile.html
<title>Qt Tutorial - t14/makefile</title>
</head><body bgcolor="#ffffff">
\postheader

<h1 align=center>Unix Makefile for \link t14.html tutorial 14\endlink</h1><br clear="all">
<hr>
\include t14/Makefile
*/



/*! \page t14.html


<title>
Qt Tutorial - Chapter 14: Facing the Wall
</title></head><body bgcolor="#ffffff">

\postheader

<h1 align=center>Chapter 14: Facing the Wall</h1><br clear="all">



<center><img src="t14.png" alt="Screenshot of tutorial fourteen"></center>

This is the final example, a complete game.

We add keyboard accelerators, introduce mouse events to CannonField.  We
put a frame around the CannonField and add a barrier (wall) to make the
game more challenging.

<ul>
<li>\link t14-lcdrange-h.html lcdrange.h\endlink contains the LCDRange
class definition
<li>\link t14-lcdrange-cpp.html lcdrange.cpp\endlink contains the LCDRange
implementation
<li>\link t14-cannon-h.html cannon.h\endlink contains the CannonField class
definition
<li>\link t14-cannon-cpp.html cannon.cpp\endlink contains the CannonField
implementation
<li>\link t14-gamebrd-h.html gamebrd.h\endlink contains the GameBoard
class definition
<li>\link t14-gamebrd-cpp.html gamebrd.cpp\endlink contains the GameBoard
implementation
<li>\link t14-main-cpp.html main.cpp\endlink contains MyWidget and main.
<li>\link t14-makefile.html Makefile\endlink contains some rules for
generating the meta object information necessary for <a
href="signalsandslots.html">signal/slot creation.</a>
</ul>

<h2>Line by Line Walk-Through</h2>


<h3>\link t14-cannon-h.html cannon.h\endlink</h3>

The CannonField can now receive mouse events to make the user aim the
barrel by clicking on it and dragging.  CannonField also has a barrier
wall.


\dontinclude t14/cannon.h

\skip CannonField
\skip protected
\until mouseReleaseEvent

In addition to the familiar event handlers, CannonField implements
three mouse event handlers.  The names say it all.

\skip paintBarrier
\line paintBarrier

This private function paints the barrier wall.

\skip barrierRect
\line barrierRect

This private function returns the enclosing rectangle of the barrier.

\skip barrelHit
\line barrelHit

This private function checks if a point is inside the barrel of the cannon.

\skip barrelPressed
\line barrelPressed

This private variable is TRUE if the user has pressed the mouse on the
barrel and not released it.


<h3>\link t14-cannon-cpp.html cannon.cpp\endlink</h3>

\dontinclude t14/cannon.cpp

\skip ::CannonField
\skip barrelPressed
\line barrelPressed

This line has been added to the constructor.  Initially, the mouse is
not pressed on the barrel.

\skip ::moveShot
\skip else
\until }

Now that we have a barrier there are three ways to miss.  We test for
the third, too.

\skip ::mousePressEvent
\until }

This is a Qt event handler.  It is called when the user presses a
mouse button when the mouse cursor is over the widget.

If the event was not generated by the left mouse button, we return
immediately.  Otherwise, we check if the position of the mouse cursor
is within the cannon's barrel.  If it is, we set \c barrelPressed to
TRUE.

Notice that the pos() function returns a point in the widget's
coordinate system.

\skip ::mouseMoveEvent
\until setAngle
\line }

This is another Qt event handler.  It is called when the user already
has pressed the mouse button inside this widget and then moves/drags
the mouse.  (You can make Qt send mouse move events even when no
buttons are pressed too, see \l QWidget::setMouseTracking().)

This handler repositions the cannon's barrel according to the position of
the mouse cursor.

First, if the barrel is not pressed, we return.  Next, we fetch the
mouse cursor's position.  If the mouse cursor is to the left or below
the widget, we adjust the point to be inside the widget.

Then we calculate the angle between the bottom edge of the widget and
the imaginary line between the bottom left corner of the widget and
the cursor position.  Finally, we set the cannon's angle to the new
value converted to degrees.

Remember that setAngle() redraws the cannon.

\skip ::mouseReleaseEvent
\until }

This Qt event handler is called whenever the user releases a mouse
button and it was pressed inside this widget.

If the left button is released, we can be sure that the barrel is no
longer pressed.

The paint event has two extra lines:

\skip ::paintEvent
\skip barrierRect
\line barrierRect
\line paintBarrier

paintBarrier() does the same sort of thing as paintShot(),
paintTarget() and paintCannon().

\skip ::paintBarrier
\until }

This private function paints the barrier as a rectangle filled with
yellow and with a black outline.

\skip ::barrierRect
\until }

This private function returns the rectangle of the barrier.  We fix
the bottom edge of the barrier to the bottom edge of the widget.

\skip ::barrelHit
\until }

This function returns TRUE if the point is in the barrel, otherwise
FALSE.

Here we use the class \l QWMatrix.  It is defined in the header file
qwmatrix.h, which is included by qpainter.h.

QWMatrix defines a coordinate system mapping.  It can perform the same
transformations as the QPainter.

Here we perform the same transformation steps as we do when drawing
the barrel in the paintCannon() function.  First we translate the
coordinate system, then we rotate it.

Now we need to check if the point \c p (in widget coordinates) lies
inside the barrel.  To do this, we invert the transformation matrix.
The inverted matrix performs the inverse transformation that we used
when drawing the barrel.  We map the point \c p using the inverted
matrix and return TRUE if it is inside the original barrel rectangle.


<h3>\link t14-gamebrd-cpp.html gamebrd.cpp\endlink</h3>

\dontinclude t14/gamebrd.cpp

\skip qaccel.h
\line qaccel.h

We include the class definition of \l QAccel.

\skip ::GameBoard
\skip QVBox
\line QVBox
\line setFrameStyle
\line cannonField

We create and set up a \l QVBox, set its frame style, and then create
\c cannonField as a child of that box.  Since nothing else is in the
box, the effect is that the QVBox will put a frame around the
CannonField.

\skip QAccel
\line accel
\line connectItem
\line fire
\line connectItem
\line fire

Here we create and set up an accelerator.  An accelerator is an object
that intercepts keyboard events to an application and calls slots if
certain keys are pressed.  This mechanism is also called shortcut
keys.  Note that an accelerator is a child of a widget and will be
destroyed when that widget is destroyed.  QAccel is \e not a widget
and has no visible effect on its parent.

We define two shortcut keys.  We want the slot fire() to be called
when the user presses Enter, and we want the application to quit when
key Control-Q is pressed.  Since Enter is sometimes Return and there
are even keyboard with \e both keys, we make both Enter and Return
invoke fire().

\line connectItem
\line quit

And then we set up Control-Q to do the same thing as Alt-Q.  Some
people are more used to Control-Q, and anyway it shows how do do it.

CTRL, Key_Enter, Key_Return and Key_Q are all constants provided by
Qt.  They're actually Qt::Key_Enter etc. but practically all classes
inherit the \l Qt namespace class.

\line QGridLayout
\line addWidget
\line addWidget
\line setColStretch

We put \c box (the QVBox), not the CannonField, in the lower right
cell.

<h2>Behavior</h2>

The cannon now shoots when you press Enter.  You can also position the
cannon's angle using the mouse.  The barrier makes it a little more
challenging to play the game.  We also have a nice looking frame
around the CannonField.


<h2>Exercises</h2>

Write a space invaders game.
<p>
(This exercise was first done by
<a href="mailto:igorr@ifi.uio.no">Igor Rafienko</a>.  You can
<a href="http://www.stud.ifi.uio.no/~igorr/download.html">
download his game</a>.)
<p>
The new exercise is:
<p>
Write a Breakout game and give it to the
<a href="http://www.kde.org">KDE project.</a>
<p>

You may now go on to write your own Qt applications.

[\link t13.html Previous tutorial\endlink]
[\link t1.html First tutorial\endlink]
[\link tutorial.html Main tutorial page\endlink]

*/
