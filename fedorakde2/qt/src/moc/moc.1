.TH moc 1 "20 January 2001" "Trolltech AS" \" -*- nroff -*-
.\"
.\" $Id: qt/src/moc/moc.1   2.3.2   edited 2001-05-15 $
.\"
.\" Copyright 1992-2001 Trolltech AS.  All rights reserved.
.\"
.\" This file is part of Qt and may be distributed and used according to
.\" the terms and conditions described in the LICENSE file.
.\"
.nh
.SH NAME
moc \- generate Qt meta object support code
.SH SYNOPSIS
.B moc
[-o file] [-i] [-f] [-k] [-ldbg] [-nw] [-p path] [-q path] file
.SH DESCRIPTION
This page documents the
.B Meta Object Compiler
for the Qt GUI application framework. The
.B moc
reads one or more C++ class declarations from a C++ header or source
file and generates one C++ source file containing meta object
information for the classes. The C++ source file generated by the
.B moc
must be compiled and linked with the implementation of the class (or it
can be #included into the class' source file).
.PP
In brief, the meta object system is a structure used by Qt (see
.BR http://doc.trolltech.com ")"
for component programming and run time type information.  It adds
properties and inheritance information to (some) classes and
provides a new type of communication between those instances of those
classes, signal-slot
connections.
.SH OPTIONS
.TP
.I "-o file"
Write output to
.I file
rather than to stdout.
.TP
.I -f
Force the generation of an #include statement in the output.
This is the default for files whose name matches the regular
expression .[hH][^.]* (ie. the extension starts with
.B H
or
.B h
). This
option is only useful if you have header files that do not follow the
standard naming conventions.
.TP
.I "-i"
Do not generate an #include statement in the output.  This may be used
to run
.B moc
on a C++ file containing one or more class declarations. You should then
#include the meta object code in the .cpp file (see USAGE below).  If both
.I -f
and
.I -i
are present, the last one wins.
.TP
.I "-nw"
Do not generate any warnings. Discouraged.
.TP
.I "-ldbg"
Write a flood of lex debug information on stdout.
.TP
.I "-p path"
Makes
.B moc
prepend
.IR path /
to the file name in the generated #include statement (if one is generated).
.TP
.I "-q path"
Makes
.B moc
prepend
.IR path /
to the file name of qt #include files in the generated code.
.PP
You can explicitely tell the
.B moc
to not parse parts of a header
file. It recognizes any C++ comment (//) that contains the substrings
MOC_SKIP_BEGIN or MOC_SKIP_END. They work as you would expect and you
can have several levels of them. The net result as seen by the
.B moc
is as if you had removed all lines between a MOC_SKIP_BEGIN and a
MOC_SKIP_END
.SH USAGE
.B moc
is almost always invoked by
.BR make (1),
not by hand.
.PP
.B moc
is typically used with an input file containing class declarations
like this skeleton:
.PP
.in +4
.nf
class YourClass: public QObject {
    Q_OBJECT
    Q_PROPERTY( ... )
    Q_CLASSINFO( ... )

public:
    YourClass( QObject * parent=0, const char * name=0 );
    ~YourClass();

signals:

public slots:

};
.fi
.in -4
.PP
Here is a useful makefile rule if you only use GNU make:
.PP
.in +4
.nf
m%.cpp: %.h
        moc $< -o $@
.fi
.in -4
.PP
If you want to write portably, you can use individual rules of the
following form:
.PP
.in +4
.nf
mNAME.cpp: NAME.h
        moc $< -o $@
.fi
.in -4
.PP
You must also remember to add
.I mNAME.cpp
to your SOURCES (substitute your favorite name) variable and
.I mNAME.o
to your OBJECTS variable.
.PP
(While we prefer to name our C++ source files .cpp, the
.B moc
doesn't know that, so you can use .C, .cc, .CC, .cxx or even .c++ if
you prefer.)
.PP
If you have class declarations in C++ files, we recommend that you use
a makefile rule like this:
.PP
.in +4
.nf
NAME.o: mNAME.cpp

mNAME.cpp: NAME.cpp
        moc -i $< -o $@
.fi
.in -4
.PP
This guarantees that
.BR make (1)
will run the
.B moc
before it compiles
.IR NAME.cpp .
You can then put
.PP
.ti +4
#include "nNAME.cpp"
.PP
at the end of
.IR NAME.cpp ,
where all the classes declared in that file are fully known.
.SH DIAGNOSTICS
Sometimes you may get linkage errors, saying that
YourClass::className() is undefined or that YourClass lacks a vtbl.
Those errors happen most often when you forget to compile the
moc-generated C++ code or include that object file in the link
command.
.PP
The
.B moc
will warn you about a number of dangerous or illegal constructs.
.SH BUGS

The
.B moc
does not expand #include or #define, it simply skips any preprocessor
directives it encounters. This is regrettable, but is normally not a
problem in practice.

The
.B moc
does not handle all of C++.  The main problem is that class templates
cannot have signals or slots.  This is an important bug.  Here is an
example:
.PP
.in +4
.nf
class SomeTemplate<int>: public QFrame {
    Q_OBJECT
    [...]
signals:
    void bugInMocDetected( int );
};
.fi
.in -4
.PP
Less importantly, the following constructs are illegal.  All of them
have have alternatives which we think are usually better, so removing
these limitations is not a high priority for us.
.SS "Multiple inheritance requires QObject to be first."
If you are using multiple inheritance, moc assumes that the
.B first
inherited class is a subclass of QObject.  Also, be sure that
.B only
the first inherited class is a QObject.
.PP
.in +4
.nf
class SomeClass: public QObject, public OtherClass {
    [...]
};
.fi
.in -4
.PP
This bug is almost impossible to fix; since the
.B moc
does not expand
#include or #define, it cannot find out which one of the base classes is a
QObject.
.SS "QObject may not be virtually inherited"
You can not use virtual inheritance in the QObject branch of the
inheritance tree. The following example shows one wrong and one
correct class declaration:
.PP
.in +4
.nf
class Wrong: virtual public QObject, virtual public Other {
    [...]
};

class Right: public QObject, virtual public Other {
    [...]
};
.fi
.in -4
.SS "Virtual functions cannot be slots when using multiple inheritance"
This problem occurs if you are using multiple inheritance. If you
reimplement a virtual function as a slot
.B and
that function was originally declared in a class that does not inherit
QObject, your program may crash when a signal triggers the slot.
(This only happens with some compilers.)
.PP
The following example shows one wrong and two correct slot definitions.
.PP
.in +4
.nf
class BaseClass {
    [...]
    virtual void setValue( int );
};

class SubClass: public QObject, public BaseClass {
    [...]
public slots:
    void setValue( int ); // illegal
    void slotSetValue( int i ) { setValue(i); } // ok
    void setName( const char* ); // ok
};
.fi
.in -4
.PP
(For those interested in C++ internals: The cause of this problem is
that a slot is internally represented as a function pointer, and
invoked on a QObject pointer. )
.SS "Function pointers can not be arguments to signals or slots."
In most cases where you would consider that, we think inheritance is a
better alternative.  Here is an example of illegal syntax:
.PP
.in +4
.nf
class someClass: public QObject {
    Q_OBJECT
    [...]
public slots:
    void apply(void (*ApplyFunction)(QList*, void*)); // illegal
};
.fi
.in -4
.PP
You can work around this restriction like this:
.PP
.in +4
.nf
typedef void (*ApplyFunctionType)(QList*, void*);

class someClass: public QObject {
    Q_OBJECT
    [...]
public slots:
    void apply( ApplyFunctionType );
};
.fi
.in -4
.PP
(It may sometimes be even better to replace the function pointer with
inheritance and virtual functions, signals or slots.)
.SS "Friend declarations can not be placed in signals or slots sections"
Sometimes it will work, but in general, friend declarations can not be
placed in
.B signals
or
.B slots
sections.  Put them in the good old
.BR private ", " protected
or
.B public
sections instead.  Here is an example of the illegal syntax:
.PP
.in +4
.nf
class someClass: public QObject {
    Q_OBJECT
    [...]
signals:
    friend class ClassTemplate<char>; // illegal
};
.fi
.in -4
.SS "Signals and slots cannot be upgraded"
The C++ feature of upgrading an inherited member function to
.B public
status is not extended to cover signals and slots.  Here is an illegal
example:
.PP
.in +4
.nf
class Whatever: public QButtonGroup {
    [...]
public slots:
    void QButtonGroup::buttonPressed(); // illegal
};
.fi
.in -4
.PP
The QButtonGroup::buttonPressed() slot is protected.
.PP
C++ quiz: What happens if you try to upgrade a protected member
function which is overloaded?
.IP
- All the functions are upgraded.
.IP
- That is not legal C++.
.\" Good idea, but look in the SEE ALSO section...
.SS "Type macros can not be used for signal and slot arguments"

Since the
.B moc
does not expand #define, type macros that take an argument
will not work in signals and slots. Here is an illegal example:
.PP
.in +4
.nf
#ifdef ultrix
#define SIGNEDNESS(a) unsigned a
#else
#define SIGNEDNESS(a) a
#endif
class Whatever: public QObject {
[...]
signals:
    void someSignal( SIGNEDNESS(a) ); // illegal
};
.PP
A #define without arguments works.
.fi
.in -4
.SS  "Nested classes cannot be in the signals or slots sections nor have signals or slots"
Here's an example:
.PP
.in +4
.nf
class A {
    Q_OBJECT
public:
    class B {
    public slots: // illegal
        void b();
    [....]
    };
signals:
    class B {  // illegal
        void b();
	[....]
    }:
};
.fi
.in -4
.PP
.SS "Constructors can not be used in signals or slots sections"
It is a mystery to me why anyone would put a constructor on either the
.B signals
or
.B slots
sections.  You can not, anyway (except that it happens to work in some
cases).  Put them in
.BR private ", " protected
or
.B public
sections, where they belong.  Here is an example of the illegal syntax:
.PP
.in +4
.nf
class SomeClass: public QObject {
    Q_OBJECT
public slots:
    SomeClass( QObject *parent, const char *name )
        : QObject( parent, name ) {} // illegal
    [...]
};
.fi
.in -4
.SS "Signals and slots may not have default arguments"
Since signal->slot binding occurs at run-time, it is
conceptually difficult to use default parameters, which are a
compile-time phenomenon.  This will fail:
.PP
.in +4
.nf
class SomeClass: public QObject {
    Q_OBJECT
public slots:
    void someSlot(int x=100); // illegal
};
.fi
.in -4
.SS "Signals and slots may not have template arguments"
.PP
Declaring signals and slots with template-type parameters will not
work as expected, even though the
.B moc
will not complain. Connecting the
signal to the slot in the following example, the slot will not get
executed when the signal is emitted:
.PP
.in +4
.nf
public slots:
    void MyWidget::setLocation(pair<int,int> location); // illegal
    [...]
public signals:
    void MyObject::moved(pair<int,int> location); // illegal
.fi
.in -4
.PP
However, you can work around this limitation by explicitly typedef'ing
the parameter types, like this:
.PP
.in +4
.nf
typedef pair<int,int> IntPair;	

public slots:
    void MyWidget::setLocation(IntPair location);
    [...]
public signals:
    void MyObject::moved(IntPair location);
.fi
.in -4
.PP
This will work as expected.

.SS "Namespace of parent class must be specified even if it is the same as that of the subclass"
.PP
In the following example, classes x::A and x::B are defined:
.PP
.in +4
.nf
namespace x {
    class A : public QObject {
        Q_OBJECT

    public:
        ...
    };
}

namespace x {
    class B : public A {
        Q_OBJECT

    public:
        ...
    };
}
.fi
.in -4
.PP
Unfortunately,
.B moc
will not understand the
.PP
.in +4
.nf
    class B : public A {
.fi
.in -4
.PP
line. You have either to write
.PP
.in +4
.nf
    class B : public x::A {
.fi
.in -4
.PP
or define classes A and B in the same namespace block.
.PP
This limitation will disappear with Qt 3.0.

.SS "Properties need to be declared before the public section that contains the respective get and set functions"
.PP
Declaring the first property within or after the public section that
contains the type definition and the respective get and set functions
does not work as expected. The
.B moc
will complain that it can neither
find the functions nor resolve the type. Here is an example of the
illegal syntax:
.PP
.in +4
.nf
class SomeClass: public QObject {
    Q_OBJECT
public:
    [...]
    // illegal
    Q_PROPERTY( Priority priority READ priority WRITE setPriority )
    Q_ENUMS( Priority )
    enum Priority { High, Low, VeryHigh, VeryLow };
    void setPriority( Priority );
    Priority priority() const;
    [...]
};
.fi
.in -4
.PP
Work around this limitation by declaring all properties at the
beginning of the class declaration, right after Q_OBJECT:
.PP
.in +4
.nf
class SomeClass: public QObject {
    Q_OBJECT
    Q_PROPERTY( Priority priority READ priority WRITE setPriority )
    Q_ENUMS( Priority )
public:
    [...]
    enum Priority { High, Low, VeryHigh, VeryLow };
    void setPriority( Priority );
    Priority priority() const;
    [...]
};
.fi
.in -4
.PP
.SH "SEE ALSO"
.BR http://www.trolltech.com/ " and"
.BR "C++ ARM, section r.11.3" " (for the answer to the quiz.)"
.SH AUTHOR
Eirik Eng, Trolltech <eiriken@trolltech.com>
